# 트랜잭션 이론 (Transaction Theory)

## 개요

트랜잭션은 데이터베이스의 **논리적 작업 단위**로, 여러 연산을 하나의 원자적 단위로 묶는다. ACID 속성을 통해 동시성과 장애 상황에서도 데이터 일관성을 보장한다. 직렬화 가능성(Serializability)은 동시 실행의 정확성을 판단하는 이론적 기준이다.

## 핵심 개념

### 1. ACID 속성

```
┌─────────────────────────────────────────────────────────────┐
│                    ACID Properties                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ A - Atomicity (원자성)                                      │
│   "All or Nothing"                                          │
│   트랜잭션의 모든 연산이 완료되거나, 하나도 반영 안 됨      │
│   구현: Undo 로그, WAL                                      │
│                                                             │
│ C - Consistency (일관성)                                    │
│   트랜잭션 전후로 데이터베이스가 일관된 상태 유지           │
│   제약조건 (PK, FK, CHECK 등) 만족                         │
│   구현: 제약조건 검사, 애플리케이션 로직                    │
│                                                             │
│ I - Isolation (격리성)                                      │
│   동시 실행 트랜잭션이 서로 간섭하지 않음                   │
│   각 트랜잭션이 혼자 실행되는 것처럼 보임                   │
│   구현: 잠금, MVCC, 타임스탬프                              │
│                                                             │
│ D - Durability (지속성)                                     │
│   커밋된 트랜잭션은 영구 저장                               │
│   시스템 장애 후에도 복구 가능                              │
│   구현: WAL, Force at Commit                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2. 트랜잭션 상태 다이어그램

```
┌─────────────────────────────────────────────────────────────┐
│              트랜잭션 상태 전이                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│              BEGIN                                          │
│                │                                            │
│                ▼                                            │
│          ┌─────────┐                                       │
│          │ Active  │ ← 연산 실행 중                        │
│          └─────────┘                                       │
│           │       │                                        │
│    성공   │       │ 오류/ABORT                             │
│           ▼       ▼                                        │
│   ┌───────────┐  ┌─────────┐                              │
│   │ Partially │  │ Failed  │                              │
│   │ Committed │  └─────────┘                              │
│   └───────────┘       │                                    │
│           │           │                                    │
│   커밋    │           │ 롤백                               │
│           ▼           ▼                                    │
│     ┌───────────┐  ┌─────────┐                            │
│     │ Committed │  │ Aborted │                            │
│     └───────────┘  └─────────┘                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

```sql
-- 트랜잭션 예시
BEGIN;                           -- Active 상태
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;                          -- Committed 상태

-- 오류 시
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- 제약조건 위반 또는 오류 발생
ROLLBACK;                        -- Aborted 상태
```

### 3. 직렬화 가능성 (Serializability)

동시 실행의 정확성 기준:

```
┌─────────────────────────────────────────────────────────────┐
│              직렬화 가능성                                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 정의: 동시 실행의 결과가 어떤 직렬 실행(serial execution)   │
│       의 결과와 동일하면, 직렬화 가능(serializable)        │
│                                                             │
│ 직렬 실행 (Serial): T1 완전 종료 후 T2 시작                 │
│   T1: R(A) W(A) Commit                                     │
│   T2:                    R(A) W(A) Commit                  │
│                                                             │
│ 동시 실행 (Concurrent): 인터리빙                            │
│   T1: R(A)     W(A)          Commit                        │
│   T2:      R(A)     W(A)           Commit                  │
│                                                             │
│ 질문: 이 동시 실행이 T1→T2 또는 T2→T1과 동일한 결과?       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4. 충돌 직렬화 가능성 (Conflict Serializability)

```
┌─────────────────────────────────────────────────────────────┐
│              충돌의 정의                                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 두 연산이 충돌: 같은 데이터 항목, 적어도 하나가 쓰기        │
│                                                             │
│ 충돌 유형:                                                   │
│ - Read-Write (RW): T1이 읽고, T2가 씀 (또는 반대)          │
│ - Write-Read (WR): T1이 쓰고, T2가 읽음 (또는 반대)        │
│ - Write-Write (WW): T1이 쓰고, T2가 씀 (또는 반대)         │
│                                                             │
│ Read-Read: 충돌 아님 (순서 바꿔도 결과 동일)               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**충돌 직렬화 가능 조건:**

```
스케줄 S가 충돌 직렬화 가능 ⟺
비충돌 연산들의 순서만 바꿔서 직렬 스케줄로 변환 가능

검증 방법: 선행 그래프 (Precedence Graph)
```

### 5. 선행 그래프 (Precedence Graph)

```
┌─────────────────────────────────────────────────────────────┐
│              선행 그래프 구성                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 노드: 각 트랜잭션                                            │
│ 간선: Ti → Tj (Ti의 연산이 Tj의 충돌 연산보다 먼저)         │
│                                                             │
│ 예시 스케줄:                                                 │
│ T1: R(A)      W(A)                                          │
│ T2:      R(A)      W(A)                                     │
│                                                             │
│ 충돌 분석:                                                   │
│ - T1.R(A) < T2.R(A): 충돌 아님 (RR)                         │
│ - T1.R(A) < T2.W(A): 충돌, T1 → T2                          │
│ - T2.R(A) < T1.W(A): 충돌, T2 → T1                          │
│ - T1.W(A) < T2.W(A): 충돌, T1 → T2                          │
│                                                             │
│ 선행 그래프:                                                 │
│     T1 ←→ T2  (양방향 간선 = 사이클!)                       │
│                                                             │
│ 결론: 사이클 있음 → 충돌 직렬화 불가능                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**사이클이 없는 예:**

```
스케줄:
T1: R(A) W(A)
T2:            R(A) W(A)

선행 그래프:
T1 → T2 (사이클 없음)

→ 충돌 직렬화 가능, T1 → T2 직렬 실행과 동등
```

### 6. 뷰 직렬화 가능성 (View Serializability)

```
┌─────────────────────────────────────────────────────────────┐
│              뷰 직렬화 가능성                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 정의: 두 스케줄 S1, S2가 뷰 동등(view equivalent)이면:     │
│                                                             │
│ 1. 같은 데이터를 읽음: Ti가 S1에서 X의 초기값을 읽으면     │
│    S2에서도 초기값을 읽음                                   │
│                                                             │
│ 2. 같은 값을 읽음: Ti가 S1에서 Tj가 쓴 X를 읽으면          │
│    S2에서도 Tj가 쓴 X를 읽음                               │
│                                                             │
│ 3. 최종 쓰기 동일: S1에서 Ti가 X의 마지막 쓰기면           │
│    S2에서도 Ti가 X의 마지막 쓰기                           │
│                                                             │
│ 관계:                                                        │
│ 충돌 직렬화 가능 ⊂ 뷰 직렬화 가능 ⊂ 직렬화 가능            │
│                                                             │
│ 실용성: 뷰 직렬화 검사는 NP-Complete                        │
│        → 실제로는 충돌 직렬화 기반 프로토콜 사용             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 7. 복구 가능성 (Recoverability)

```
┌─────────────────────────────────────────────────────────────┐
│              복구 가능성 수준                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ Recoverable (복구 가능):                                    │
│   Ti가 Tj가 쓴 데이터를 읽었으면, Tj가 먼저 커밋           │
│   → 연쇄 중단(Cascading Abort) 발생 가능                   │
│                                                             │
│ Cascadeless (연쇄 중단 없음):                               │
│   Ti가 Tj가 쓴 데이터를 읽으려면, Tj가 이미 커밋됨         │
│   → 읽는 시점에 이미 커밋된 데이터만 읽음                   │
│                                                             │
│ Strict:                                                      │
│   Ti가 Tj가 쓴 데이터를 읽거나 덮어쓰려면, Tj가 이미 커밋  │
│   → 커밋 전 데이터에 접근 불가                              │
│                                                             │
│ 관계:                                                        │
│ Strict ⊂ Cascadeless ⊂ Recoverable                         │
│                                                             │
│ 대부분의 DBMS: Strict 스케줄 사용                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 8. 동시성 제어 프로토콜 개요

```
┌─────────────────────────────────────────────────────────────┐
│              동시성 제어 방법                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 비관적 (Pessimistic):                                       │
│   충돌이 발생할 것으로 가정하고 미리 방지                   │
│   - Two-Phase Locking (2PL)                                │
│   - Timestamp Ordering                                      │
│                                                             │
│ 낙관적 (Optimistic):                                        │
│   충돌이 드물 것으로 가정하고 실행 후 검증                  │
│   - Optimistic Concurrency Control (OCC)                   │
│   - MVCC (Multi-Version Concurrency Control)               │
│                                                             │
│ 실제 DBMS:                                                   │
│ - PostgreSQL: MVCC + SSI (Serializable Snapshot Isolation) │
│ - MySQL InnoDB: MVCC + 2PL (잠금 기반)                      │
│ - Oracle: MVCC                                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 실무 적용

### 트랜잭션 사용 패턴

```sql
-- 패턴 1: 명시적 트랜잭션
BEGIN;
-- 여러 연산
COMMIT;

-- 패턴 2: SAVEPOINT 활용
BEGIN;
UPDATE ...;
SAVEPOINT sp1;
UPDATE ...;  -- 실패 가능
ROLLBACK TO sp1;  -- 부분 롤백
UPDATE ...;  -- 다른 시도
COMMIT;

-- 패턴 3: 자동 커밋 비활성화
SET autocommit = 0;  -- MySQL
-- 또는 SET autocommit = off;  -- PostgreSQL (기본이 off)
```

### 트랜잭션 모니터링

```sql
-- PostgreSQL: 현재 트랜잭션 확인
SELECT * FROM pg_stat_activity WHERE state != 'idle';

-- 장기 실행 트랜잭션 탐지
SELECT
    pid,
    now() - xact_start AS duration,
    state,
    query
FROM pg_stat_activity
WHERE xact_start IS NOT NULL
ORDER BY xact_start;

-- MySQL: 트랜잭션 확인
SELECT * FROM information_schema.innodb_trx;
```

## 참고 자료

- "Database System Concepts" (Silberschatz) - Chapter 17, 18
- "Transaction Processing: Concepts and Techniques" (Gray, Reuter)
- CMU 15-445: Concurrency Control
- PostgreSQL Documentation: Transaction Isolation

# B+Tree 내부 구조 (B+Tree Internals)

## 개요

B+Tree는 관계형 데이터베이스에서 가장 널리 사용되는 인덱스 자료구조다. **디스크 I/O를 최소화**하도록 설계되어, 수백만 개의 레코드에서도 3-4번의 디스크 접근으로 원하는 데이터를 찾을 수 있다. 이 문서에서는 B-Tree와 B+Tree의 차이, 분할/병합 알고리즘, 동시성 제어까지 깊이 있게 다룬다.

## 핵심 개념

### 1. B-Tree vs B+Tree

```
┌─────────────────────────────────────────────────────────────┐
│                    B-Tree                                    │
├─────────────────────────────────────────────────────────────┤
│                   ┌─────────────────┐                       │
│                   │  [30*] [70*]    │  * = 데이터 포인터    │
│                   └─────────────────┘                       │
│           ┌───────────┼───────────┐                         │
│           ▼           ▼           ▼                         │
│    ┌──────────┐ ┌──────────┐ ┌──────────┐                  │
│    │[10*][20*]│ │[50*][60*]│ │[80*][90*]│                  │
│    └──────────┘ └──────────┘ └──────────┘                  │
│                                                             │
│ 특징:                                                        │
│ - 모든 노드에 데이터(레코드 포인터) 저장                     │
│ - 키를 찾으면 바로 데이터 접근 가능                          │
│ - 범위 검색이 비효율적 (트리 순회 필요)                      │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                    B+Tree                                    │
├─────────────────────────────────────────────────────────────┤
│                   ┌─────────────────┐                       │
│                   │    [30] [70]    │  내부 노드: 키만      │
│                   └─────────────────┘                       │
│           ┌───────────┼───────────┐                         │
│           ▼           ▼           ▼                         │
│    ┌──────────┐ ┌──────────┐ ┌──────────┐                  │
│    │[10*][20*]│→│[30*][50*]│→│[70*][80*]│  리프 연결리스트  │
│    └──────────┘ └──────────┘ └──────────┘                  │
│                                                             │
│ 특징:                                                        │
│ - 리프 노드에만 데이터(레코드 포인터) 저장                   │
│ - 내부 노드는 키만 저장 → 더 높은 팬아웃                     │
│ - 리프 노드가 연결 리스트 → 효율적인 범위 검색               │
│ - 모든 검색이 리프까지 도달 (일관된 성능)                    │
└─────────────────────────────────────────────────────────────┘
```

### 2. B+Tree 속성

```
Order(차수) = m인 B+Tree:

내부 노드:
- 최소 ⌈m/2⌉ - 1개, 최대 m - 1개의 키
- 최소 ⌈m/2⌉개, 최대 m개의 자식
- 루트는 최소 2개 자식 (1개 키)

리프 노드:
- 최소 ⌈m/2⌉개, 최대 m개의 키-데이터 쌍
- 다음 리프 노드로의 포인터

예: m = 4 (실제 DB는 수백)
- 내부 노드: 1-3개 키, 2-4개 자식
- 리프 노드: 2-4개 키-데이터 쌍
```

### 3. 팬아웃(Fan-out)과 트리 높이

```
팬아웃: 각 노드가 가질 수 있는 자식 수

예: 8KB 페이지, 8B 키, 8B 포인터
내부 노드 팬아웃 ≈ 8KB / (8B + 8B) ≈ 500

높이 계산:
- 레코드 수 N, 팬아웃 f
- 높이 h = logf(N)

예: 10억 레코드, f = 500
h = log500(1,000,000,000) ≈ 3.3 → 높이 4

즉, 4번의 페이지 접근으로 10억 레코드 중 하나를 찾을 수 있음!
```

### 4. 검색 알고리즘

```python
def search(node, key):
    """B+Tree 검색"""
    if node.is_leaf():
        # 리프 노드: 키 찾기
        for i, k in enumerate(node.keys):
            if k == key:
                return node.values[i]  # 데이터 포인터 반환
        return None  # 키 없음
    else:
        # 내부 노드: 적절한 자식으로 이동
        i = binary_search_position(node.keys, key)
        return search(node.children[i], key)

# I/O 복잡도: O(logf N) - 높이만큼 페이지 읽기
```

### 5. 삽입과 분할 (Split)

```
┌─────────────────────────────────────────────────────────────┐
│                    삽입 알고리즘                              │
├─────────────────────────────────────────────────────────────┤
│ 1. 리프 노드 찾기                                            │
│ 2. 리프에 공간 있으면 삽입                                   │
│ 3. 공간 없으면 분할:                                         │
│    a. 새 리프 노드 생성                                      │
│    b. 키들을 반으로 나눔                                     │
│    c. 부모에 중간 키 복사                                    │
│    d. 부모도 가득 차면 재귀적으로 분할                       │
└─────────────────────────────────────────────────────────────┘
```

```
예: 25 삽입 (리프 분할)

Before:
       [30]
      /    \
[10,20,25?] [30,40,50]  ← 왼쪽 리프가 가득 참

Step 1: 분할
       [30]
      /    \
[10,20] → [25]  [30,40,50]  ← 새 리프 생성

Step 2: 부모에 키 올림
          [25,30]
         /   |   \
    [10,20] [25] [30,40,50]
```

**리프 vs 내부 노드 분할 차이:**

```
리프 노드 분할:
- 중간 키를 복사하여 부모로 올림
- 원래 키는 리프에 남음

내부 노드 분할:
- 중간 키를 이동하여 부모로 올림
- 원래 위치에서 제거됨
```

### 6. 삭제와 병합 (Merge)

```
┌─────────────────────────────────────────────────────────────┐
│                    삭제 알고리즘                              │
├─────────────────────────────────────────────────────────────┤
│ 1. 리프 노드에서 키 삭제                                     │
│ 2. 노드가 최소 키 수 이상이면 완료                           │
│ 3. 언더플로 시:                                              │
│    a. 형제에서 빌려오기 (Redistribution)                     │
│    b. 빌릴 수 없으면 형제와 병합 (Merge)                     │
│    c. 병합 시 부모 키 제거 → 재귀적 처리                     │
└─────────────────────────────────────────────────────────────┘
```

```
예: 30 삭제 (병합)

Before:
          [25,50]
         /   |   \
    [10,20] [30] [50,60,70]  ← 30 삭제하면 언더플로

After (형제에서 빌려오기):
          [25,60]
         /   |   \
    [10,20] [50] [60,70]

또는 After (병합):
          [50]
         /    \
    [10,20,25] [50,60,70]  ← 왼쪽으로 병합
```

### 7. 벌크 로딩 (Bulk Loading)

대량의 정렬된 데이터를 효율적으로 B+Tree에 삽입:

```
┌─────────────────────────────────────────────────────────────┐
│                    Bulk Loading                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 일반 삽입: O(N log N) - 각 삽입마다 트리 순회               │
│ 벌크 로딩: O(N) - 정렬된 순서로 리프 채움                    │
│                                                             │
│ 알고리즘:                                                    │
│ 1. 데이터를 키 순서로 정렬                                   │
│ 2. 리프 노드를 왼쪽부터 순차적으로 채움                      │
│ 3. 리프 노드가 가득 차면 새 리프 생성                        │
│ 4. 상위 레벨은 bottom-up으로 구축                            │
│                                                             │
│ 장점:                                                        │
│ - 분할 연산 최소화                                           │
│ - 순차 I/O로 빠름                                            │
│ - 리프 노드 100% 채움 가능                                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

```sql
-- PostgreSQL: 인덱스 생성 시 벌크 로딩 사용
CREATE INDEX idx_name ON table (column);

-- 대용량 테이블에서 인덱스 재생성
REINDEX TABLE mytable;

-- MySQL: 정렬된 데이터 삽입 시 자동 최적화
ALTER TABLE mytable ORDER BY id;
```

### 8. 동시성 제어 (Latch Crabbing)

```
┌─────────────────────────────────────────────────────────────┐
│              Latch Crabbing (Latch Coupling)                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 읽기:                                                        │
│ 1. 루트에 Read Latch                                        │
│ 2. 자식 노드에 Read Latch                                   │
│ 3. 부모 Latch 해제                                          │
│ 4. 반복                                                      │
│                                                             │
│ 쓰기 (보수적):                                               │
│ 1. 루트에 Write Latch                                       │
│ 2. 자식 노드에 Write Latch                                  │
│ 3. 자식이 "안전"하면 (분할/병합 불필요) 조상 Latch 해제     │
│ 4. 반복                                                      │
│                                                             │
│ "안전" 조건:                                                 │
│ - 삽입 시: 노드가 가득 차지 않음                            │
│ - 삭제 시: 노드가 최소 + 1개 이상의 키                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

```
예: 키 25 삽입 (Latch Crabbing)

       [30]  ← Write Latch
      /    \
    [10,20] [40,50]

→ [10,20]에 Write Latch
→ [10,20]이 안전함 (공간 있음)
→ [30] Latch 해제
→ 25 삽입
```

### 9. Blink-Tree

```
┌─────────────────────────────────────────────────────────────┐
│                    Blink-Tree                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 문제: Latch Crabbing은 루트에서 병목                         │
│                                                             │
│ 해결: 각 레벨에서 오른쪽 형제로의 링크 추가                  │
│                                                             │
│         [30] ────────────→ NULL                             │
│        /    \                                               │
│   [10,20]→[30,40] ────────→ NULL                           │
│                                                             │
│ 장점:                                                        │
│ - 분할 중에도 읽기 가능                                      │
│ - Write latch 유지 시간 단축                                 │
│ - 분할이 순간적으로 불완전해도 오른쪽 링크로 복구            │
│                                                             │
│ PostgreSQL의 B+Tree가 Blink-Tree 변형 사용                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 10. 실제 DBMS의 B+Tree

```sql
-- PostgreSQL: 인덱스 페이지 구조 확인
CREATE EXTENSION pageinspect;

-- 메타 페이지 정보
SELECT * FROM bt_metap('idx_name');
-- magic | version | root | level | fastroot | ...

-- 페이지 내용
SELECT * FROM bt_page_items('idx_name', 1);
-- itemoffset | ctid | itemlen | data

-- MySQL: 인덱스 정보
SHOW INDEX FROM table_name;
SELECT * FROM information_schema.INNODB_SYS_INDEXES;
```

## 실무 적용

### 인덱스 크기 추정

```sql
-- PostgreSQL: 인덱스 크기
SELECT
    indexrelname,
    pg_size_pretty(pg_relation_size(indexrelid)) as size
FROM pg_stat_user_indexes
ORDER BY pg_relation_size(indexrelid) DESC;

-- 예상 크기 계산
-- 레코드 수: 1000만
-- 키 크기: 8B (bigint)
-- 포인터 크기: 6B (TID)
-- 페이지 크기: 8KB
-- 팬아웃: 8KB / (8B + 8B) ≈ 500
-- 리프 노드 수: 10M / 500 = 20,000 페이지
-- 총 크기: ~200MB (내부 노드 포함)
```

### B+Tree 건강 상태 확인

```sql
-- PostgreSQL: 인덱스 bloat 확인
SELECT
    schemaname, tablename, indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size,
    idx_scan, idx_tup_read, idx_tup_fetch
FROM pg_stat_user_indexes;

-- 인덱스 재구축
REINDEX INDEX idx_name;
REINDEX TABLE table_name CONCURRENTLY;  -- PostgreSQL 12+, 온라인
```

## 참고 자료

- "Database System Concepts" (Silberschatz) - Chapter 14: Indexing
- CMU 15-445: Tree Indexes
- "Database Internals" (Petrov) - Chapter 2, 4
- PostgreSQL: B-Tree Implementation (src/backend/access/nbtree)
- Lehman & Yao: "Efficient Locking for Concurrent Operations on B-Trees" (1981)

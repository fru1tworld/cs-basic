# 저장 계층 구조 (Storage Hierarchy)

## 개요

데이터베이스 시스템의 성능은 저장 매체의 특성에 크게 의존한다. CPU와 메모리의 속도 차이(메모리 벽), 메모리와 디스크의 속도 차이(I/O 벽)를 이해하고 각 계층의 특성에 맞게 데이터를 관리하는 것이 DBMS 설계의 핵심이다. 특히 **디스크 I/O가 데이터베이스 성능의 주요 병목**이다.

## 핵심 개념

### 1. 저장 계층 피라미드

```
┌─────────────────────────────────────────────────────────────┐
│                    저장 계층 피라미드                         │
├─────────────────────────────────────────────────────────────┤
│         ┌───────┐                                           │
│         │  CPU  │  레지스터: ~1ns, ~KB                       │
│         │ Cache │  L1: ~1ns, ~32KB / L2: ~4ns, ~256KB       │
│         └───────┘  L3: ~10ns, ~30MB                         │
│        ┌─────────┐                                          │
│        │  DRAM   │  ~100ns, ~수백GB                         │
│        └─────────┘                                          │
│       ┌───────────┐                                         │
│       │   SSD     │  ~10-100µs, ~수TB                       │
│       └───────────┘                                         │
│      ┌─────────────┐                                        │
│      │    HDD      │  ~10ms, ~수십TB                        │
│      └─────────────┘                                        │
│     ┌───────────────┐                                       │
│     │    Network    │  ~100ms (cloud), 무제한               │
│     └───────────────┘                                       │
│                                                             │
│   ← 속도 증가          비용 증가 →                           │
│   → 용량 증가          휘발성 증가 ←                         │
└─────────────────────────────────────────────────────────────┘
```

### 2. HDD vs SSD 특성 비교

```
┌─────────────────────────────────────────────────────────────┐
│                    HDD (Hard Disk Drive)                     │
├─────────────────────────────────────────────────────────────┤
│ 구조: 회전하는 플래터 + 이동하는 헤드                         │
│                                                             │
│ 읽기/쓰기 시간 = Seek Time + Rotational Delay + Transfer Time│
│   - Seek Time: 헤드 이동 (~5-10ms)                          │
│   - Rotational Delay: 플래터 회전 대기 (~4ms @7200rpm)       │
│   - Transfer Time: 데이터 전송 (~0.1ms/64KB)                │
│                                                             │
│ Sequential Read: ~200 MB/s                                   │
│ Random Read: ~100 IOPS (각 10ms)                            │
│                                                             │
│ 핵심: Random I/O가 매우 느림 → Sequential I/O 선호           │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                    SSD (Solid State Drive)                   │
├─────────────────────────────────────────────────────────────┤
│ 구조: NAND Flash 메모리 + 컨트롤러                           │
│                                                             │
│ 읽기: ~10-100µs                                             │
│ 쓰기: ~100µs-1ms                                            │
│ Sequential Read: ~500MB/s - 7GB/s (NVMe)                    │
│ Random Read: ~100K - 1M IOPS                                │
│                                                             │
│ 특성:                                                        │
│ - Random I/O 성능이 HDD 대비 100-1000배                     │
│ - Write Amplification: 쓰기 시 블록 단위 삭제 필요           │
│ - Wear Leveling: 쓰기 수명 관리                              │
│ - 읽기가 쓰기보다 빠름                                       │
└─────────────────────────────────────────────────────────────┘
```

**I/O 비용 비교:**

```
Random 4KB Read 1000회:
- HDD: 1000 × 10ms = 10초
- SSD: 1000 × 100µs = 0.1초

Sequential 4MB Read:
- HDD: ~20ms (seek + 4MB/200MB/s)
- SSD: ~1ms (4MB/4GB/s)
```

### 3. NVMe와 PMEM

```
┌─────────────────────────────────────────────────────────────┐
│ NVMe (Non-Volatile Memory Express)                          │
├─────────────────────────────────────────────────────────────┤
│ - PCIe 직접 연결 (SATA 대비 저지연)                         │
│ - 여러 큐 지원 (64K 큐 × 64K 명령)                          │
│ - Random Read: ~500K-1M IOPS                                │
│ - Latency: ~10-20µs                                         │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ PMEM (Persistent Memory) / Intel Optane                     │
├─────────────────────────────────────────────────────────────┤
│ - 바이트 단위 접근 (블록 단위 아님)                          │
│ - DRAM 버스에 직접 연결                                      │
│ - Latency: ~300ns (DRAM의 ~3배, SSD의 ~100배 빠름)          │
│ - 비휘발성이면서 메모리처럼 사용                             │
│                                                             │
│ DBMS 영향:                                                   │
│ - 버퍼 풀 설계 재고 필요                                     │
│ - WAL 최적화 가능                                            │
│ - 복구 시간 단축                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4. 디스크 I/O 최적화 원칙

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Sequential I/O 선호                                       │
│    - 테이블 스캔: 순차 읽기                                   │
│    - 로그 쓰기: 추가 전용 (append-only)                      │
│    - B+Tree: 리프 노드 연결 리스트로 범위 스캔 최적화         │
├─────────────────────────────────────────────────────────────┤
│ 2. 블록 단위 I/O                                             │
│    - 디스크는 블록(보통 4KB) 단위로 읽기/쓰기                │
│    - DB 페이지도 보통 4KB-16KB                               │
│    - 페이지 내 여러 튜플을 함께 처리                         │
├─────────────────────────────────────────────────────────────┤
│ 3. I/O 횟수 최소화                                           │
│    - 인덱스로 필요한 페이지만 접근                           │
│    - Covering Index로 테이블 접근 회피                       │
│    - 적절한 프리페칭(prefetching)                            │
├─────────────────────────────────────────────────────────────┤
│ 4. 버퍼 풀 활용                                              │
│    - 자주 접근하는 페이지를 메모리에 캐싱                    │
│    - LRU 등의 교체 정책                                      │
│    - Dirty 페이지 관리                                       │
└─────────────────────────────────────────────────────────────┘
```

### 5. 버퍼 풀 관리 (Buffer Pool Management)

```
┌─────────────────────────────────────────────────────────────┐
│                     Buffer Pool                              │
├─────────────────────────────────────────────────────────────┤
│  ┌────────┬────────┬────────┬────────┬────────┐            │
│  │Page 1  │Page 5  │Page 3  │Page 8  │Page 2  │            │
│  │(clean) │(dirty) │(clean) │(dirty) │(clean) │            │
│  └────────┴────────┴────────┴────────┴────────┘            │
│                                                             │
│  Page Table: page_id → frame_id 매핑                        │
│  ┌──────────────────────────────────────────┐               │
│  │ page_id │ frame_id │ dirty │ pin_count │               │
│  │    1    │    0     │   F   │     0     │               │
│  │    5    │    1     │   T   │     2     │               │
│  │   ...   │   ...    │  ...  │    ...    │               │
│  └──────────────────────────────────────────┘               │
└─────────────────────────────────────────────────────────────┘
```

**주요 개념:**
- **Frame**: 버퍼 풀의 페이지 슬롯
- **Pin Count**: 현재 페이지를 사용 중인 쿼리 수 (0이어야 교체 가능)
- **Dirty Flag**: 디스크와 내용이 다른지 여부

### 6. 페이지 교체 정책

```
┌─────────────────────────────────────────────────────────────┐
│ LRU (Least Recently Used)                                    │
├─────────────────────────────────────────────────────────────┤
│ - 가장 오래 사용되지 않은 페이지 교체                        │
│ - 구현: 접근 시마다 리스트 앞으로 이동                       │
│ - 문제: Sequential Flooding                                  │
│   전체 테이블 스캔 시 최근 사용 페이지가 모두 밀려남          │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ Clock (Second Chance)                                        │
├─────────────────────────────────────────────────────────────┤
│ - LRU 근사, 낮은 오버헤드                                    │
│ - Reference bit: 접근 시 1로 설정                            │
│ - 교체 시: bit=1이면 0으로, bit=0이면 교체                   │
│ - PostgreSQL 사용                                            │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ LRU-K                                                        │
├─────────────────────────────────────────────────────────────┤
│ - 최근 K번의 접근 기록 유지                                  │
│ - K번째 최근 접근이 가장 오래된 페이지 교체                  │
│ - Sequential flooding 방지                                   │
│ - 오버헤드가 큼                                              │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ 2Q (Two Queues)                                              │
├─────────────────────────────────────────────────────────────┤
│ - FIFO 큐(A1) + LRU 큐(Am)                                  │
│ - 처음 접근: A1에 삽입                                       │
│ - 재접근: A1에서 Am으로 이동                                 │
│ - Sequential scan은 A1에서 교체됨                            │
└─────────────────────────────────────────────────────────────┘
```

### 7. Prefetching (미리 읽기)

```
┌─────────────────────────────────────────────────────────────┐
│ Sequential Prefetching                                       │
├─────────────────────────────────────────────────────────────┤
│ Page 1 요청 → Page 1, 2, 3, 4 함께 읽기                     │
│ - 테이블 스캔에 효과적                                       │
│ - OS 레벨 + DB 레벨에서 모두 수행                           │
│ - PostgreSQL: effective_io_concurrency                       │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ Index Prefetching                                            │
├─────────────────────────────────────────────────────────────┤
│ 인덱스 스캔 중 다음에 필요한 페이지 예측하여 미리 읽기       │
│ - B+Tree 리프 노드 순차 접근 시                              │
│ - Bitmap Index Scan                                          │
└─────────────────────────────────────────────────────────────┘
```

### 8. 버퍼 풀 설정

```sql
-- PostgreSQL
shared_buffers = '4GB'  -- 버퍼 풀 크기 (총 RAM의 25-40%)
effective_cache_size = '12GB'  -- OS 캐시 포함 예상 캐시 (75%)

-- MySQL InnoDB
innodb_buffer_pool_size = 12G  -- 버퍼 풀 크기 (전용 서버: RAM의 80%)
innodb_buffer_pool_instances = 8  -- 멀티 버퍼 풀 (동시성 향상)
```

## 실무 적용

### 워크로드별 저장소 선택

```
┌─────────────────────────────────────────────────────────────┐
│ OLTP (Online Transaction Processing)                         │
├─────────────────────────────────────────────────────────────┤
│ 특성: 랜덤 I/O, 작은 쿼리, 높은 동시성                       │
│ 권장: NVMe SSD, 충분한 버퍼 풀                               │
│ 이유: 랜덤 I/O 성능이 중요                                   │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ OLAP (Online Analytical Processing)                          │
├─────────────────────────────────────────────────────────────┤
│ 특성: 순차 스캔, 큰 쿼리, 낮은 동시성                        │
│ 권장: 대용량 SSD 또는 HDD (비용 고려)                        │
│ 이유: Sequential I/O 위주, 용량이 중요                       │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ WAL/Redo Log                                                 │
├─────────────────────────────────────────────────────────────┤
│ 특성: 순차 쓰기, 지속성 중요                                 │
│ 권장: 고성능 NVMe SSD, 별도 디스크                           │
│ 이유: 커밋 지연 시간에 직접 영향                             │
└─────────────────────────────────────────────────────────────┘
```

### 버퍼 풀 모니터링

```sql
-- PostgreSQL: 버퍼 캐시 히트율
SELECT
    sum(heap_blks_hit) / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0) * 100
    AS cache_hit_ratio
FROM pg_statio_user_tables;

-- 목표: 99% 이상

-- MySQL InnoDB: 버퍼 풀 상태
SHOW ENGINE INNODB STATUS;
-- Buffer pool hit rate: 999 / 1000

SELECT
    (1 - (Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests)) * 100
    AS hit_ratio
FROM information_schema.global_status
WHERE variable_name IN ('Innodb_buffer_pool_reads', 'Innodb_buffer_pool_read_requests');
```

## 참고 자료

- "Architecture of a Database System" (Hellerstein) - Section 5
- "Database System Concepts" (Silberschatz) - Chapter 12, 13
- CMU 15-445: Storage & Buffer Management
- PostgreSQL Documentation: Resource Consumption
- MySQL Documentation: InnoDB Buffer Pool

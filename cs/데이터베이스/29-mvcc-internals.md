# MVCC 내부 구조 (MVCC Internals)

## 개요

MVCC(Multi-Version Concurrency Control)는 **읽기가 쓰기를 블로킹하지 않고, 쓰기가 읽기를 블로킹하지 않는** 동시성 제어 기법이다. 각 트랜잭션에게 특정 시점의 데이터 스냅샷을 제공하여 높은 동시성을 달성한다. PostgreSQL과 MySQL InnoDB 모두 MVCC를 사용하지만 구현 방식이 다르다.

## 핵심 개념

### 1. MVCC 기본 원리

```
┌─────────────────────────────────────────────────────────────┐
│                    MVCC 개념                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 핵심 아이디어:                                               │
│ - 데이터의 여러 버전(version)을 유지                        │
│ - 각 트랜잭션은 시작 시점의 스냅샷을 봄                     │
│ - 읽기는 잠금 없이 진행                                      │
│ - 쓰기는 새 버전 생성                                        │
│                                                             │
│ 기존 버전:                                                   │
│ ┌─────────────────────────────────────────────┐             │
│ │ Row: id=1, name="Kim", version=T10         │             │
│ └─────────────────────────────────────────────┘             │
│                                                             │
│ T20이 수정 후:                                               │
│ ┌─────────────────────────────────────────────┐             │
│ │ Row v1: id=1, name="Kim", version=T10      │ (이전 버전) │
│ │ Row v2: id=1, name="Lee", version=T20      │ (새 버전)   │
│ └─────────────────────────────────────────────┘             │
│                                                             │
│ T15(T10 이후, T20 이전 시작)는 v1을 봄                      │
│ T25(T20 이후 시작)는 v2를 봄                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2. PostgreSQL MVCC 구현

```
┌─────────────────────────────────────────────────────────────┐
│              PostgreSQL 튜플 헤더                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ HeapTupleHeaderData:                                        │
│ ┌────────────────────────────────────────────────────────┐ │
│ │ t_xmin (4B)    : 이 튜플을 생성한 트랜잭션 ID          │ │
│ │ t_xmax (4B)    : 이 튜플을 삭제/수정한 트랜잭션 ID     │ │
│ │ t_cid (4B)     : 트랜잭션 내 명령 ID                   │ │
│ │ t_ctid (6B)    : 현재 또는 새 버전의 위치              │ │
│ │ t_infomask (2B): 상태 플래그                           │ │
│ │ t_infomask2(2B): 추가 플래그, 컬럼 수                  │ │
│ │ t_hoff (1B)    : 데이터 시작 오프셋                    │ │
│ │ [NULL bitmap]  : NULL 컬럼 비트맵                      │ │
│ │ [User Data]    : 실제 컬럼 데이터                      │ │
│ └────────────────────────────────────────────────────────┘ │
│                                                             │
│ 가시성 규칙:                                                 │
│ 튜플이 보이려면:                                             │
│ 1. xmin이 커밋됨 AND 현재 스냅샷 이전                       │
│ 2. xmax가 없거나 (0), 커밋 안 됨, 또는 스냅샷 이후          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**PostgreSQL 버전 체인:**

```
┌─────────────────────────────────────────────────────────────┐
│              PostgreSQL 버전 관리                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ UPDATE는 새 튜플을 생성하고 이전 튜플에 xmax 설정          │
│                                                             │
│ 초기 상태:                                                   │
│ ┌────────────────────────────────────────────────────────┐ │
│ │ Page 5, Offset 10:                                     │ │
│ │ xmin=100, xmax=0, data="Kim"                          │ │
│ └────────────────────────────────────────────────────────┘ │
│                                                             │
│ T200이 UPDATE 실행:                                         │
│ ┌────────────────────────────────────────────────────────┐ │
│ │ Page 5, Offset 10: (이전 버전)                        │ │
│ │ xmin=100, xmax=200, ctid→(5,15), data="Kim"          │ │
│ └────────────────────────────────────────────────────────┘ │
│ ┌────────────────────────────────────────────────────────┐ │
│ │ Page 5, Offset 15: (새 버전)                          │ │
│ │ xmin=200, xmax=0, data="Lee"                          │ │
│ └────────────────────────────────────────────────────────┘ │
│                                                             │
│ ctid는 새 버전 위치를 가리킴 (UPDATE 체인)                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3. MySQL InnoDB MVCC 구현

```
┌─────────────────────────────────────────────────────────────┐
│              InnoDB MVCC 구조                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 행 구조:                                                     │
│ ┌────────────────────────────────────────────────────────┐ │
│ │ DB_TRX_ID (6B)  : 마지막 수정 트랜잭션 ID              │ │
│ │ DB_ROLL_PTR(7B) : Undo 로그 포인터                     │ │
│ │ DB_ROW_ID (6B)  : 숨겨진 Row ID (PK 없을 때)          │ │
│ │ [User Data]     : 실제 컬럼 데이터                     │ │
│ └────────────────────────────────────────────────────────┘ │
│                                                             │
│ Undo Log (Rollback Segment):                                │
│ ┌────────────────────────────────────────────────────────┐ │
│ │ 이전 버전 데이터                                       │ │
│ │ 이전 DB_TRX_ID                                        │ │
│ │ 이전 버전 Undo Log 포인터                              │ │
│ └────────────────────────────────────────────────────────┘ │
│                                                             │
│ 버전 체인 (Undo Log에 저장):                                │
│                                                             │
│ 현재 행 ──→ Undo1 ──→ Undo2 ──→ Undo3 (오래된 버전)        │
│ (T300)     (T200)    (T100)    (T50)                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4. 가시성 체크 (Visibility Check)

**PostgreSQL:**

```
┌─────────────────────────────────────────────────────────────┐
│              PostgreSQL 가시성 판단                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 스냅샷 구조:                                                 │
│ ┌────────────────────────────────────────────────────────┐ │
│ │ xmin: 가장 작은 활성 트랜잭션 ID                       │ │
│ │ xmax: 다음 할당될 트랜잭션 ID                          │ │
│ │ xip[]: 현재 진행 중인 트랜잭션 ID 목록                 │ │
│ └────────────────────────────────────────────────────────┘ │
│                                                             │
│ 가시성 규칙 (의사 코드):                                    │
│                                                             │
│ is_visible(tuple, snapshot):                                │
│   # xmin 체크                                               │
│   if tuple.xmin >= snapshot.xmax:                          │
│       return FALSE  # 아직 시작 안 한 트랜잭션              │
│   if tuple.xmin in snapshot.xip:                           │
│       return FALSE  # 진행 중인 트랜잭션                    │
│   if not is_committed(tuple.xmin):                         │
│       return FALSE  # 커밋 안 됨                            │
│                                                             │
│   # xmax 체크                                               │
│   if tuple.xmax == 0:                                      │
│       return TRUE   # 삭제 안 됨                            │
│   if tuple.xmax >= snapshot.xmax:                          │
│       return TRUE   # 삭제자가 나중                         │
│   if tuple.xmax in snapshot.xip:                           │
│       return TRUE   # 삭제자가 진행 중                      │
│   if not is_committed(tuple.xmax):                         │
│       return TRUE   # 삭제자가 커밋 안 함                   │
│   return FALSE      # 삭제됨                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**MySQL InnoDB:**

```
┌─────────────────────────────────────────────────────────────┐
│              InnoDB 가시성 판단 (Read View)                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ Read View 구조:                                              │
│ ┌────────────────────────────────────────────────────────┐ │
│ │ m_low_limit_id: 다음 할당될 트랜잭션 ID               │ │
│ │ m_up_limit_id: 가장 작은 활성 트랜잭션 ID             │ │
│ │ m_ids[]: 활성 트랜잭션 ID 목록                        │ │
│ │ m_creator_trx_id: Read View 생성자 트랜잭션           │ │
│ └────────────────────────────────────────────────────────┘ │
│                                                             │
│ 가시성 규칙:                                                 │
│                                                             │
│ if trx_id < m_up_limit_id:                                 │
│     return TRUE   # 모든 활성 트랜잭션보다 이전             │
│                                                             │
│ if trx_id >= m_low_limit_id:                               │
│     return FALSE  # Read View 생성 후 시작                 │
│                                                             │
│ if trx_id in m_ids:                                        │
│     return FALSE  # 생성 시점에 활성이었던 트랜잭션        │
│                                                             │
│ return TRUE       # 그 외 (이미 커밋됨)                     │
│                                                             │
│ 안 보이면 → Undo Log에서 이전 버전 찾아서 재확인           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5. PostgreSQL vs MySQL MVCC 비교

```
┌─────────────────────────────────────────────────────────────┐
│              MVCC 구현 비교                                   │
├───────────────────┬─────────────────────────────────────────┤
│                   │  PostgreSQL       │  MySQL InnoDB       │
├───────────────────┼─────────────────────────────────────────┤
│ 버전 저장 위치    │ 같은 테이블       │ Undo Log (별도)     │
│                   │ (힙에 새 튜플)    │ (롤백 세그먼트)     │
├───────────────────┼─────────────────────────────────────────┤
│ UPDATE 동작       │ 새 튜플 삽입 +    │ In-place 수정 +     │
│                   │ 이전 튜플에 xmax  │ Undo에 이전값       │
├───────────────────┼─────────────────────────────────────────┤
│ 인덱스 영향       │ 모든 인덱스 갱신  │ PK만 갱신 (보조     │
│                   │ (HOT 예외)        │ 인덱스는 그대로)    │
├───────────────────┼─────────────────────────────────────────┤
│ 정리 메커니즘     │ VACUUM            │ Purge Thread        │
├───────────────────┼─────────────────────────────────────────┤
│ 공간 재사용       │ VACUUM 후 가능    │ 즉시 가능           │
│                   │                   │ (Undo만 정리)       │
├───────────────────┼─────────────────────────────────────────┤
│ 장점              │ 구현 단순,        │ 공간 효율,          │
│                   │ 복구 빠름         │ 인덱스 효율         │
├───────────────────┼─────────────────────────────────────────┤
│ 단점              │ 테이블 bloat,     │ Undo Log 유지,      │
│                   │ VACUUM 필요       │ 긴 트랜잭션 문제    │
└───────────────────┴─────────────────────────────────────────┘
```

### 6. 트랜잭션 ID와 랩어라운드

```
┌─────────────────────────────────────────────────────────────┐
│              PostgreSQL 트랜잭션 ID 관리                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 트랜잭션 ID: 32비트 부호 없는 정수 (약 42억)               │
│                                                             │
│ 랩어라운드 문제:                                             │
│ - ID가 2^32에 도달하면 0으로 순환                           │
│ - "과거"와 "미래" 판단이 뒤집힐 수 있음                     │
│                                                             │
│ 해결: Freezing                                               │
│ - 오래된 튜플의 xmin을 FrozenTransactionId로 변경           │
│ - FrozenXID는 모든 트랜잭션에게 "과거"로 인식              │
│                                                             │
│ VACUUM 역할:                                                 │
│ - Dead 튜플 정리                                             │
│ - 오래된 xmin을 Freeze                                      │
│ - pg_database.datfrozenxid 갱신                             │
│                                                             │
│ 경고: 20억 트랜잭션 안에 VACUUM 필요                        │
│       autovacuum_freeze_max_age 설정                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 7. Read View 생성 시점

```
┌─────────────────────────────────────────────────────────────┐
│              Read View 생성 시점 차이                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ READ COMMITTED:                                              │
│ - 각 SQL 문마다 새 스냅샷/Read View 생성                    │
│ - 같은 트랜잭션 내 다른 문장이 다른 데이터를 볼 수 있음    │
│                                                             │
│ REPEATABLE READ:                                             │
│ - 트랜잭션 시작 시(또는 첫 쿼리 시) 스냅샷 생성             │
│ - 트랜잭션 동안 같은 스냅샷 사용                            │
│                                                             │
│ SERIALIZABLE (PostgreSQL SSI):                              │
│ - REPEATABLE READ + 직렬화 충돌 탐지                        │
│ - 읽기/쓰기 의존성 추적                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 실무 적용

### MVCC 관련 모니터링

```sql
-- PostgreSQL: 트랜잭션 ID 상태
SELECT datname, age(datfrozenxid) as xid_age
FROM pg_database;

-- 오래된 트랜잭션 확인
SELECT pid, xact_start, now() - xact_start as duration, state, query
FROM pg_stat_activity
WHERE xact_start IS NOT NULL
ORDER BY xact_start;

-- MySQL: Undo Log 크기
SHOW ENGINE INNODB STATUS;
-- History list length: N (높으면 Purge 지연)
```

### 장기 트랜잭션 문제

```sql
-- 문제: 장기 트랜잭션이 이전 버전 정리를 막음

-- PostgreSQL: VACUUM이 오래된 버전을 정리 못함
--            → 테이블 bloat 증가

-- MySQL: Undo Log가 커짐
--        → History list length 증가
--        → 읽기 성능 저하 (긴 버전 체인)

-- 해결: 장기 트랜잭션 탐지 및 종료
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE state = 'idle in transaction'
  AND now() - xact_start > interval '1 hour';
```

## 참고 자료

- PostgreSQL Documentation: MVCC
- MySQL Documentation: InnoDB Multi-Versioning
- "Database Internals" (Petrov) - Chapter 5
- CMU 15-445: Multi-Version Concurrency Control

# 해시 테이블 (Hash Table)

## 개요

해시 테이블은 **키(Key)**를 **해시 함수**로 변환하여 데이터를 저장/검색하는 자료구조입니다.

**핵심 특징**:
- 평균 O(1) 검색, 삽입, 삭제
- 키-값(Key-Value) 쌍으로 저장
- 해시 충돌 처리 필요

## 핵심 개념

### 1. 해시 테이블 구조

```
Key → [Hash Function] → Index → Bucket(저장소)

예시:
"apple" → hash("apple") → 3 → bucket[3]에 저장

┌─────┬─────────────────┐
│  0  │                 │
├─────┼─────────────────┤
│  1  │ "banana" → 50   │
├─────┼─────────────────┤
│  2  │                 │
├─────┼─────────────────┤
│  3  │ "apple" → 100   │
├─────┼─────────────────┤
│  4  │ "cherry" → 30   │
└─────┴─────────────────┘
```

### 2. 해시 함수 (Hash Function)

임의 크기의 데이터를 고정 크기의 값으로 매핑합니다.

#### 좋은 해시 함수 조건
1. **결정적**: 같은 입력 → 항상 같은 출력
2. **균등 분포**: 출력이 골고루 분포
3. **빠른 계산**: O(1) 시간
4. **최소 충돌**: 다른 입력 → 다른 출력 (이상적)

#### 해시 함수 예시

**나눗셈법 (Division Method)**:
```
h(k) = k mod m  (m은 테이블 크기, 주로 소수)

예: m = 13
h(15) = 15 mod 13 = 2
h(28) = 28 mod 13 = 2  ← 충돌!
```

**곱셈법 (Multiplication Method)**:
```
h(k) = floor(m × (k × A mod 1))
A는 0 < A < 1인 상수 (황금비 권장: 0.6180339...)
```

**문자열 해시**:
```java
// Java String.hashCode()
int hash = 0;
for (char c : str) {
    hash = 31 * hash + c;
}
```

### 3. 해시 충돌 (Collision)

서로 다른 키가 같은 인덱스에 매핑되는 현상입니다.

```
hash("apple") = 3
hash("grape") = 3  ← 충돌!
```

**비둘기집 원리**: 키의 가짓수 > 버킷 수 → 충돌 불가피

### 4. 충돌 해결 방법

#### 4.1 체이닝 (Chaining)

같은 인덱스에 **연결 리스트**로 저장합니다.

```
┌─────┬─────────────────────────────────┐
│  0  │ → NULL                          │
├─────┼─────────────────────────────────┤
│  1  │ → ["banana":50] → NULL          │
├─────┼─────────────────────────────────┤
│  2  │ → NULL                          │
├─────┼─────────────────────────────────┤
│  3  │ → ["apple":100] → ["grape":70]  │  ← 충돌 처리
├─────┼─────────────────────────────────┤
│  4  │ → ["cherry":30] → NULL          │
└─────┴─────────────────────────────────┘
```

**장점**:
- 구현 간단
- 삭제 쉬움
- 적재율 > 1 가능

**단점**:
- 추가 메모리 (포인터)
- 캐시 효율 낮음 (메모리 불연속)

**시간 복잡도**:
- 평균: O(1 + α) (α = 적재율 = n/m)
- 최악: O(n) (모든 키가 같은 버킷)

#### 4.2 개방 주소법 (Open Addressing)

충돌 시 **다른 빈 버킷**을 찾아 저장합니다.

**선형 탐사 (Linear Probing)**:
```
h(k, i) = (h(k) + i) mod m

충돌 시 다음 칸으로 이동:
h(k), h(k)+1, h(k)+2, ...

예: hash("apple") = 3, hash("grape") = 3
┌───┬───┬───┬─────────┬─────────┬───┐
│ 0 │ 1 │ 2 │ apple   │ grape   │ 5 │
└───┴───┴───┴─────────┴─────────┴───┘
              index=3   index=4
```

**문제**: 클러스터링 (연속된 데이터 뭉침)

**이차 탐사 (Quadratic Probing)**:
```
h(k, i) = (h(k) + i²) mod m

충돌 시: h(k), h(k)+1, h(k)+4, h(k)+9, ...
```

**이중 해싱 (Double Hashing)**:
```
h(k, i) = (h1(k) + i × h2(k)) mod m

두 번째 해시 함수로 탐사 간격 결정
→ 클러스터링 감소
```

**삭제 문제**:
```
삽입: A(3) → B(3→4)
검색: B → hash(B)=3 → 3에 A → 4 확인 → B 찾음

삭제: A 삭제 → 3 비움
검색: B → hash(B)=3 → 3 비어있음 → "B 없음"?

해결: 삭제 표시(DELETED) 사용
```

### 5. 적재율 (Load Factor)

```
α = n / m
n: 저장된 요소 수
m: 버킷 수
```

**적재율이 높으면**:
- 충돌 증가
- 성능 저하
- 일반적으로 0.7~0.75 유지

**리해싱 (Rehashing)**:
적재율이 임계값을 넘으면 테이블 크기를 늘리고 모든 요소를 재배치합니다.

```
α > 0.75 → 테이블 크기 2배 → 모든 요소 재해싱

Before (m=4):         After (m=8):
┌───┬───┬───┬───┐    ┌───┬───┬───┬───┬───┬───┬───┬───┐
│ A │ B │ C │   │ →  │   │ A │   │ B │   │   │ C │   │
└───┴───┴───┴───┘    └───┴───┴───┴───┴───┴───┴───┴───┘
```

### 6. 시간 복잡도

| 연산 | 평균 | 최악 |
|------|------|------|
| 검색 | O(1) | O(n) |
| 삽입 | O(1) | O(n) |
| 삭제 | O(1) | O(n) |

**최악의 경우**: 모든 키가 같은 버킷으로 해싱 (해시 함수 품질 낮음)

### 7. 해시 테이블 vs 다른 자료구조

| | 해시 테이블 | 이진 탐색 트리 | 배열 |
|---|---|---|---|
| 검색 | O(1) | O(log n) | O(n) |
| 삽입 | O(1) | O(log n) | O(n) |
| 삭제 | O(1) | O(log n) | O(n) |
| 순서 유지 | X | O | 인덱스 순 |
| 범위 검색 | X | O | O |
| 메모리 | 추가 필요 | 추가 필요 | 연속 |

### 8. 프로그래밍 언어별 구현

```java
// Java
HashMap<String, Integer> map = new HashMap<>();
map.put("apple", 100);
int value = map.get("apple");

// Python
dict = {}
dict["apple"] = 100
value = dict["apple"]

// JavaScript
const map = new Map();
map.set("apple", 100);
const value = map.get("apple");
```

### 9. 해시 테이블 활용 사례

1. **데이터베이스 인덱싱**: 해시 인덱스
2. **캐시 구현**: 키로 빠른 조회
3. **중복 검사**: 집합(Set) 구현
4. **문자열 매칭**: Rabin-Karp 알고리즘
5. **라우팅 테이블**: IP 주소 → 경로

## 실무 적용

### Java HashMap 내부 구조

```
Java 8 이후:
- 기본: 체이닝 (연결 리스트)
- 버킷당 8개 초과 시: 레드-블랙 트리로 전환
- 버킷당 6개 이하 시: 다시 연결 리스트로

이유: 최악의 경우 O(n) → O(log n)
```

### 해시 충돌 공격 방지

```java
// 예측 불가능한 해시 함수 사용
// SipHash 등 암호학적 해시 함수 도입

// 또는 시드 값 랜덤화
int hash = seed ^ key.hashCode();
```

## 참고 자료

- [Java HashMap 구현](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html)
- Introduction to Algorithms (CLRS) - Chapter 11: Hash Tables

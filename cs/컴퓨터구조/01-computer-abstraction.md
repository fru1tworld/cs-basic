# 컴퓨터 추상화 (Computer Abstraction)

## 개요

컴퓨터 시스템은 복잡한 하드웨어와 소프트웨어의 집합체다. 이 복잡성을 관리하기 위해 **추상화(Abstraction)** 개념을 사용한다. 추상화는 하위 계층의 복잡한 세부사항을 숨기고, 상위 계층에서 더 단순한 인터페이스를 제공하는 기법이다.

## 핵심 개념

### 추상화 계층 (Abstraction Layers)

컴퓨터 시스템은 여러 추상화 계층으로 구성된다:

```
┌─────────────────────────────────────┐
│         Application (응용 프로그램)    │  ← 사용자가 보는 계층
├─────────────────────────────────────┤
│         Algorithm (알고리즘)          │  ← 문제 해결 방법
├─────────────────────────────────────┤
│     Programming Language (언어)      │  ← 고급 언어
├─────────────────────────────────────┤
│    Operating System (운영체제)        │  ← 자원 관리
├─────────────────────────────────────┤
│    Instruction Set Architecture     │  ← SW/HW 인터페이스
│              (ISA)                  │
├─────────────────────────────────────┤
│    Microarchitecture (마이크로아키텍처) │  ← ISA 구현
├─────────────────────────────────────┤
│         Logic (논리 회로)             │  ← 게이트, 레지스터
├─────────────────────────────────────┤
│         Circuit (회로)               │  ← 트랜지스터 레벨
├─────────────────────────────────────┤
│         Device (소자)                │  ← 물리적 반도체
└─────────────────────────────────────┘
```

### 각 계층의 역할

#### 1. Application (응용 프로그램)
- 사용자가 직접 상호작용하는 계층
- Word, Chrome, 게임 등
- 하위 계층의 존재를 알 필요 없음

#### 2. Algorithm (알고리즘)
- 문제를 해결하는 절차적 방법
- 시간 복잡도, 공간 복잡도 분석
- 언어 독립적인 추상적 해결책

#### 3. Programming Language (프로그래밍 언어)
- 고급 언어: Python, Java, C++
- 컴파일러/인터프리터가 기계어로 변환
- 하드웨어 세부사항 추상화

#### 4. Operating System (운영체제)
- 하드웨어 자원 관리 (CPU, 메모리, I/O)
- 프로세스, 파일 시스템, 네트워크 추상화
- System Call을 통한 서비스 제공

#### 5. Instruction Set Architecture (ISA)
- **가장 중요한 추상화 계층**
- 소프트웨어와 하드웨어 사이의 인터페이스
- 프로그래머가 볼 수 있는 하드웨어의 모습

#### 6. Microarchitecture (마이크로아키텍처)
- ISA를 실제로 구현하는 방법
- 같은 ISA도 다르게 구현 가능 (Intel Core vs AMD Ryzen)
- 파이프라인, 캐시, 분기 예측 등

#### 7. Logic (논리 회로)
- AND, OR, NOT 등 논리 게이트
- 레지스터, 멀티플렉서, ALU
- RTL(Register Transfer Level) 설계

#### 8. Circuit (회로)
- 트랜지스터 수준의 설계
- 전압, 전류, 타이밍 분석
- 아날로그 특성 고려

#### 9. Device (소자)
- 물리적 반도체 소자
- MOSFET, CMOS 기술
- 반도체 물리학 영역

### ISA: 가장 핵심적인 추상화

ISA(Instruction Set Architecture)는 소프트웨어와 하드웨어를 분리하는 가장 중요한 추상화다:

```
┌─────────────────────────────────────┐
│            Software                 │
│   (OS, Compiler, Application)       │
├─────────────────────────────────────┤
│              ISA                    │  ← 계약(Contract)
├─────────────────────────────────────┤
│            Hardware                 │
│   (Microarchitecture, Logic, ...)   │
└─────────────────────────────────────┘
```

#### ISA가 정의하는 것:
1. **명령어 집합**: 사용 가능한 연산들
2. **레지스터**: 개수, 크기, 용도
3. **메모리 모델**: 주소 지정 방식, 정렬 규칙
4. **데이터 타입**: 정수, 부동소수점 크기
5. **예외/인터럽트**: 처리 방식

#### ISA의 장점:
- **호환성**: 같은 ISA면 모든 구현체에서 실행 가능
- **유연성**: 하드웨어 구현을 자유롭게 변경 가능
- **지속성**: 수십 년간 호환성 유지 (x86은 1978년부터)

### 추상화의 장단점

#### 장점:
```
생산성 향상    : 하위 계층 몰라도 개발 가능
재사용성      : 추상화된 인터페이스 기반 개발
복잡성 관리   : 계층별로 분리하여 관리
유지보수성    : 한 계층 변경이 다른 계층에 최소 영향
```

#### 단점:
```
성능 오버헤드  : 추상화 계층 통과에 비용 발생
누수 추상화   : 하위 계층 특성이 노출되는 경우
최적화 한계   : 하위 계층 직접 제어 불가
디버깅 어려움  : 문제 발생 시 여러 계층 추적 필요
```

### 누수 추상화 (Leaky Abstraction)

완벽한 추상화는 존재하지 않는다. 하위 계층의 특성이 상위 계층으로 "누수"되는 경우가 있다:

```java
// 예시: 메모리 접근 패턴이 성능에 영향
// 추상화 관점에서는 동일해야 하지만, 캐시 때문에 성능 차이 발생

// 행 우선 순회 - 캐시 친화적 (빠름)
for (int i = 0; i < N; i++)
    for (int j = 0; j < N; j++)
        arr[i][j] = 0;

// 열 우선 순회 - 캐시 비친화적 (느림)
for (int j = 0; j < N; j++)
    for (int i = 0; i < N; i++)
        arr[i][j] = 0;
```

이는 메모리 추상화(선형 주소 공간)가 캐시 계층을 완전히 숨기지 못하기 때문이다.

## 실무 적용

### 백엔드 개발자가 알아야 할 추상화

1. **JVM의 추상화**:
   - Java 코드 → 바이트코드 → JVM → OS → 하드웨어
   - "Write Once, Run Anywhere"

2. **데이터베이스 추상화**:
   - SQL 쿼리 → 실행 계획 → 스토리지 엔진 → 디스크 I/O
   - 쿼리 최적화를 위해 하위 계층 이해 필요

3. **네트워크 추상화**:
   - HTTP → TCP → IP → 이더넷 → 물리 계층
   - 각 계층 프로토콜의 역할 이해

### 성능 최적화 시 추상화 계층 고려

```python
# 추상화 계층을 고려한 최적화 예시

# Level 1: 알고리즘 최적화 (가장 큰 효과)
# O(n²) → O(n log n)

# Level 2: 자료구조 최적화
# List → HashSet for lookup

# Level 3: 메모리 접근 패턴 최적화
# 캐시 지역성 고려

# Level 4: 시스템 콜 최적화
# I/O 버퍼링, 배치 처리

# Level 5: 하드웨어 특성 활용
# SIMD, 멀티스레딩
```

## 참고 자료

- Patterson & Hennessy, "Computer Organization and Design" Chapter 1
- Hennessy & Patterson, "Computer Architecture: A Quantitative Approach" Chapter 1
- Joel Spolsky, "The Law of Leaky Abstractions" (2002)
- David Patterson, "A New Golden Age for Computer Architecture" (2019)

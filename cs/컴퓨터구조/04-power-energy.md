# 전력과 에너지 (Power and Energy)

## 개요

현대 프로세서 설계에서 전력 소비는 성능만큼이나 중요한 요소다. 모바일 기기에서는 배터리 수명을, 데이터센터에서는 운영 비용과 냉각 문제를 결정한다. **Power Wall**로 인해 클록 속도 경쟁이 끝나고 멀티코어 시대가 열렸다. 전력 효율적인 설계는 현대 컴퓨터 아키텍처의 핵심 과제다.

## 핵심 개념

### 전력 vs 에너지

```
전력 (Power): 단위 시간당 소비하는 에너지
            P = W/t (와트, W = J/s)

에너지 (Energy): 총 소비한 일의 양
              E = P × t (줄, J)

┌────────────────────────────────────────────────────────────┐
│                   전력 vs 에너지 비유                       │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  전력 = 수도꼭지에서 나오는 물의 양 (유량)                   │
│  에너지 = 욕조에 채워진 물의 총량                           │
│                                                            │
│  빠르게 채우면(높은 전력): 금방 채워짐, 하지만 유량 높음      │
│  천천히 채우면(낮은 전력): 시간 오래 걸림, 하지만 유량 낮음   │
│  총량(에너지)은 같을 수 있음                                │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

### CMOS 회로의 전력 소비

CMOS(Complementary Metal-Oxide-Semiconductor) 회로의 전력 소비:

```
P_total = P_dynamic + P_static

┌────────────────────────────────────────────────────────────┐
│                    전력 소비 구성                           │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  동적 전력 (Dynamic Power)                                 │
│  └── 스위칭 시 발생                                        │
│      └── 커패시터 충/방전 에너지                            │
│                                                            │
│  정적 전력 (Static Power / Leakage)                        │
│  └── 트랜지스터가 완전히 꺼지지 않아 발생                    │
│      └── 누설 전류 (Leakage Current)                       │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

### 동적 전력 (Dynamic Power)

스위칭 활동으로 인한 전력 소비:

```
P_dynamic = α × C × V² × f

여기서:
- α (Activity Factor): 스위칭 확률 (0~1)
- C (Capacitance): 부하 커패시턴스
- V (Voltage): 전원 전압
- f (Frequency): 클록 주파수
```

**각 요소의 영향**:

```
┌─────────────────┬──────────────────────────────────────────┐
│ 요소            │ 영향                                      │
├─────────────────┼──────────────────────────────────────────┤
│ 전압 (V)        │ V² 비례, 가장 큰 영향                     │
│                 │ 전압 50% 감소 → 전력 75% 감소              │
├─────────────────┼──────────────────────────────────────────┤
│ 주파수 (f)      │ 선형 비례                                 │
│                 │ 주파수 50% 감소 → 전력 50% 감소            │
├─────────────────┼──────────────────────────────────────────┤
│ 커패시턴스 (C)  │ 선형 비례                                 │
│                 │ 트랜지스터 크기, 배선 길이에 의존           │
├─────────────────┼──────────────────────────────────────────┤
│ Activity (α)   │ 선형 비례                                 │
│                 │ 실제 스위칭 빈도                          │
└─────────────────┴──────────────────────────────────────────┘
```

**동적 전력 감소 방법**:
```
1. 전압 낮추기 (V↓) → 가장 효과적 (V² 비례)
   단, 전압 낮추면 스위칭 속도 감소 → 최대 주파수 제한

2. 주파수 낮추기 (f↓)
   성능과 직접적 트레이드오프

3. 클록 게이팅 (Clock Gating)
   사용하지 않는 회로의 클록 차단 → α↓

4. 설계 최적화
   짧은 배선, 작은 트랜지스터 → C↓
```

### 정적 전력 (Static Power / Leakage)

트랜지스터가 꺼져 있어도 흐르는 누설 전류:

```
P_static = I_leakage × V

┌────────────────────────────────────────────────────────────┐
│                 누설 전류의 종류                            │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  서브스레숄드 누설 (Subthreshold Leakage)                   │
│  └── 문턱 전압 이하에서도 약간의 전류가 흐름                 │
│  └── 트랜지스터 크기가 작아질수록 심각해짐                   │
│                                                            │
│  게이트 누설 (Gate Leakage)                                │
│  └── 게이트 산화막이 얇아져 터널링 현상 발생                 │
│  └── High-k 유전체로 해결                                   │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

**정적 전력의 중요성 증가**:

```
공정 미세화에 따른 전력 비율 변화:

130nm:  동적 90%, 정적 10%
65nm:   동적 70%, 정적 30%
22nm:   동적 50%, 정적 50%
7nm:    동적 40%, 정적 60%

→ 공정이 미세화될수록 누설 전류 비중 증가
→ 아무것도 안 해도 전력 소비!
```

**정적 전력 감소 방법**:
```
1. Power Gating
   사용하지 않는 회로 블록의 전원 완전 차단

2. Multi-Vt Design
   임계 경로는 Low-Vt (빠름, 누설 높음)
   나머지는 High-Vt (느림, 누설 낮음)

3. Body Biasing
   트랜지스터 바디 전압 조절로 Vt 동적 제어
```

### Power Wall

클록 속도 향상의 한계:

```
┌────────────────────────────────────────────────────────────┐
│                     Power Wall 현상                        │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  2000년대 초반까지:                                        │
│  - Dennard Scaling: 트랜지스터 작아지면 전압도 비례 감소     │
│  - 전력 밀도 일정하게 유지 → 클록 계속 상승                 │
│                                                            │
│  2006년 이후:                                              │
│  - Dennard Scaling 붕괴                                    │
│  - 전압을 더 이상 낮출 수 없음 (문턱 전압 한계)              │
│  - 클록 올리면 전력 밀도 증가 → 발열 문제                   │
│  - ~4GHz에서 정체                                          │
│                                                            │
└────────────────────────────────────────────────────────────┘

CPU 클록 속도 변화:
Year    Clock Speed     Power (TDP)
2000    1.0 GHz         ~30W
2004    3.8 GHz         ~130W
2006    3.0 GHz         ~75W (클록 감소!)
2024    5.0 GHz         ~125W
```

**Power Wall의 결과**:
```
멀티코어로 전환!

단일 코어 성능 향상 한계 → 코어 수 증가

P_dynamic ∝ f (주파수)
하지만 코어 2개를 50% 속도로 돌리면:
- 전력: 2 × 0.5 = 1 (동일)
- 성능: 2 × 0.5 = 1 (단일 스레드) or 2× (멀티 스레드)
- 전압도 낮출 수 있으면 추가 이득!
```

### DVFS (Dynamic Voltage and Frequency Scaling)

전압과 주파수를 동적으로 조절하는 기술:

```
┌────────────────────────────────────────────────────────────┐
│                    DVFS 작동 원리                          │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  부하 높을 때:                                             │
│  └── 전압↑, 주파수↑ → 성능 최대화                          │
│                                                            │
│  부하 낮을 때:                                             │
│  └── 전압↓, 주파수↓ → 전력 절약                            │
│                                                            │
│  V와 f는 함께 조절해야 함:                                  │
│  └── f↑하려면 V↑ 필요 (스위칭 속도 확보)                    │
│  └── V↓하면 f↓ 해야 함 (타이밍 마진)                       │
│                                                            │
└────────────────────────────────────────────────────────────┘

전력 절감 효과:
P_dynamic = α × C × V² × f

전압 20% 감소, 주파수 20% 감소 시:
P_new = α × C × (0.8V)² × 0.8f
      = 0.64 × 0.8 × P_original
      = 0.512 × P_original

→ 약 49% 전력 절감!
```

**DVFS 구현**:
```
운영체제 수준:
- Linux: cpufreq governor (performance, powersave, ondemand)
- Windows: Power Plans

하드웨어 수준:
- Intel Speed Step / Turbo Boost
- AMD Cool'n'Quiet / Precision Boost
```

### Energy-Delay Product (EDP)

에너지 효율성을 측정하는 지표:

```
EDP = Energy × Delay = P × t × t = P × t²

또는

EDP = Power × (Execution Time)²

낮을수록 좋음!
```

**왜 Delay²인가?**:
```
단순히 E × D를 쓰면:
- 매우 느리지만 저전력 → 좋게 평가됨
- 하지만 실제로는 에너지도 많이 씀 (E = P × t)

Delay에 가중치를 줘서:
- 성능과 에너지의 균형 평가
- ED²P (Energy-Delay-Squared Product)도 사용
```

### Dark Silicon

전력 제약으로 칩의 일부만 동시에 사용 가능한 현상:

```
┌────────────────────────────────────────────────────────────┐
│                    Dark Silicon 문제                       │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  트랜지스터 집적도: 무어의 법칙에 따라 계속 증가             │
│  전력 밀도: Dennard Scaling 종료로 개선 안 됨               │
│                                                            │
│  결과:                                                     │
│  - 모든 트랜지스터를 동시에 켤 수 없음                      │
│  - 칩의 일부는 꺼져 있어야 함 (Dark Silicon)                │
│  - 2024년 기준: 칩의 50% 이상이 dark                        │
│                                                            │
│  해결책:                                                   │
│  - 특화 가속기 (GPU, NPU): 필요할 때만 켜기                 │
│  - 이기종 멀티코어: big.LITTLE                              │
│  - Chiplet 설계: 기능별 분리                               │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

## 실무 적용

### 소프트웨어 수준의 전력 최적화

```java
// 배터리/전력 효율적인 코드 작성

// Bad: 바쁜 대기 (Busy Waiting) - CPU 100% 사용
while (!dataReady) {
    // 계속 폴링 → 전력 낭비
}

// Good: 이벤트 기반 대기 - CPU 휴식 가능
synchronized (lock) {
    while (!dataReady) {
        lock.wait();  // CPU가 sleep 상태로 전환
    }
}

// Good: 배치 처리로 wake-up 횟수 줄이기
// 자주 깨우기보다 모아서 처리
```

### 서버/데이터센터 전력 관리

```python
# 데이터센터 전력 효율 지표
# PUE (Power Usage Effectiveness) = 총 전력 / IT 장비 전력
# 이상적: PUE = 1.0, 현실: 1.1 ~ 2.0

# 전력 인식 스케줄링 예시
def power_aware_scheduling(tasks, servers):
    for task in tasks:
        # 현재 부하가 낮은 서버에 할당
        # but 너무 분산되면 많은 서버가 켜져 있어야 함
        # 통합(consolidation)하여 일부 서버 끄기
        pass
```

### 모바일 앱 전력 최적화

```kotlin
// Android 전력 최적화 예시

// Bad: 주기적 폴링
val handler = Handler()
handler.postDelayed(object : Runnable {
    override fun run() {
        checkForUpdates()  // 15초마다 체크 → 배터리 소모
        handler.postDelayed(this, 15000)
    }
}, 15000)

// Good: Push 알림 사용 (서버가 알려줌)
// 또는 WorkManager로 시스템이 최적 시점에 실행
WorkManager.getInstance(context)
    .enqueue(PeriodicWorkRequestBuilder<UpdateWorker>(
        15, TimeUnit.MINUTES
    ).setConstraints(
        Constraints.Builder()
            .setRequiredNetworkType(NetworkType.UNMETERED)
            .setRequiresBatteryNotLow(true)
            .build()
    ).build())
```

## 참고 자료

- Hennessy & Patterson, "Computer Architecture: A Quantitative Approach" Chapter 1
- Mark Horowitz, "Computing's Energy Problem (and what we can do about it)" (2014)
- Hadi Esmaeilzadeh et al., "Dark Silicon and the End of Multicore Scaling" (2011)
- Robert Dennard et al., "Design of Ion-Implanted MOSFETs with Very Small Physical Dimensions" (1974)

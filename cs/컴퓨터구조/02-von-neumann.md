# 폰 노이만 구조 (Von Neumann Architecture)

## 개요

폰 노이만 구조는 1945년 존 폰 노이만이 제안한 컴퓨터 설계 모델이다. **프로그램과 데이터를 같은 메모리에 저장**하는 Stored Program Concept(저장 프로그램 개념)이 핵심이며, 오늘날 대부분의 컴퓨터가 이 구조를 기반으로 한다.

## 핵심 개념

### Stored Program Concept (저장 프로그램 개념)

폰 노이만 구조 이전의 컴퓨터(ENIAC 등)는 프로그램을 변경하려면 물리적으로 배선을 바꿔야 했다.

```
이전 방식:                           폰 노이만 방식:
┌──────────┐                        ┌──────────┐
│ 하드웨어 │ ← 배선 변경 필요          │  메모리   │
│ (배선)   │                        │┌────────┐│
└──────────┘                        ││프로그램 ││ ← 소프트웨어로 변경
                                    │├────────┤│
                                    ││ 데이터  ││
                                    │└────────┘│
                                    └──────────┘
```

핵심 아이디어:
- **프로그램 = 데이터**: 명령어도 데이터처럼 메모리에 저장
- **유연성**: 프로그램 변경 시 메모리 내용만 수정
- **범용성**: 같은 하드웨어로 다양한 프로그램 실행 가능

### 폰 노이만 구조의 구성 요소

```
                    ┌─────────────────────────────────────┐
                    │            메인 메모리               │
                    │   (명령어 + 데이터 저장)             │
                    └─────────────┬───────────────────────┘
                                  │
                              시스템 버스
                    ┌─────────────┴───────────────────────┐
                    │                                     │
        ┌───────────▼───────────┐           ┌────────────▼────────────┐
        │         CPU           │           │       I/O 장치          │
        │  ┌─────────────────┐  │           │                        │
        │  │   제어 유닛 (CU) │  │           │  키보드, 모니터, 디스크  │
        │  │  ┌───────────┐  │  │           │                        │
        │  │  │    PC     │  │  │           └────────────────────────┘
        │  │  │    IR     │  │  │
        │  │  └───────────┘  │  │
        │  └─────────────────┘  │
        │  ┌─────────────────┐  │
        │  │   산술논리 유닛  │  │
        │  │     (ALU)       │  │
        │  └─────────────────┘  │
        │  ┌─────────────────┐  │
        │  │   레지스터      │  │
        │  └─────────────────┘  │
        └───────────────────────┘
```

#### 1. CPU (Central Processing Unit)

**제어 유닛 (Control Unit)**:
- 명령어 해석 및 실행 제어
- PC (Program Counter): 다음 실행할 명령어 주소
- IR (Instruction Register): 현재 실행 중인 명령어

**ALU (Arithmetic Logic Unit)**:
- 산술 연산: 덧셈, 뺄셈, 곱셈, 나눗셈
- 논리 연산: AND, OR, NOT, XOR

**레지스터**:
- CPU 내부의 고속 저장 공간
- 연산 대상 데이터 임시 저장

#### 2. 메모리 (Memory)

- 명령어와 데이터를 모두 저장
- 주소로 접근 (선형 주소 공간)
- 휘발성 (전원 끄면 데이터 소멸)

#### 3. I/O 장치 (Input/Output)

- 외부 세계와의 인터페이스
- 입력: 키보드, 마우스, 센서
- 출력: 모니터, 프린터, 스피커

#### 4. 시스템 버스 (System Bus)

```
┌──────────────────────────────────────────────────┐
│                   시스템 버스                     │
├────────────────┬───────────────┬─────────────────┤
│   주소 버스     │   데이터 버스  │   제어 버스     │
│   (Address)    │    (Data)     │   (Control)    │
│                │               │                │
│ 메모리 주소 전달 │ 데이터 전송    │ 읽기/쓰기 신호  │
│ 단방향         │ 양방향        │ 양방향         │
└────────────────┴───────────────┴─────────────────┘
```

### 명령어 실행 사이클 (Fetch-Decode-Execute)

폰 노이만 구조에서 명령어는 순차적으로 실행된다:

```
┌─────────────┐
│   Fetch     │ ← 메모리에서 명령어 가져오기
│ (인출)      │   IR ← Memory[PC]
└──────┬──────┘   PC ← PC + 1
       │
       ▼
┌─────────────┐
│   Decode    │ ← 명령어 해석
│ (해독)      │   연산 종류, 피연산자 파악
└──────┬──────┘
       │
       ▼
┌─────────────┐
│   Execute   │ ← 명령어 실행
│ (실행)      │   ALU 연산, 메모리 접근
└──────┬──────┘
       │
       └──────→ 다음 명령어로 반복
```

```python
# 의사 코드로 표현한 명령어 실행 사이클
while True:
    # Fetch: 메모리에서 명령어 가져오기
    instruction = memory[PC]
    PC = PC + 1

    # Decode: 명령어 해석
    opcode, operands = decode(instruction)

    # Execute: 명령어 실행
    if opcode == "ADD":
        registers[operands.dest] = registers[operands.src1] + registers[operands.src2]
    elif opcode == "LOAD":
        registers[operands.dest] = memory[operands.address]
    elif opcode == "STORE":
        memory[operands.address] = registers[operands.src]
    elif opcode == "JUMP":
        PC = operands.address
    # ... 기타 명령어
```

### Von Neumann Bottleneck (폰 노이만 병목)

폰 노이만 구조의 가장 큰 문제점은 **병목 현상**이다:

```
┌─────────┐      단일 버스       ┌─────────┐
│   CPU   │ ◄═══════════════► │  Memory │
│(매우 빠름)│    (상대적으로 느림)  │ (느림)   │
└─────────┘                    └─────────┘
     │
     └── CPU가 아무리 빨라도 메모리 속도에 제한됨
```

**문제점**:
1. CPU와 메모리 사이에 하나의 버스만 존재
2. 명령어와 데이터가 같은 버스로 이동 (경쟁)
3. CPU 성능은 급격히 향상되지만, 메모리는 상대적으로 느림
4. CPU가 메모리를 기다리며 유휴 상태 (Memory Stall)

**해결 방안**:
- 캐시 메모리: CPU와 메인 메모리 사이에 고속 버퍼
- 프리페칭: 미리 데이터를 가져옴
- 멀티레벨 캐시: L1, L2, L3 캐시 계층
- 하버드 아키텍처: 명령어와 데이터 경로 분리

### Harvard Architecture (하버드 구조)

폰 노이만 병목을 해결하기 위한 대안:

```
폰 노이만 구조:                    하버드 구조:
┌───────┐                        ┌─────────────┐
│  CPU  │                        │   명령어     │
│       │                        │   메모리     │
└───┬───┘                        └──────┬──────┘
    │                                   │
 단일 버스                            명령어 버스
    │                                   │
┌───┴───┐                        ┌──────┴──────┐
│Memory │                        │    CPU      │
│(명령어 │                        │             │
│+데이터)│                        └──────┬──────┘
└───────┘                              │
                                   데이터 버스
                                       │
                                ┌──────┴──────┐
                                │   데이터     │
                                │   메모리     │
                                └─────────────┘
```

**하버드 구조의 장점**:
- 명령어와 데이터를 동시에 접근 가능
- 더 높은 대역폭
- 파이프라인 효율 향상

**현대 프로세서의 접근**:
- **Modified Harvard**: 내부적으로는 하버드 (L1 I-Cache, L1 D-Cache 분리), 외부적으로는 폰 노이만 (통합 메인 메모리)

```
┌──────────────────────────────────────────────────┐
│                     CPU                          │
│  ┌─────────────┐           ┌─────────────┐      │
│  │ L1 I-Cache  │           │ L1 D-Cache  │      │
│  │ (명령어용)   │           │ (데이터용)   │      │
│  └──────┬──────┘           └──────┬──────┘      │
│         └──────────┬─────────────┘              │
│                    │                            │
│            ┌───────▼───────┐                    │
│            │   L2 Cache    │  ← 통합 캐시       │
│            │   (통합)      │                    │
│            └───────────────┘                    │
└────────────────────┬─────────────────────────────┘
                     │
              ┌──────▼──────┐
              │ Main Memory │  ← 통합 메모리
              └─────────────┘
```

## 실무 적용

### 폰 노이만 구조가 프로그래밍에 미치는 영향

#### 1. 순차적 실행 모델
```python
# 프로그램은 기본적으로 순차 실행
a = 10        # 1번째 실행
b = 20        # 2번째 실행
c = a + b     # 3번째 실행 (이전 결과에 의존)
print(c)      # 4번째 실행
```

#### 2. 메모리 주소 기반 접근
```c
// 포인터 = 메모리 주소 직접 다루기
int x = 42;
int *ptr = &x;     // x의 메모리 주소
printf("%d", *ptr); // 해당 주소의 값 접근
```

#### 3. 프로그램 카운터와 제어 흐름
```c
// 조건문, 반복문은 PC 값을 변경하는 것
if (condition) {
    // condition이 참이면 다음 명령어 실행
} else {
    // 거짓이면 else 블록으로 PC 점프
}

while (condition) {
    // 조건 참이면 계속, 거짓이면 루프 탈출
    // PC가 루프 시작으로 돌아감
}
```

### 성능 최적화와 폰 노이만 구조

```java
// 폰 노이만 병목을 고려한 최적화

// Bad: 캐시 미스 유발 (비연속 메모리 접근)
for (int i = 0; i < size; i++) {
    process(linkedList.get(i));  // 포인터 추적, 캐시 미스
}

// Good: 캐시 친화적 (연속 메모리 접근)
for (int i = 0; i < array.length; i++) {
    process(array[i]);  // 연속 메모리, 캐시 히트
}
```

## 참고 자료

- John von Neumann, "First Draft of a Report on the EDVAC" (1945)
- Patterson & Hennessy, "Computer Organization and Design" Chapter 1
- William Stallings, "Computer Organization and Architecture"
- Wikipedia - Von Neumann architecture

# 프로세스 vs 스레드

## 개요

프로세스와 스레드는 운영체제에서 **실행 단위**를 나타냅니다.

- **프로세스**: 실행 중인 프로그램, 독립적인 메모리 공간
- **스레드**: 프로세스 내의 실행 흐름, 메모리 공유

## 핵심 개념

### 1. 프로세스 (Process)

#### 정의
- 실행 중인 프로그램의 **인스턴스**
- 운영체제로부터 **독립적인 메모리 공간** 할당
- 최소 1개의 스레드(메인 스레드) 보유

#### 프로세스 메모리 구조

```
┌─────────────────┐  높은 주소
│      Stack      │  ← 지역 변수, 함수 호출 정보
│        ↓        │
│                 │
│        ↑        │
│       Heap      │  ← 동적 할당 메모리
├─────────────────┤
│       BSS       │  ← 초기화되지 않은 전역 변수
├─────────────────┤
│       Data      │  ← 초기화된 전역 변수
├─────────────────┤
│       Code      │  ← 실행 코드 (Read-Only)
└─────────────────┘  낮은 주소
```

| 영역 | 설명 | 특징 |
|------|------|------|
| Code | 실행 코드 | 읽기 전용 |
| Data | 초기화된 전역/정적 변수 | 읽기/쓰기 |
| BSS | 초기화되지 않은 전역/정적 변수 | 0으로 초기화 |
| Heap | 동적 메모리 (malloc, new) | 위로 증가 |
| Stack | 지역 변수, 함수 호출 정보 | 아래로 증가 |

#### PCB (Process Control Block)

프로세스 메타데이터를 저장하는 자료구조입니다.

```
┌─────────────────────────┐
│  Process ID (PID)       │
│  Process State          │
│  Program Counter        │
│  CPU Registers          │
│  Memory Management Info │
│  I/O Status Info        │
│  Scheduling Info        │
└─────────────────────────┘
```

### 2. 스레드 (Thread)

#### 정의
- 프로세스 내의 **실행 흐름**
- 경량 프로세스(Lightweight Process)라고도 함
- 같은 프로세스의 스레드끼리 **메모리 공유**

#### 스레드 메모리 구조

```
프로세스 메모리
┌─────────────────┐
│      Code       │  ← 모든 스레드 공유
├─────────────────┤
│      Data       │  ← 모든 스레드 공유
├─────────────────┤
│      Heap       │  ← 모든 스레드 공유
├─────────────────┤
│  Thread 1 Stack │  ← 스레드별 독립
├─────────────────┤
│  Thread 2 Stack │  ← 스레드별 독립
├─────────────────┤
│  Thread 3 Stack │  ← 스레드별 독립
└─────────────────┘
```

**스레드가 공유하는 것**:
- Code, Data, Heap 영역
- 파일 디스크립터
- 전역 변수

**스레드가 독립적으로 가지는 것**:
- Stack
- PC (Program Counter)
- 레지스터
- TID (Thread ID)

### 3. 프로세스 vs 스레드 비교

| 특성 | 프로세스 | 스레드 |
|------|----------|--------|
| 메모리 | 독립적 | 공유 (Stack만 독립) |
| 생성 비용 | 높음 | 낮음 |
| 컨텍스트 스위칭 | 느림 | 빠름 |
| 통신 | IPC 필요 | 메모리 공유로 간단 |
| 안정성 | 한 프로세스 문제가 다른 프로세스에 영향 X | 한 스레드 문제가 전체 프로세스에 영향 |
| 동기화 | 불필요 | 필요 (공유 자원) |

### 4. 컨텍스트 스위칭 (Context Switching)

CPU가 한 프로세스/스레드에서 다른 것으로 전환하는 것입니다.

#### 프로세스 컨텍스트 스위칭

```
프로세스 A 실행
    ↓
A의 상태 PCB에 저장
    ↓
B의 상태 PCB에서 로드
    ↓
메모리 맵 변경 (페이지 테이블 교체)  ← 비용 큼
    ↓
TLB 플러시  ← 비용 큼
    ↓
프로세스 B 실행
```

#### 스레드 컨텍스트 스위칭 (같은 프로세스 내)

```
스레드 A 실행
    ↓
A의 레지스터, PC, Stack 저장
    ↓
B의 레지스터, PC, Stack 로드
    ↓
스레드 B 실행
```

**스레드가 더 빠른 이유**:
- 메모리 맵 변경 불필요 (같은 주소 공간)
- TLB 플러시 불필요
- 캐시 히트율 높음

### 5. 멀티프로세스 vs 멀티스레드

#### 멀티프로세스

여러 프로세스로 병렬 처리합니다.

```
┌─────────┐  ┌─────────┐  ┌─────────┐
│Process 1│  │Process 2│  │Process 3│
│ [Memory]│  │ [Memory]│  │ [Memory]│
└─────────┘  └─────────┘  └─────────┘
     ↑            ↑            ↑
     └────── IPC ─┴───── IPC ──┘
```

**장점**:
- 안정성: 한 프로세스 crash가 다른 프로세스에 영향 X
- 보안: 메모리 격리

**단점**:
- 높은 메모리 사용량
- IPC 오버헤드
- 컨텍스트 스위칭 비용

**사용 사례**: Chrome 브라우저 (탭별 프로세스)

#### 멀티스레드

한 프로세스 내 여러 스레드로 병렬 처리합니다.

```
┌───────────────────────────────────┐
│           Process                 │
│  ┌───────┐ ┌───────┐ ┌───────┐  │
│  │Thread1│ │Thread2│ │Thread3│  │
│  └───────┘ └───────┘ └───────┘  │
│  [       공유 메모리           ]  │
└───────────────────────────────────┘
```

**장점**:
- 낮은 메모리 사용량
- 빠른 통신 (메모리 공유)
- 빠른 컨텍스트 스위칭

**단점**:
- 한 스레드 문제 → 전체 프로세스 crash
- 동기화 필요 (Race Condition)
- 디버깅 어려움

**사용 사례**: 웹 서버, 게임 서버

### 6. 동기화 문제

멀티스레드에서 공유 자원 접근 시 발생하는 문제입니다.

#### Race Condition

```java
// 두 스레드가 동시에 실행
// 결과: count가 2가 아닐 수 있음
int count = 0;

// Thread 1
count++;  // 읽기 → 증가 → 쓰기

// Thread 2
count++;  // 읽기 → 증가 → 쓰기
```

```
시간 →
T1: READ(count=0)
                    T2: READ(count=0)
T1: count = 0 + 1
                    T2: count = 0 + 1
T1: WRITE(count=1)
                    T2: WRITE(count=1)
결과: count = 1 (기대값: 2)
```

#### 해결: 동기화 기법

```java
// Mutex (상호 배제)
synchronized void increment() {
    count++;
}

// Java Lock
lock.lock();
try {
    count++;
} finally {
    lock.unlock();
}
```

### 7. User Thread vs Kernel Thread

#### User Thread
- 사용자 공간에서 스레드 라이브러리가 관리
- 커널은 스레드 존재를 모름
- 빠른 생성/스위칭
- 하나의 스레드 블로킹 → 전체 프로세스 블로킹

#### Kernel Thread
- 커널이 직접 관리
- 진정한 병렬 실행 가능
- 생성/스위칭 비용 높음
- 하나의 스레드 블로킹 → 다른 스레드 실행 가능

#### 매핑 모델

| 모델 | 설명 |
|------|------|
| Many-to-One | 여러 User Thread → 1 Kernel Thread |
| One-to-One | 1 User Thread → 1 Kernel Thread (Linux, Windows) |
| Many-to-Many | 여러 User Thread → 여러 Kernel Thread |

## 실무 적용

### 언제 멀티프로세스? 언제 멀티스레드?

| 상황 | 선택 |
|------|------|
| 안정성이 최우선 | 멀티프로세스 |
| 성능이 최우선 | 멀티스레드 |
| 메모리 제한 | 멀티스레드 |
| 독립적인 작업 | 멀티프로세스 |
| 데이터 공유 빈번 | 멀티스레드 |

### 실제 사례

- **Nginx**: 멀티프로세스 (Worker Process)
- **Apache**: 멀티스레드/멀티프로세스 선택 가능
- **Node.js**: 싱글 스레드 + 이벤트 루프 + Worker Thread (I/O)
- **Java Spring**: 멀티스레드 (Thread Pool)

## 참고 자료

- Operating System Concepts (공룡책)
- [Linux 프로세스 관리](https://www.kernel.org/doc/html/latest/admin-guide/mm/concepts.html)

# 컨텍스트 스위칭 (Context Switching)

## 개요

컨텍스트 스위칭은 CPU가 한 프로세스(또는 스레드)에서 다른 프로세스로 전환할 때 **현재 상태를 저장하고 새 상태를 복원**하는 과정입니다. 멀티태스킹의 핵심 메커니즘이지만 오버헤드가 발생합니다.

```
Process A 실행 중
      │
      ▼
┌─────────────────┐
│  A의 상태 저장  │ ← 레지스터, PC, SP 등
└─────────────────┘
      │
      ▼
┌─────────────────┐
│  B의 상태 복원  │ ← PCB에서 로드
└─────────────────┘
      │
      ▼
Process B 실행 시작
```

## 핵심 개념

### 1. 컨텍스트란?

프로세스가 실행 중일 때 CPU와 메모리에 있는 모든 상태 정보입니다.

#### 1.1 CPU 컨텍스트

```
┌─────────────────────────────────────────┐
│              CPU 레지스터               │
├─────────────────────────────────────────┤
│ PC (Program Counter)    │ 다음 실행할 명령어 주소 │
│ SP (Stack Pointer)      │ 현재 스택 위치          │
│ BP (Base Pointer)       │ 스택 프레임 기준 주소   │
│ General Purpose Regs    │ 연산용 레지스터         │
│ (RAX, RBX, RCX, ...)    │ (x86-64 기준 16개)      │
│ Flags/Status Register   │ 상태 플래그             │
│ Floating Point Regs     │ 부동소수점 연산용       │
│ SIMD Registers (XMM)    │ 벡터 연산용             │
└─────────────────────────────────────────┘
```

#### 1.2 메모리 컨텍스트

```
┌─────────────────────────────────────────┐
│           메모리 관리 정보              │
├─────────────────────────────────────────┤
│ 페이지 테이블 베이스 레지스터 (CR3)    │
│ 메모리 맵 정보                         │
│ 세그먼트 레지스터                      │
└─────────────────────────────────────────┘
```

#### 1.3 PCB에 저장되는 정보

```c
// Linux task_struct 주요 필드 (간략화)
struct task_struct {
    volatile long state;           // 프로세스 상태
    pid_t pid;                     // 프로세스 ID
    struct mm_struct *mm;          // 메모리 디스크립터

    struct thread_struct thread;   // CPU 레지스터 상태
    /*
     * thread_struct에 저장되는 정보:
     * - sp (stack pointer)
     * - 기타 CPU 레지스터들
     * - FPU 상태
     */

    struct files_struct *files;    // 열린 파일 테이블
    struct signal_struct *signal;  // 시그널 정보
    // ...
};
```

### 2. 컨텍스트 스위칭 과정

#### 2.1 상세 과정

```
┌─────────────────────────────────────────────────────────────┐
│                   컨텍스트 스위칭 과정                       │
└─────────────────────────────────────────────────────────────┘

1. 트리거 발생 (인터럽트, 시스템 콜, 스케줄러)
        │
        ▼
2. ┌────────────────────────────────────────┐
   │  현재 프로세스(A) 상태 저장           │
   │  - 범용 레지스터 → A의 커널 스택      │
   │  - PC, SP → A의 task_struct          │
   │  - 플래그 레지스터 저장               │
   │  - FPU/SIMD 상태 저장 (lazy saving)   │
   └────────────────────────────────────────┘
        │
        ▼
3. ┌────────────────────────────────────────┐
   │  스케줄러 호출                         │
   │  - 다음 실행할 프로세스(B) 선택       │
   │  - 실행 큐에서 B 선택                 │
   └────────────────────────────────────────┘
        │
        ▼
4. ┌────────────────────────────────────────┐
   │  메모리 컨텍스트 전환                 │
   │  - 페이지 테이블 교체 (CR3 레지스터)  │
   │  - TLB 플러시 (또는 ASID 사용)        │
   └────────────────────────────────────────┘
        │
        ▼
5. ┌────────────────────────────────────────┐
   │  새 프로세스(B) 상태 복원             │
   │  - B의 task_struct → PC, SP          │
   │  - B의 커널 스택 → 범용 레지스터      │
   │  - 플래그 레지스터 복원               │
   └────────────────────────────────────────┘
        │
        ▼
6. 프로세스 B 실행 시작
```

#### 2.2 Linux의 context_switch() 함수

```c
// kernel/sched/core.c (개념적 코드)
static inline struct rq *
context_switch(struct rq *rq, struct task_struct *prev,
               struct task_struct *next)
{
    // 1. 메모리 컨텍스트 전환 준비
    prepare_task_switch(rq, prev, next);

    // 2. 메모리 맵 전환 (페이지 테이블)
    if (!next->mm) {
        // 커널 스레드인 경우
        next->active_mm = prev->active_mm;
    } else {
        // 유저 프로세스인 경우
        switch_mm(prev->active_mm, next->mm, next);
    }

    // 3. CPU 컨텍스트 전환 (아키텍처 의존적)
    switch_to(prev, next, prev);

    return rq;
}
```

### 3. 프로세스 vs 스레드 컨텍스트 스위칭

#### 3.1 프로세스 컨텍스트 스위칭

```
프로세스 A → 프로세스 B

┌─────────────────────────────────────────────┐
│  저장/복원 대상                             │
├─────────────────────────────────────────────┤
│  ✓ CPU 레지스터 (전체)                     │
│  ✓ 페이지 테이블 (CR3 교체)                │
│  ✓ TLB 플러시                              │
│  ✓ 캐시 무효화 (일부)                      │
│  ✓ 파일 디스크립터 테이블 (간접적)         │
│  ✓ 시그널 핸들러                           │
└─────────────────────────────────────────────┘

비용: 높음 (수 마이크로초)
```

#### 3.2 스레드 컨텍스트 스위칭 (같은 프로세스 내)

```
스레드 A → 스레드 B (같은 프로세스)

┌─────────────────────────────────────────────┐
│  저장/복원 대상                             │
├─────────────────────────────────────────────┤
│  ✓ CPU 레지스터                            │
│  ✓ 스택 포인터                             │
│  ✓ TLS (Thread Local Storage)              │
├─────────────────────────────────────────────┤
│  ✗ 페이지 테이블 (동일)                    │
│  ✗ TLB 플러시 불필요                       │
│  ✗ 캐시 무효화 최소화                      │
│  ✗ 파일 디스크립터 (공유)                  │
└─────────────────────────────────────────────┘

비용: 낮음 (수백 나노초)
```

#### 3.3 비용 비교

```
┌────────────────────┬─────────────────┬─────────────────┐
│ 항목               │ 프로세스 전환   │ 스레드 전환     │
├────────────────────┼─────────────────┼─────────────────┤
│ 레지스터 저장/복원 │ 필요            │ 필요            │
│ 페이지 테이블 교체 │ 필요 (CR3 변경) │ 불필요          │
│ TLB 플러시         │ 필요            │ 불필요          │
│ 캐시 영향          │ 크다 (Cold)     │ 작다 (Warm)     │
│ 예상 시간          │ 1~10 μs         │ 0.1~1 μs        │
└────────────────────┴─────────────────┴─────────────────┘
```

### 4. 컨텍스트 스위칭 오버헤드

#### 4.1 직접 비용 (Direct Cost)

```
직접 비용 = 실제 전환 작업에 드는 시간

┌─────────────────────────────────────────────┐
│  1. 레지스터 저장            (~100 cycles) │
│  2. 스케줄러 실행            (~200 cycles) │
│  3. 페이지 테이블 전환       (~50 cycles)  │
│  4. 레지스터 복원            (~100 cycles) │
├─────────────────────────────────────────────┤
│  총 직접 비용: ~500-1000 CPU cycles        │
│  (약 0.2-0.5 μs @ 2GHz)                    │
└─────────────────────────────────────────────┘
```

#### 4.2 간접 비용 (Indirect Cost)

```
간접 비용 = 캐시/TLB 미스로 인한 추가 지연

┌─────────────────────────────────────────────┐
│  TLB 미스 비용                              │
│  ─────────────────────────────────────────  │
│  TLB 플러시 후 페이지 테이블 워킹:         │
│  - 4단계 페이지 테이블 × 메모리 접근       │
│  - 최대 수백 cycles per TLB miss           │
├─────────────────────────────────────────────┤
│  캐시 미스 비용                             │
│  ─────────────────────────────────────────  │
│  새 프로세스의 데이터가 캐시에 없음:       │
│  - L1 miss: ~4 cycles                       │
│  - L2 miss: ~12 cycles                      │
│  - L3 miss: ~40 cycles                      │
│  - RAM 접근: ~100+ cycles                   │
├─────────────────────────────────────────────┤
│  총 간접 비용: 수천~수만 cycles            │
│  (직접 비용보다 훨씬 큼!)                  │
└─────────────────────────────────────────────┘
```

#### 4.3 측정 방법

```c
// 간단한 컨텍스트 스위칭 시간 측정
#include <time.h>
#include <unistd.h>

int main() {
    int pipe_fd[2];
    pipe(pipe_fd);

    struct timespec start, end;
    char buf;

    pid_t pid = fork();
    if (pid == 0) {
        // 자식: 읽고 쓰기 반복
        for (int i = 0; i < 10000; i++) {
            read(pipe_fd[0], &buf, 1);
            write(pipe_fd[1], &buf, 1);
        }
    } else {
        // 부모: 시간 측정
        clock_gettime(CLOCK_MONOTONIC, &start);

        for (int i = 0; i < 10000; i++) {
            write(pipe_fd[1], &buf, 1);
            read(pipe_fd[0], &buf, 1);
        }

        clock_gettime(CLOCK_MONOTONIC, &end);

        double elapsed = (end.tv_sec - start.tv_sec) * 1e6 +
                        (end.tv_nsec - start.tv_nsec) / 1e3;
        printf("Context switch time: %.2f μs\n", elapsed / 20000);
    }
    return 0;
}
```

### 5. TLB와 컨텍스트 스위칭

#### 5.1 TLB 플러시 문제

```
프로세스 전환 시:
┌─────────────────────────────────────────────┐
│  TLB에는 이전 프로세스의 주소 변환 정보    │
│  새 프로세스가 같은 가상 주소 사용 가능    │
│  → 잘못된 물리 주소로 변환될 위험!         │
│  → TLB 플러시 필요                          │
└─────────────────────────────────────────────┘
```

#### 5.2 ASID (Address Space ID)

```
TLB 플러시 없이 프로세스 구분

TLB Entry with ASID:
┌────────────────────────────────────────────────────┐
│  ASID  │  Virtual Page Number  │  Physical Frame  │
└────────────────────────────────────────────────────┘
    │
    └── 각 프로세스에 고유한 ID 부여

프로세스 전환 시:
- TLB 플러시 불필요
- 현재 ASID만 변경
- 다른 ASID의 엔트리는 그대로 유지

x86-64: PCID (Process Context ID)
ARM: ASID
```

### 6. 컨텍스트 스위칭 트리거

```
┌─────────────────────────────────────────────────────┐
│            컨텍스트 스위칭 발생 시점                │
├─────────────────────────────────────────────────────┤
│                                                     │
│  1. 타임 슬라이스 만료                              │
│     - 타이머 인터럽트 발생                         │
│     - 스케줄러가 다음 프로세스 선택                │
│                                                     │
│  2. I/O 대기                                        │
│     - 프로세스가 블로킹 I/O 호출                   │
│     - 자발적으로 CPU 양보                          │
│                                                     │
│  3. 높은 우선순위 프로세스 도착                    │
│     - 선점형 스케줄링에서 발생                     │
│     - 현재 프로세스 중단, 높은 우선순위 실행       │
│                                                     │
│  4. 동기화 대기                                     │
│     - 뮤텍스, 세마포어 대기                        │
│     - 프로세스 블록 상태로 전환                    │
│                                                     │
│  5. 명시적 양보 (yield)                             │
│     - sched_yield() 호출                           │
│     - 자발적 CPU 양보                              │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### 7. 최적화 기법

#### 7.1 Lazy FPU Context Switching

```
아이디어: 모든 프로세스가 FPU를 사용하지는 않음

전통 방식:
컨텍스트 스위칭 시 항상 FPU 레지스터 저장/복원
→ 불필요한 오버헤드

Lazy 방식:
1. 컨텍스트 스위칭 시 FPU 저장 안 함
2. FPU 비활성화 상태로 설정
3. 새 프로세스가 FPU 사용 시도
4. #NM Exception 발생
5. 그때 이전 FPU 상태 저장, 새 상태 로드
6. FPU 활성화

결과: FPU 미사용 프로세스는 오버헤드 없음
```

#### 7.2 Kernel Same-Page Merging (KSM)

```
동일 페이지 공유로 메모리 절약 + TLB 효율 향상

가상화 환경에서 유용:
┌─────────────────┐  ┌─────────────────┐
│      VM 1       │  │      VM 2       │
│ [동일한 라이브러리 페이지] [동일한 라이브러리 페이지]
└────────┬────────┘  └────────┬────────┘
         │                    │
         └──────┬─────────────┘
                ▼
        ┌─────────────────┐
        │   단일 물리     │
        │   프레임       │
        └─────────────────┘
```

## 실무 적용

### 컨텍스트 스위칭 모니터링

```bash
# Linux에서 컨텍스트 스위칭 통계
vmstat 1
# cs 열: 초당 컨텍스트 스위칭 횟수

# 특정 프로세스의 컨텍스트 스위칭
cat /proc/<pid>/status | grep ctxt
# voluntary_ctxt_switches: 자발적 전환 (I/O 대기 등)
# nonvoluntary_ctxt_switches: 비자발적 전환 (타임슬라이스 만료)

# 시스템 전체 스케줄링 통계
cat /proc/schedstat
```

### 컨텍스트 스위칭 최소화 전략

```
1. I/O 최적화
   - 비동기 I/O (epoll, io_uring)
   - 배치 처리로 I/O 횟수 감소

2. 락 최적화
   - 락 보유 시간 최소화
   - Lock-free 자료구조 사용

3. CPU Affinity 설정
   - 프로세스를 특정 CPU에 바인딩
   - 캐시 친화성 유지

4. 적절한 스레드 수
   - CPU 코어 수에 맞는 스레드 풀
   - 과도한 스레드 생성 방지
```

## 참고 자료

- Understanding the Linux Kernel (Bovet, Cesati) - Chapter 3: Processes
- Linux Kernel Development (Love) - Chapter 4: Process Scheduling
- [Linux Kernel Source - context_switch()](https://github.com/torvalds/linux/blob/master/kernel/sched/core.c)
- Computer Architecture: A Quantitative Approach (Hennessy, Patterson)
- [Intel® 64 and IA-32 Architectures Software Developer's Manual](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)

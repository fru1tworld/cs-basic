# 가상 메모리 (Virtual Memory)

## 개요

가상 메모리는 물리 메모리보다 큰 프로그램을 실행할 수 있게 해주는 메모리 관리 기법입니다. 프로세스의 일부만 메모리에 올려두고, 나머지는 디스크에 저장합니다.

```
프로세스 관점                    실제 메모리
┌─────────────┐
│ 가상 주소   │                ┌─────────────┐
│ 공간       │                │ 물리 메모리  │
│ (큰 공간)   │  ─── 매핑 ───→ │ (작은 공간)  │
│            │                └─────────────┘
│            │                      +
└─────────────┘                ┌─────────────┐
                               │   디스크    │
                               │ (스왑 영역)  │
                               └─────────────┘
```

**핵심 아이디어**: 프로세스 전체가 메모리에 있을 필요 없이, 현재 실행에 필요한 부분만 있으면 된다.

## 핵심 개념

### 1. 가상 메모리가 필요한 이유

#### 1.1 메모리 부족 문제

```
물리 메모리: 8GB
실행해야 할 프로그램들:
- Chrome: 4GB
- IDE: 3GB
- Slack: 1GB
- 기타: 2GB
────────────
합계: 10GB > 8GB (물리 메모리 초과!)

해결: 가상 메모리로 일부만 물리 메모리에 로드
```

#### 1.2 가상 메모리의 장점

| 장점 | 설명 |
|------|------|
| 큰 주소 공간 | 물리 메모리보다 큰 프로그램 실행 가능 |
| 메모리 보호 | 프로세스 간 메모리 격리 |
| 메모리 공유 | 공유 라이브러리, 공유 메모리 구현 용이 |
| 효율적 메모리 사용 | 필요한 부분만 로드 |

### 2. 요구 페이징 (Demand Paging)

필요한 페이지만 메모리에 로드하는 기법입니다.

#### 2.1 기본 개념

```
프로그램 시작 시:
┌───────────────────────────────────────┐
│ 전체 프로그램을 메모리에 로드? ✗     │
│ 필요한 페이지만 로드? ✓              │
└───────────────────────────────────────┘

실행 흐름:
1. 프로세스 시작 → 페이지 테이블만 생성 (메모리 로드 X)
2. 페이지 접근 시 → 해당 페이지가 메모리에 있는지 확인
3. 없으면 → Page Fault → 디스크에서 로드
4. 있으면 → 정상 접근
```

#### 2.2 Valid/Invalid Bit

페이지 테이블 엔트리(PTE)에 해당 페이지가 메모리에 있는지 표시합니다.

```
Page Table Entry (PTE)
┌─────────────────────────────────────────────┐
│ Valid │ Frame Number │ R/W │ User │ Dirty  │
│  Bit  │   (물리)     │     │      │  Bit   │
└─────────────────────────────────────────────┘

Valid Bit:
- 1 (Valid): 페이지가 물리 메모리에 있음
- 0 (Invalid): 페이지가 물리 메모리에 없음 (디스크에 있거나 할당 안 됨)
```

```
페이지 테이블 예시:
┌──────┬───────┬────────────┐
│ Page │ Valid │ Frame Num  │
├──────┼───────┼────────────┤
│  0   │   1   │     5      │  ← 메모리에 있음
│  1   │   0   │     -      │  ← 메모리에 없음
│  2   │   1   │     9      │  ← 메모리에 있음
│  3   │   0   │     -      │  ← 메모리에 없음
│  4   │   1   │     2      │  ← 메모리에 있음
└──────┴───────┴────────────┘
```

### 3. 페이지 폴트 (Page Fault)

접근하려는 페이지가 메모리에 없을 때 발생하는 인터럽트입니다.

#### 3.1 페이지 폴트 처리 과정

```
CPU가 가상 주소 접근
        │
        ▼
    TLB 확인
        │
   TLB Miss
        │
        ▼
  페이지 테이블 확인
        │
        ▼
  Valid Bit = 0?  ──────────────┐
        │ Yes                   │ No
        ▼                       ▼
  [Page Fault!]            정상 접근
        │
        ▼
┌───────────────────────────────────────┐
│           Page Fault 처리            │
│                                       │
│ 1. 트랩 발생 → OS로 제어권 이동      │
│ 2. 유효한 접근인지 확인              │
│    - 유효: 계속 진행                 │
│    - 무효: Segmentation Fault        │
│ 3. 빈 프레임 찾기                    │
│    - 있으면: 사용                    │
│    - 없으면: 페이지 교체             │
│ 4. 디스크에서 페이지 로드 (I/O)      │
│ 5. 페이지 테이블 업데이트            │
│    - Valid Bit = 1                   │
│    - Frame Number 설정               │
│ 6. 명령어 재실행                     │
└───────────────────────────────────────┘
```

#### 3.2 페이지 폴트 처리 시간

```
주요 시간 소요 요소:
1. 페이지 폴트 인터럽트 처리: ~1μs
2. 페이지 테이블/권한 확인: ~1μs
3. 디스크 I/O (가장 큼!)
   - HDD: ~8ms (8,000,000ns)
   - SSD: ~100μs (100,000ns)
4. 페이지 테이블 업데이트: ~1μs
5. 프로세스 재시작: ~1μs

비교:
- 메모리 접근: ~100ns
- Page Fault (HDD): ~8,000,000ns

Page Fault는 메모리 접근보다 약 80,000배 느림!
```

#### 3.3 유효 접근 시간 (Effective Access Time)

```
EAT = (1 - p) × ma + p × page_fault_time

p: 페이지 폴트 확률
ma: 메모리 접근 시간 (~100ns)
page_fault_time: 페이지 폴트 처리 시간 (~8ms for HDD)

예시 (p = 0.001, 즉 1000번 중 1번 Page Fault):
EAT = (1 - 0.001) × 100ns + 0.001 × 8,000,000ns
    = 99.9ns + 8,000ns
    = 8,099.9ns

메모리만 접근할 때보다 약 80배 느려짐!

결론: Page Fault 확률을 최소화하는 것이 핵심
```

### 4. Pure Demand Paging vs Prepaging

#### 4.1 Pure Demand Paging

```
시작 시 페이지 로드: 0개
페이지 로드 시점: 접근할 때만

장점:
- 메모리 사용량 최소화
- 불필요한 페이지 로드 방지

단점:
- 초기 실행 시 많은 Page Fault 발생
- 시작이 느림
```

#### 4.2 Prepaging (Prefetching)

```
필요할 것으로 예상되는 페이지를 미리 로드

예측 방법:
1. 지역성(Locality) 기반: 인접 페이지 미리 로드
2. Working Set 기반: 이전 실행에서 사용한 페이지들
3. 패턴 인식: 접근 패턴 학습

장점:
- Page Fault 감소
- 실행 속도 향상

단점:
- 예측이 틀리면 메모리 낭비
- I/O 대역폭 소모
```

### 5. Copy-on-Write (COW)

fork() 시스템 콜 최적화를 위한 기법입니다.

#### 5.1 기본 아이디어

```
fork() 호출 시:
─────────────────────────────────────────────

전통적 방식:
Parent 메모리 전체를 Child에 복사
→ 시간과 메모리 낭비 (특히 exec() 직후 호출 시)

Copy-on-Write:
Parent와 Child가 같은 물리 페이지를 공유
쓰기 발생 시에만 해당 페이지를 복사
```

#### 5.2 COW 동작 과정

```
1. fork() 호출 직후
─────────────────────────────────────────────
Parent                     Child
┌───────────┐             ┌───────────┐
│ Page 1    │─────────────│ Page 1    │
│ (R/O)     │──┐     ┌────│ (R/O)     │
└───────────┘  │     │    └───────────┘
               │     │
               ▼     ▼
          ┌─────────────┐
          │  물리 메모리  │
          │   Frame 5   │
          └─────────────┘

두 프로세스가 같은 물리 프레임을 공유
페이지는 Read-Only로 표시


2. Parent가 Page 1에 쓰기 시도
─────────────────────────────────────────────
Parent: Page 1에 쓰기 시도
         │
         ▼
    Page Fault 발생 (R/O 페이지에 쓰기)
         │
         ▼
    OS가 COW 상황 인식
         │
         ▼
    Parent용 새 프레임 할당 및 복사
         │
         ▼
    Parent의 페이지 테이블 업데이트 (R/W)


3. 복사 후
─────────────────────────────────────────────
Parent                     Child
┌───────────┐             ┌───────────┐
│ Page 1    │             │ Page 1    │
│ (R/W)     │             │ (R/W)     │
└─────┬─────┘             └─────┬─────┘
      │                         │
      ▼                         ▼
┌─────────────┐           ┌─────────────┐
│  Frame 7    │           │  Frame 5    │
│   (새 복사)  │           │  (원본)    │
└─────────────┘           └─────────────┘
```

#### 5.3 COW 장점

```
fork() + exec() 패턴:
─────────────────────────────────────────────
pid = fork();
if (pid == 0) {
    exec("/bin/ls");  // 새 프로그램 로드 → 이전 페이지 버림
}

COW 없이: fork()에서 전체 복사 → exec()에서 버림 (낭비)
COW 사용: fork()에서 공유 → exec()에서 새로 로드 (효율적)
```

### 6. Memory-Mapped Files

파일을 가상 메모리에 매핑하여 접근하는 기법입니다.

#### 6.1 기본 개념

```
일반적인 파일 I/O:
read(fd, buffer, size);  // 시스템 콜 → 커널 버퍼 → 유저 버퍼
write(fd, buffer, size); // 유저 버퍼 → 커널 버퍼 → 디스크

Memory-Mapped I/O:
char *ptr = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
// 파일이 가상 메모리에 매핑됨
// ptr[0], ptr[1], ... 로 직접 접근
// Page Fault 발생 시 자동으로 디스크에서 로드
```

#### 6.2 mmap() 동작

```c
#include <sys/mman.h>

// 파일을 메모리에 매핑
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);

// 매핑 해제
int munmap(void *addr, size_t length);
```

```
가상 주소 공간              디스크
┌─────────────┐            ┌─────────────┐
│             │            │   File      │
│ ┌─────────┐ │            │  ┌───────┐  │
│ │ Mapped  │◄├────────────┤──│ Data  │  │
│ │ Region  │ │  Demand    │  └───────┘  │
│ └─────────┘ │  Paging    │             │
│             │            │             │
└─────────────┘            └─────────────┘
```

#### 6.3 장점

| 항목 | 일반 I/O | mmap |
|------|----------|------|
| 복사 횟수 | 2번 (커널↔유저) | 0번 (직접 접근) |
| 시스템 콜 | 매 read/write | 초기 mmap만 |
| 랜덤 접근 | lseek 필요 | 포인터로 직접 |
| 여러 프로세스 공유 | 복잡 | MAP_SHARED로 간단 |

### 7. 스왑 공간 (Swap Space)

물리 메모리가 부족할 때 페이지를 저장하는 디스크 영역입니다.

#### 7.1 스왑 동작

```
물리 메모리 부족 상황:
┌─────────────────────────────────────────┐
│ 메모리 가득 참                          │
│         │                               │
│         ▼                               │
│ 페이지 교체 알고리즘으로 희생자 선정    │
│         │                               │
│         ▼                               │
│ Dirty Page면 스왑 영역에 기록           │
│ Clean Page면 그냥 버림                  │
│         │                               │
│         ▼                               │
│ 새 페이지를 빈 프레임에 로드            │
└─────────────────────────────────────────┘
```

#### 7.2 Dirty Bit

```
Page Table Entry
┌──────────────────────────────────────────┐
│  ...  │ Dirty │  ...  │  Frame Number   │
└──────────────────────────────────────────┘
           │
           ├── 0: Clean (수정 안 됨) → 버려도 됨
           └── 1: Dirty (수정됨) → 스왑에 기록해야 함
```

```
페이지 상태에 따른 처리:

Clean Page (Dirty = 0):
- 디스크의 원본과 동일
- 교체 시 그냥 버림 (필요하면 다시 로드)

Dirty Page (Dirty = 1):
- 메모리에서 수정됨
- 교체 시 스왑 영역에 기록해야 함 (Swap Out)
- I/O 발생 → 느림
```

## 실무 적용

### Linux에서의 가상 메모리 확인

```bash
# 프로세스의 가상 메모리 맵 확인
cat /proc/<pid>/maps

# 시스템 메모리 상태
free -h

# 스왑 사용량
swapon --show

# 페이지 폴트 통계
vmstat 1
```

```
$ cat /proc/1234/maps
주소 범위              권한  오프셋   장치   inode  경로
00400000-00410000      r-xp  00000000 08:01  12345  /usr/bin/program
00610000-00611000      r--p  00010000 08:01  12345  /usr/bin/program
00611000-00612000      rw-p  00011000 08:01  12345  /usr/bin/program
7f8a12340000-7f8a12540000 r-xp 00000000 08:01 23456 /lib/x86_64-linux-gnu/libc.so.6
...
7fff12340000-7fff12361000 rw-p 00000000 00:00 0     [stack]
```

### Page Fault 최소화 전략

1. **지역성 활용**: 데이터를 연속적으로 접근
2. **적절한 자료구조**: 배열 > 연결 리스트 (캐시 친화적)
3. **Working Set 크기 관리**: 필요한 데이터만 메모리에 유지
4. **대용량 페이지 사용**: Huge Pages (2MB, 1GB)

```c
// Huge Pages 사용 예시
void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE,
                 MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB, -1, 0);
```

## 참고 자료

- Operating System Concepts (Silberschatz) - Chapter 9, 10
- [OSTEP - Address Spaces](https://pages.cs.wisc.edu/~remzi/OSTEP/vm-intro.pdf)
- [OSTEP - Paging](https://pages.cs.wisc.edu/~remzi/OSTEP/vm-paging.pdf)
- Linux Kernel Development (Love) - Memory Management 챕터
- [Linux Memory Management Documentation](https://www.kernel.org/doc/html/latest/admin-guide/mm/index.html)

# 대규모 시스템 설계 사례

## 목차
1. [URL Shortener (TinyURL)](#1-url-shortener-tinyurl)
2. [Rate Limiter](#2-rate-limiter)
3. [Twitter Timeline / News Feed](#3-twitter-timeline--news-feed)
4. [Chat System (WhatsApp/Slack)](#4-chat-system-whatsappslack)
5. [Web Crawler](#5-web-crawler)
6. [Notification System](#6-notification-system)
---

## 1. URL Shortener (TinyURL)

### 1.1 문제 정의 및 요구사항

#### 기능적 요구사항
- 긴 URL을 짧은 URL로 변환
- 짧은 URL 접속 시 원본 URL로 리다이렉트
- 사용자 정의 단축 URL 지원 (선택)
- URL 만료 기능 (선택)

#### 비기능적 요구사항
- 고가용성 (99.9% 이상)
- 낮은 지연시간 (< 100ms)
- 단축 URL은 예측 불가능해야 함
- 확장 가능한 설계

### 1.2 용량 산정

```
가정:
- 월간 URL 생성: 100M
- 읽기:쓰기 비율 = 100:1
- 데이터 보관 기간: 5년

트래픽 계산:
- 쓰기 QPS = 100M / (30 * 24 * 3600) ≈ 40 QPS
- 읽기 QPS = 40 * 100 = 4,000 QPS
- 피크 QPS = 4,000 * 3 = 12,000 QPS

스토리지 계산:
- 5년간 총 URL = 100M * 12 * 5 = 6B (60억)
- 레코드당 크기 = 500 bytes (URL + 메타데이터)
- 총 스토리지 = 6B * 500 bytes = 3TB

캐시 계산 (20% 규칙):
- 일일 읽기 요청 = 4,000 * 86,400 = 345.6M
- 캐시 대상 = 345.6M * 20% = 69.12M URL
- 캐시 메모리 = 69.12M * 500 bytes ≈ 35GB
```

### 1.3 고수준 아키텍처

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         URL Shortener 아키텍처                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│    ┌─────────┐       ┌──────────────┐       ┌─────────────────────────┐     │
│    │ Client  │──────→│ Load Balancer│──────→│ Application Servers     │     │
│    └─────────┘       └──────────────┘       │  (Stateless)            │     │
│                                             └───────────┬─────────────┘     │
│                                                         │                   │
│                              ┌───────────────────┬──────┴───────┐          │
│                              ▼                   ▼              ▼          │
│                       ┌───────────┐      ┌───────────┐   ┌──────────────┐  │
│                       │   Cache   │      │  Key Gen  │   │   Database   │  │
│                       │  (Redis)  │      │  Service  │   │ (Cassandra)  │  │
│                       └───────────┘      └───────────┘   └──────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.4 단축 URL 생성 알고리즘

#### 방법 1: Base62 인코딩

```python
# Base62 문자셋: [0-9][a-z][A-Z]
CHARSET = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
BASE = 62

def encode(num: int) -> str:
    """숫자를 Base62 문자열로 변환"""
    if num == 0:
        return CHARSET[0]

    result = []
    while num > 0:
        result.append(CHARSET[num % BASE])
        num //= BASE

    return ''.join(reversed(result))

def decode(short_url: str) -> int:
    """Base62 문자열을 숫자로 변환"""
    num = 0
    for char in short_url:
        num = num * BASE + CHARSET.index(char)
    return num

# 7자리 Base62 = 62^7 ≈ 3.5조 개 URL 가능
# 예: encode(125) = "21" -> tinyurl.com/21
```

#### 방법 2: 해시 기반

```python
import hashlib

def hash_url(long_url: str) -> str:
    """MD5 해시 후 Base62로 변환 (앞 7자리 사용)"""
    hash_bytes = hashlib.md5(long_url.encode()).hexdigest()
    # 해시 충돌 시 처리 필요
    return hash_bytes[:7]

# 장점: 같은 URL은 같은 단축 URL
# 단점: 해시 충돌 처리 필요
```

#### 방법 3: Key Generation Service (KGS)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Key Generation Service                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│    ┌────────────────┐                ┌────────────────┐                     │
│    │  Used Keys DB  │←──Key Used────│    KGS Server   │                     │
│    │                │               │                 │                     │
│    └────────────────┘               │  ┌───────────┐  │                     │
│                                     │  │ Key Pool  │  │←──Request Key       │
│    ┌────────────────┐               │  │ (Memory)  │  │                     │
│    │ Available Keys │──Get Keys────→│  └───────────┘  │────Key──→ App       │
│    │     DB         │               │                 │           Server     │
│    └────────────────┘               └────────────────┘                     │
│                                                                             │
│  특징:                                                                       │
│  - 미리 키를 생성하여 저장                                                    │
│  - 사용된 키는 Used Keys DB로 이동                                           │
│  - 충돌 가능성 제거                                                          │
│  - KGS가 단일 장애점이 될 수 있음 → 복제 필요                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.5 데이터베이스 설계

```sql
-- URL 매핑 테이블
CREATE TABLE url_mapping (
    id              BIGINT PRIMARY KEY,        -- Auto-increment ID
    short_code      VARCHAR(10) UNIQUE,        -- 단축 코드
    long_url        VARCHAR(2048) NOT NULL,    -- 원본 URL
    user_id         BIGINT,                    -- 생성자 (선택)
    created_at      TIMESTAMP DEFAULT NOW(),
    expires_at      TIMESTAMP,                 -- 만료 시간 (선택)
    click_count     BIGINT DEFAULT 0
);

-- 인덱스
CREATE INDEX idx_short_code ON url_mapping(short_code);
CREATE INDEX idx_expires_at ON url_mapping(expires_at);
```

#### 데이터베이스 선택

| 옵션 | 장점 | 단점 |
|-----|-----|-----|
| **Cassandra (추천)** | 수평 확장 용이, 고가용성 | 복잡한 쿼리 제한 |
| DynamoDB | 완전관리형, 자동 확장 | 벤더 종속 |
| PostgreSQL | ACID 보장, 풍부한 기능 | 확장 제한적 |

### 1.6 리다이렉션 흐름

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           리다이렉션 처리 흐름                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Client                 App Server           Cache           Database       │
│    │                        │                  │                │           │
│    │   GET /abc123         │                  │                │           │
│    │──────────────────────→│                  │                │           │
│    │                        │  Get(abc123)    │                │           │
│    │                        │────────────────→│                │           │
│    │                        │                  │                │           │
│    │                        │   Cache Hit?    │                │           │
│    │                        │←───────────────│                │           │
│    │                        │                  │                │           │
│    │                        │ [Cache Miss]     │  Query        │           │
│    │                        │────────────────────────────────→│           │
│    │                        │                  │                │           │
│    │                        │ [Store in Cache] │←───────────────│           │
│    │                        │────────────────→│                │           │
│    │                        │                  │                │           │
│    │   301/302 Redirect    │                  │                │           │
│    │←──────────────────────│                  │                │           │
│    │                        │                  │                │           │
│                                                                             │
│  301 (Moved Permanently): 브라우저가 캐싱 → 트래픽 감소                       │
│  302 (Found): 캐싱 안 함 → 분석/추적에 유리                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.7 트레이드오프 분석

| 결정 사항 | 선택 | 이유 |
|----------|------|------|
| 단축 알고리즘 | Base62 + Counter | 충돌 없음, 예측 가능성 낮음 |
| 데이터베이스 | Cassandra | 높은 쓰기 처리량, 수평 확장 |
| 캐시 전략 | Cache-Aside | 읽기 중심 워크로드에 적합 |
| 리다이렉트 코드 | 301 | 트래픽 감소, CDN 캐싱 가능 |

---

## 2. Rate Limiter

### 2.1 문제 정의 및 요구사항

#### 기능적 요구사항
- API 요청 속도 제한
- 다양한 제한 규칙 지원 (IP 기반, 사용자 기반, API 기반)
- 제한 초과 시 명확한 에러 응답

#### 비기능적 요구사항
- 분산 환경에서 동작
- 낮은 레이턴시 (Rate Limiter 자체가 병목이 되면 안 됨)
- 높은 정확성
- 장애 허용

### 2.2 Rate Limiting 알고리즘

#### 1. Token Bucket

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Token Bucket 알고리즘                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌──────────────────────────────┐                                          │
│   │     Token Bucket             │                                          │
│   │  ┌────────────────────────┐  │                                          │
│   │  │ ●  ●  ●  ●  ●  ●  ●    │  │ ← Bucket Capacity (최대 토큰 수)         │
│   │  │ ●  ●  ●  ○  ○  ○  ○    │  │   현재 7개의 토큰                        │
│   │  └────────────────────────┘  │                                          │
│   │       ↑              ↓       │                                          │
│   │   Refill           Consume   │                                          │
│   │  (정해진 속도)    (요청당 1개) │                                          │
│   └──────────────────────────────┘                                          │
│                                                                             │
│   동작 방식:                                                                 │
│   1. 정해진 속도로 토큰이 버킷에 추가됨                                        │
│   2. 요청이 들어오면 토큰을 1개 소비                                          │
│   3. 토큰이 없으면 요청 거부                                                  │
│   4. 버킷이 가득 차면 새 토큰은 버려짐                                         │
│                                                                             │
│   장점: 버스트 트래픽 허용, 구현 단순, 메모리 효율적                            │
│   단점: 파라미터 튜닝 필요                                                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

```python
import time
from threading import Lock

class TokenBucket:
    def __init__(self, capacity: int, refill_rate: float):
        """
        capacity: 버킷의 최대 토큰 수
        refill_rate: 초당 추가되는 토큰 수
        """
        self.capacity = capacity
        self.refill_rate = refill_rate
        self.tokens = capacity
        self.last_refill_time = time.time()
        self.lock = Lock()

    def allow_request(self) -> bool:
        with self.lock:
            self._refill()
            if self.tokens >= 1:
                self.tokens -= 1
                return True
            return False

    def _refill(self):
        now = time.time()
        elapsed = now - self.last_refill_time
        tokens_to_add = elapsed * self.refill_rate
        self.tokens = min(self.capacity, self.tokens + tokens_to_add)
        self.last_refill_time = now
```

#### 2. Leaky Bucket

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Leaky Bucket 알고리즘                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│      요청 유입 (가변적)                                                       │
│          ↓ ↓ ↓                                                              │
│   ┌──────────────────┐                                                      │
│   │  ●  ●  ●  ●  ●   │ ← Queue (FIFO)                                       │
│   │  ●  ●  ●         │   버킷이 가득 차면 새 요청 거부                        │
│   └───────┬──────────┘                                                      │
│           │                                                                 │
│           ▼ (일정 속도로 유출)                                                │
│      ┌─────────┐                                                            │
│      │ Process │ ← 고정된 속도로 요청 처리                                    │
│      └─────────┘                                                            │
│                                                                             │
│   특징:                                                                      │
│   - 출력 속도가 일정함 (버스트 없음)                                          │
│   - 큐로 구현 (요청이 대기)                                                   │
│   - Token Bucket과 달리 요청이 즉시 거부되지 않고 대기 가능                     │
│                                                                             │
│   장점: 안정적인 출력 속도, 버스트 방지                                        │
│   단점: 오래된 요청이 새 요청을 막을 수 있음, 파라미터 튜닝 필요                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 3. Fixed Window Counter

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Fixed Window Counter 알고리즘                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Time: 0:00        0:30        1:00        1:30        2:00                │
│          │           │           │           │           │                  │
│          ▼           ▼           ▼           ▼           ▼                  │
│   ┌──────────────┐ ┌──────────────┐ ┌──────────────┐                        │
│   │  Window 1    │ │  Window 2    │ │  Window 3    │                        │
│   │  Count: 45   │ │  Count: 38   │ │  Count: 12   │                        │
│   │  Limit: 50   │ │  Limit: 50   │ │  Limit: 50   │                        │
│   └──────────────┘ └──────────────┘ └──────────────┘                        │
│                                                                             │
│   동작 방식:                                                                 │
│   1. 고정된 시간 윈도우 (예: 1분) 마다 카운터 초기화                            │
│   2. 요청마다 카운터 증가                                                     │
│   3. 카운터가 임계값 초과 시 요청 거부                                         │
│                                                                             │
│   ⚠️ 경계 문제 (Boundary Problem):                                           │
│   │←──── Window 1 ────→│←──── Window 2 ────→│                               │
│   │         45 reqs   50│50 reqs   45       │                               │
│   │                  ↑ ↑│↑ ↑                │                               │
│   │              경계 부근에 100개 요청 집중 가능!                             │
│                                                                             │
│   장점: 구현 간단, 메모리 효율적                                               │
│   단점: 윈도우 경계에서 버스트 발생 가능                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 4. Sliding Window Log

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Sliding Window Log 알고리즘                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   요청 로그 저장 (타임스탬프 기반):                                            │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────┐           │
│   │ [1:00:15, 1:00:23, 1:00:45, 1:01:02, 1:01:15, 1:01:30] │           │
│   └─────────────────────────────────────────────────────────────┘           │
│           ↑                                               ↑                  │
│       윈도우 시작                                      현재 시간              │
│       (현재 - 1분)                                                          │
│                                                                             │
│   동작 방식:                                                                 │
│   1. 요청의 타임스탬프를 로그에 저장                                           │
│   2. 윈도우 밖의 오래된 로그 제거                                              │
│   3. 윈도우 내 로그 수가 임계값 초과 시 거부                                    │
│                                                                             │
│   장점: 정확한 속도 제한, 경계 문제 없음                                        │
│   단점: 메모리 사용량 높음 (모든 요청 타임스탬프 저장)                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 5. Sliding Window Counter (권장)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Sliding Window Counter 알고리즘                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Fixed Window + Sliding Window 하이브리드                                   │
│                                                                             │
│   현재 시간: 1:15 (윈도우 크기: 1분)                                          │
│                                                                             │
│   │←─── 이전 윈도우 ───→│←─── 현재 윈도우 ───→│                              │
│   │     (0:00-1:00)     │     (1:00-2:00)     │                              │
│   │     Count: 42       │     Count: 18       │                              │
│                         ↑                                                    │
│                     현재 위치 (1:15)                                         │
│                                                                             │
│   계산:                                                                      │
│   - 이전 윈도우 가중치 = (60 - 15) / 60 = 0.75 (75%)                         │
│   - 현재 윈도우 가중치 = 15 / 60 = 0.25 (25%)                                │
│   - 요청 수 = 42 * 0.75 + 18 * 1.0 = 31.5 + 18 = 49.5                       │
│                                                                             │
│   장점: 메모리 효율적, 부드러운 속도 제한, 경계 문제 완화                        │
│   단점: 근사치 (완전히 정확하지 않음)                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

```python
import time
import redis

class SlidingWindowCounter:
    def __init__(self, redis_client, limit: int, window_size: int = 60):
        self.redis = redis_client
        self.limit = limit
        self.window_size = window_size

    def allow_request(self, key: str) -> bool:
        now = time.time()
        current_window = int(now // self.window_size)
        previous_window = current_window - 1

        # 현재 윈도우 내 위치 비율
        window_position = (now % self.window_size) / self.window_size

        # 이전 윈도우 카운트
        prev_count = int(self.redis.get(f"{key}:{previous_window}") or 0)
        # 현재 윈도우 카운트
        curr_count = int(self.redis.get(f"{key}:{current_window}") or 0)

        # 가중 평균 계산
        weighted_count = prev_count * (1 - window_position) + curr_count

        if weighted_count < self.limit:
            # 현재 윈도우 카운터 증가
            pipe = self.redis.pipeline()
            pipe.incr(f"{key}:{current_window}")
            pipe.expire(f"{key}:{current_window}", self.window_size * 2)
            pipe.execute()
            return True

        return False
```

### 2.3 분산 Rate Limiter 아키텍처

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      분산 Rate Limiter 아키텍처                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────┐       ┌──────────────┐       ┌─────────────────────┐         │
│   │ Client  │──────→│ API Gateway  │──────→│ Rate Limiter        │         │
│   └─────────┘       │ / LB         │       │ Middleware          │         │
│                     └──────────────┘       └──────────┬──────────┘         │
│                                                       │                     │
│                                                       ▼                     │
│                                            ┌────────────────────┐          │
│                                            │   Redis Cluster    │          │
│                                            │ ┌────┐ ┌────┐ ┌────┐│         │
│                                            │ │Node│ │Node│ │Node││         │
│                                            │ │ 1  │ │ 2  │ │ 3  ││         │
│                                            │ └────┘ └────┘ └────┘│         │
│                                            └────────────────────┘          │
│                                                                             │
│   Rate Limit 규칙 예시:                                                      │
│   ┌────────────────────────────────────────────────────────────────┐       │
│   │ {                                                              │       │
│   │   "rules": [                                                   │       │
│   │     { "key": "user_id", "limit": 100, "window": 60 },         │       │
│   │     { "key": "ip", "limit": 1000, "window": 60 },             │       │
│   │     { "key": "api_key", "limit": 10000, "window": 3600 }      │       │
│   │   ]                                                            │       │
│   │ }                                                              │       │
│   └────────────────────────────────────────────────────────────────┘       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.4 응답 헤더 설계

```
HTTP/1.1 429 Too Many Requests
Content-Type: application/json
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1609459200
Retry-After: 30

{
    "error": "Rate limit exceeded",
    "message": "You have exceeded your API rate limit. Please try again in 30 seconds."
}
```

### 2.5 트레이드오프 분석

| 알고리즘 | 메모리 | 정확도 | 버스트 허용 | 구현 복잡도 |
|---------|-------|-------|-----------|-----------|
| Token Bucket | 낮음 | 높음 | 예 | 중간 |
| Leaky Bucket | 중간 | 높음 | 아니오 | 중간 |
| Fixed Window | 낮음 | 낮음 | 예 (경계) | 낮음 |
| Sliding Window Log | 높음 | 매우 높음 | 아니오 | 높음 |
| **Sliding Window Counter** | **낮음** | **높음** | **부분적** | **중간** |

---

## 3. Twitter Timeline / News Feed

### 3.1 문제 정의 및 요구사항

#### 기능적 요구사항
- 사용자가 새 게시물(트윗) 작성
- 사용자의 홈 타임라인 조회 (팔로우하는 사용자들의 게시물)
- 특정 사용자의 타임라인 조회

#### 비기능적 요구사항
- 빠른 피드 로딩 (< 300ms)
- 높은 가용성
- 최종 일관성 허용 (5초 내)
- 수억 명의 사용자 지원

### 3.2 용량 산정

```
가정:
- DAU: 300M (3억)
- 평균 팔로워: 200명
- 평균 팔로잉: 200명
- 일일 트윗 수: 사용자당 0.5개 (총 150M/일)
- 일일 타임라인 조회: 사용자당 10회

트래픽 계산:
- 트윗 쓰기 QPS = 150M / 86400 ≈ 1,700 QPS
- 타임라인 읽기 QPS = 300M * 10 / 86400 ≈ 35,000 QPS
- 읽기:쓰기 비율 ≈ 20:1

Fan-out 계산:
- 평균 팔로워가 200명이면
- 1개 트윗 → 200개 타임라인에 복사
- 1,700 QPS * 200 = 340,000 Fan-out 연산/초
```

### 3.3 고수준 아키텍처

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Twitter Timeline 아키텍처                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                              ┌──────────────────┐                           │
│                              │   Load Balancer  │                           │
│                              └────────┬─────────┘                           │
│                                       │                                     │
│                    ┌──────────────────┼──────────────────┐                  │
│                    ▼                  ▼                  ▼                  │
│             ┌────────────┐    ┌────────────┐    ┌────────────┐              │
│             │ Tweet API  │    │ Timeline   │    │ User API   │              │
│             │ Service    │    │ Service    │    │ Service    │              │
│             └──────┬─────┘    └──────┬─────┘    └──────┬─────┘              │
│                    │                 │                 │                    │
│                    ▼                 ▼                 ▼                    │
│             ┌────────────┐    ┌────────────┐    ┌────────────┐              │
│             │ Tweet DB   │    │ Timeline   │    │ User DB    │              │
│             │ (Cassandra)│    │ Cache      │    │ (MySQL)    │              │
│             └────────────┘    │ (Redis)    │    └────────────┘              │
│                    │          └────────────┘                                │
│                    ▼                                                        │
│             ┌────────────────────────────────┐                              │
│             │       Fan-out Service          │                              │
│             │  (Message Queue + Workers)     │                              │
│             └────────────────────────────────┘                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.4 Fan-out 전략

#### Fan-out on Write (Push 모델)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Fan-out on Write (Push)                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   사용자 A가 트윗 작성                                                        │
│        │                                                                    │
│        ▼                                                                    │
│   ┌────────────────┐                                                        │
│   │ Tweet Service  │──Store──→ Tweet DB                                     │
│   └───────┬────────┘                                                        │
│           │                                                                 │
│           ▼                                                                 │
│   ┌────────────────┐                                                        │
│   │ Fan-out Queue  │ ← 비동기 처리                                           │
│   └───────┬────────┘                                                        │
│           │                                                                 │
│           ▼                                                                 │
│   ┌────────────────┐         ┌─────────────────────────────────┐            │
│   │ Fan-out Worker │──Get───→│ Social Graph (팔로워 목록)       │            │
│   └───────┬────────┘         └─────────────────────────────────┘            │
│           │                                                                 │
│           │ A의 팔로워들: [User B, User C, User D, ...]                      │
│           │                                                                 │
│           ▼                                                                 │
│   ┌────────────────────────────────────────────────────────────┐            │
│   │ Redis Timeline Cache                                        │            │
│   │ ┌──────────────┐ ┌──────────────┐ ┌──────────────┐         │            │
│   │ │ B's Timeline │ │ C's Timeline │ │ D's Timeline │  ...    │            │
│   │ │ + TweetID_A  │ │ + TweetID_A  │ │ + TweetID_A  │         │            │
│   │ └──────────────┘ └──────────────┘ └──────────────┘         │            │
│   └────────────────────────────────────────────────────────────┘            │
│                                                                             │
│   장점: 읽기 시 매우 빠름 (pre-computed)                                      │
│   단점: 유명인 트윗 시 팬아웃 비용 막대 (수백만 팔로워)                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Fan-out on Read (Pull 모델)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Fan-out on Read (Pull)                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   사용자 B가 타임라인 요청                                                    │
│        │                                                                    │
│        ▼                                                                    │
│   ┌────────────────┐                                                        │
│   │Timeline Service│                                                        │
│   └───────┬────────┘                                                        │
│           │                                                                 │
│           ▼                                                                 │
│   ┌────────────────────────────────────────────────────────────┐            │
│   │ Social Graph: B가 팔로우하는 사용자들                        │            │
│   │ → [User A, User X, User Y, ...]                            │            │
│   └────────────────────────────────────────────────────────────┘            │
│           │                                                                 │
│           ▼                                                                 │
│   ┌────────────────────────────────────────────────────────────┐            │
│   │ Tweet DB에서 각 사용자의 최근 트윗 조회                       │            │
│   │ → A's tweets + X's tweets + Y's tweets                     │            │
│   └────────────────────────────────────────────────────────────┘            │
│           │                                                                 │
│           ▼                                                                 │
│   ┌────────────────────────────────────────────────────────────┐            │
│   │ Merge & Sort by timestamp                                   │            │
│   └────────────────────────────────────────────────────────────┘            │
│           │                                                                 │
│           ▼                                                                 │
│      Timeline 반환                                                          │
│                                                                             │
│   장점: 쓰기 시 빠름, 저장 공간 절약                                          │
│   단점: 읽기 시 느림 (여러 소스 집계), 팔로잉 많으면 느려짐                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 하이브리드 접근법 (Twitter 실제 사용)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Hybrid Fan-out (Twitter 방식)                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   사용자 분류:                                                               │
│   ┌─────────────────────────────────────────────────────────────┐           │
│   │ 일반 사용자 (팔로워 < 10,000)     → Fan-out on Write        │           │
│   │ 유명인 (팔로워 >= 10,000)         → Fan-out on Read         │           │
│   └─────────────────────────────────────────────────────────────┘           │
│                                                                             │
│   타임라인 조회 시:                                                          │
│                                                                             │
│   ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐        │
│   │ Pre-computed    │    │ 유명인 트윗     │    │ 최종            │        │
│   │ Timeline        │ +  │ 실시간 조회     │ =  │ Timeline        │        │
│   │ (from Cache)    │    │ (Fan-out Read)  │    │ (Merged)        │        │
│   └─────────────────┘    └─────────────────┘    └─────────────────┘        │
│                                                                             │
│   예시:                                                                      │
│   - 일반인 친구 A의 트윗: 이미 캐시에 있음                                     │
│   - 셀럽 B의 트윗: 타임라인 조회 시 실시간 가져옴                              │
│   - 두 소스 병합 후 시간순 정렬                                               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.5 데이터 저장소 설계

```
Tweet 저장 (Cassandra):
┌─────────────────────────────────────────────────────────────────┐
│ CREATE TABLE tweets (                                           │
│     tweet_id    BIGINT PRIMARY KEY,                             │
│     user_id     BIGINT,                                         │
│     content     TEXT,                                           │
│     media_urls  LIST<TEXT>,                                     │
│     created_at  TIMESTAMP,                                      │
│     like_count  COUNTER,                                        │
│     retweet_count COUNTER                                       │
│ );                                                              │
└─────────────────────────────────────────────────────────────────┘

Timeline Cache (Redis):
┌─────────────────────────────────────────────────────────────────┐
│ Key: timeline:{user_id}                                         │
│ Value: Sorted Set (score = timestamp)                           │
│                                                                 │
│ ZADD timeline:user123 1609459200 "tweet:456"                    │
│ ZADD timeline:user123 1609459300 "tweet:789"                    │
│                                                                 │
│ # 최근 타임라인 조회 (최대 800개 유지)                            │
│ ZREVRANGE timeline:user123 0 19  # 최근 20개                    │
└─────────────────────────────────────────────────────────────────┘

Social Graph (별도 서비스):
┌─────────────────────────────────────────────────────────────────┐
│ followers:{user_id} → SET of follower user IDs                  │
│ following:{user_id} → SET of following user IDs                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.6 트레이드오프 분석

| 모델 | 쓰기 비용 | 읽기 비용 | 적합한 경우 |
|-----|---------|---------|-----------|
| Push (Fan-out on Write) | 높음 | 낮음 | 팔로워 적은 사용자 |
| Pull (Fan-out on Read) | 낮음 | 높음 | 팔로워 많은 유명인 |
| **Hybrid** | **중간** | **중간** | **대규모 서비스** |

---

## 4. Chat System (WhatsApp/Slack)

### 4.1 문제 정의 및 요구사항

#### 기능적 요구사항
- 1:1 채팅
- 그룹 채팅 (최대 500명)
- 온라인 상태 표시
- 메시지 읽음 확인
- 이미지/파일 전송

#### 비기능적 요구사항
- 실시간 메시지 전달 (< 100ms)
- 메시지 순서 보장
- 메시지 영속성 (안 잃어버림)
- 고가용성
- 오프라인 사용자 메시지 지원

### 4.2 고수준 아키텍처

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          Chat System 아키텍처                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────┐                                              ┌─────────┐       │
│  │ Client  │◄──────────────WebSocket───────────────────►│ Client  │       │
│  │  (A)    │                    │                        │  (B)    │       │
│  └─────────┘                    │                        └─────────┘       │
│                                 ▼                                          │
│                    ┌────────────────────────┐                              │
│                    │    Load Balancer       │                              │
│                    │  (L4 - Connection LB)  │                              │
│                    └───────────┬────────────┘                              │
│                                │                                           │
│          ┌─────────────────────┼─────────────────────┐                     │
│          ▼                     ▼                     ▼                     │
│   ┌──────────────┐     ┌──────────────┐      ┌──────────────┐              │
│   │  WebSocket   │     │  WebSocket   │      │  WebSocket   │              │
│   │  Server 1    │     │  Server 2    │      │  Server N    │              │
│   └──────┬───────┘     └──────┬───────┘      └──────┬───────┘              │
│          │                    │                     │                      │
│          └────────────────────┼─────────────────────┘                      │
│                               ▼                                            │
│                    ┌────────────────────────┐                              │
│                    │   WebSocket Manager    │                              │
│                    │   (Redis Pub/Sub)      │                              │
│                    └───────────┬────────────┘                              │
│                                │                                           │
│          ┌─────────────────────┼─────────────────────┐                     │
│          ▼                     ▼                     ▼                     │
│   ┌──────────────┐     ┌──────────────┐      ┌──────────────┐              │
│   │   Message    │     │   Presence   │      │    User      │              │
│   │   Service    │     │   Service    │      │   Service    │              │
│   └──────────────┘     └──────────────┘      └──────────────┘              │
│          │                    │                     │                      │
│          ▼                    ▼                     ▼                      │
│   ┌──────────────┐     ┌──────────────┐      ┌──────────────┐              │
│   │  Message DB  │     │ Redis Cache  │      │  User DB     │              │
│   │ (Cassandra)  │     │              │      │  (MySQL)     │              │
│   └──────────────┘     └──────────────┘      └──────────────┘              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.3 메시지 전송 흐름

#### 1:1 채팅

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          1:1 메시지 전송 흐름                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   User A                WS Server        Message Service      User B        │
│     │                      │                   │                │           │
│     │──Send Message───────→│                   │                │           │
│     │ {to: B, msg: "Hi"}  │                   │                │           │
│     │                      │                   │                │           │
│     │                      │──Save Message────→│                │           │
│     │                      │                   │                │           │
│     │                      │◄──Message ID──────│                │           │
│     │                      │                   │                │           │
│     │◄──ACK (msg saved)───│                   │                │           │
│     │                      │                   │                │           │
│     │                      │──Lookup B's       │                │           │
│     │                      │  WS Server────────│                │           │
│     │                      │                   │                │           │
│     │                      │   [B Online?]     │                │           │
│     │                      │        │          │                │           │
│     │                      │   ┌────┴────┐     │                │           │
│     │                      │   ▼         ▼     │                │           │
│     │                      │ Online    Offline │                │           │
│     │                      │   │         │     │                │           │
│     │                      │   │    Queue for  │                │           │
│     │                      │   │    later      │                │           │
│     │                      │   │         │     │                │           │
│     │                      │   ▼         ▼     │                │           │
│     │                      │──Push via WS─────────────────────→│           │
│     │                      │                   │                │           │
│     │                      │◄─────────────────────Delivered ACK│           │
│     │                      │                   │                │           │
│     │◄──Delivered Status──│                   │                │           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 그룹 채팅

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          그룹 메시지 전송 흐름                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   User A           Group Service          Message Queue         Members     │
│     │                   │                      │                   │        │
│     │──Send to Group───→│                      │                   │        │
│     │ {group: G1}       │                      │                   │        │
│     │                   │                      │                   │        │
│     │                   │──Get Group Members──→│                   │        │
│     │                   │ [B, C, D, E, ...]    │                   │        │
│     │                   │                      │                   │        │
│     │                   │──Publish to Queue───→│                   │        │
│     │                   │                      │                   │        │
│     │◄──ACK────────────│                      │                   │        │
│     │                   │                      │                   │        │
│     │                   │                      │──Fan-out──────→[B]│        │
│     │                   │                      │──Fan-out──────→[C]│        │
│     │                   │                      │──Fan-out──────→[D]│        │
│     │                   │                      │──Fan-out──────→[E]│        │
│     │                   │                      │      ...          │        │
│                                                                             │
│   소규모 그룹 (< 100명): 직접 Fan-out                                        │
│   대규모 그룹 (>= 100명): Message Queue 사용하여 비동기 처리                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.4 WebSocket 연결 관리

```python
# WebSocket Manager (Redis 기반)
class WebSocketManager:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.local_connections = {}  # user_id -> websocket

    def register_connection(self, user_id: str, ws_server_id: str):
        """사용자의 WebSocket 연결 정보 등록"""
        self.redis.hset("ws:connections", user_id, ws_server_id)
        self.redis.sadd(f"ws:server:{ws_server_id}", user_id)

    def get_user_server(self, user_id: str) -> Optional[str]:
        """사용자가 연결된 서버 조회"""
        return self.redis.hget("ws:connections", user_id)

    def remove_connection(self, user_id: str, ws_server_id: str):
        """연결 해제"""
        self.redis.hdel("ws:connections", user_id)
        self.redis.srem(f"ws:server:{ws_server_id}", user_id)

# 메시지 라우팅
class MessageRouter:
    def __init__(self, ws_manager, pubsub):
        self.ws_manager = ws_manager
        self.pubsub = pubsub

    async def route_message(self, recipient_id: str, message: dict):
        target_server = self.ws_manager.get_user_server(recipient_id)

        if target_server:
            # 온라인: Redis Pub/Sub으로 해당 서버에 전달
            self.pubsub.publish(f"server:{target_server}", {
                "type": "message",
                "recipient": recipient_id,
                "data": message
            })
        else:
            # 오프라인: 메시지 큐에 저장
            self.save_to_offline_queue(recipient_id, message)
```

### 4.5 메시지 저장 스키마

```sql
-- Messages 테이블 (Cassandra)
CREATE TABLE messages (
    conversation_id  TEXT,
    message_id       TIMEUUID,
    sender_id        TEXT,
    content          TEXT,
    content_type     TEXT,  -- 'text', 'image', 'file'
    media_url        TEXT,
    created_at       TIMESTAMP,
    PRIMARY KEY (conversation_id, message_id)
) WITH CLUSTERING ORDER BY (message_id DESC);

-- 대화 목록 (최근 메시지 포함)
CREATE TABLE user_conversations (
    user_id          TEXT,
    conversation_id  TEXT,
    last_message_at  TIMESTAMP,
    last_message     TEXT,
    unread_count     INT,
    PRIMARY KEY (user_id, last_message_at)
) WITH CLUSTERING ORDER BY (last_message_at DESC);

-- 그룹 멤버
CREATE TABLE group_members (
    group_id    TEXT,
    user_id     TEXT,
    role        TEXT,  -- 'admin', 'member'
    joined_at   TIMESTAMP,
    PRIMARY KEY (group_id, user_id)
);
```

### 4.6 온라인 상태 (Presence) 관리

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Presence System                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Heartbeat 방식:                                                            │
│   ┌─────────┐          ┌─────────────┐          ┌─────────────┐             │
│   │ Client  │──Heart──→│  Presence   │──Update─→│   Redis     │             │
│   │         │  beat    │  Service    │          │  (TTL 30s)  │             │
│   └─────────┘ (5초마다) └─────────────┘          └─────────────┘             │
│                                                                             │
│   Redis 저장 구조:                                                           │
│   ┌──────────────────────────────────────────────────────────┐              │
│   │ SET presence:{user_id} "online" EX 30                    │              │
│   │                                                          │              │
│   │ # TTL 30초: 30초간 heartbeat 없으면 자동 offline         │              │
│   └──────────────────────────────────────────────────────────┘              │
│                                                                             │
│   상태 변경 알림:                                                             │
│   - 친구 목록의 사용자들에게만 알림                                            │
│   - Fan-out 방식 또는 Pub/Sub 사용                                           │
│   - 대규모 서비스: 상태 변경 이벤트 배치 처리                                   │
│                                                                             │
│   최적화:                                                                    │
│   - 팔로워가 많은 유명인: 상태 조회 시 실시간 확인 (Pull)                       │
│   - 일반 사용자: 상태 변경 시 알림 (Push)                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.7 트레이드오프 분석

| 결정 사항 | 선택 | 이유 |
|----------|------|------|
| 통신 프로토콜 | WebSocket | 양방향 실시간 통신, 낮은 레이턴시 |
| 메시지 저장소 | Cassandra | 높은 쓰기 처리량, 시계열 데이터에 적합 |
| 연결 관리 | Redis Pub/Sub | 서버 간 메시지 라우팅 |
| 오프라인 큐 | Kafka | 내구성, 순서 보장 |

---

## 5. Web Crawler

### 5.1 문제 정의 및 요구사항

#### 기능적 요구사항
- URL에서 웹 페이지 다운로드
- 페이지에서 새 URL 추출
- robots.txt 준수
- 중복 URL 필터링

#### 비기능적 요구사항
- 확장성 (수십억 페이지 크롤링)
- 정중함 (Politeness) - 서버 과부하 방지
- 견고성 (Robustness) - 장애 복구
- 확장 가능한 아키텍처

### 5.2 용량 산정

```
가정:
- 월간 크롤링 대상: 10억 페이지
- 평균 페이지 크기: 500KB (HTML + 리소스)
- 메타데이터: 500 bytes/페이지

크롤링 속도:
- 10억 / 30일 / 24시간 / 3600초 ≈ 400 페이지/초

스토리지:
- HTML 저장: 10억 × 500KB = 500TB/월
- 메타데이터: 10억 × 500B = 500GB/월

대역폭:
- 다운로드: 400 × 500KB = 200MB/s ≈ 1.6Gbps
```

### 5.3 고수준 아키텍처

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          Web Crawler 아키텍처                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────┐                                                           │
│   │ Seed URLs   │ ← 초기 URL 목록                                            │
│   └──────┬──────┘                                                           │
│          │                                                                  │
│          ▼                                                                  │
│   ┌─────────────────────────────────────────────────────────────────┐      │
│   │                      URL Frontier                                │      │
│   │  ┌─────────────────────────────────────────────────────────┐    │      │
│   │  │ Priority Queue   │   Host Queue   │   Politeness Queue  │    │      │
│   │  │ (중요도 기반)      │  (호스트별 분리) │   (속도 제한)        │    │      │
│   │  └─────────────────────────────────────────────────────────┘    │      │
│   └──────────────────────────────┬──────────────────────────────────┘      │
│                                  │                                          │
│                                  ▼                                          │
│   ┌─────────────────────────────────────────────────────────────────┐      │
│   │                      Fetcher Workers                             │      │
│   │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐            │      │
│   │  │Fetcher 1│  │Fetcher 2│  │Fetcher 3│  │Fetcher N│            │      │
│   │  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘            │      │
│   └───────┼────────────┼────────────┼────────────┼──────────────────┘      │
│           │            │            │            │                          │
│           └────────────┴─────┬──────┴────────────┘                          │
│                              │                                              │
│                              ▼                                              │
│   ┌─────────────────────────────────────────────────────────────────┐      │
│   │                      Content Parser                              │      │
│   │  • HTML 파싱                                                     │      │
│   │  • URL 추출                                                      │      │
│   │  • 컨텐츠 추출                                                   │      │
│   └──────────────────────────┬──────────────────────────────────────┘      │
│                              │                                              │
│          ┌───────────────────┼───────────────────┐                          │
│          ▼                   ▼                   ▼                          │
│   ┌──────────────┐   ┌──────────────┐   ┌──────────────┐                   │
│   │ URL Filter   │   │  Content     │   │ URL Dedup    │                   │
│   │ (robots.txt) │   │  Store       │   │ (Bloom Filter│                   │
│   └──────────────┘   │ (S3/HDFS)    │   │  + DB)       │                   │
│          │           └──────────────┘   └───────┬──────┘                   │
│          │                                      │                          │
│          └──────────────────┬───────────────────┘                          │
│                             │                                               │
│                             ▼                                               │
│                      URL Frontier로 피드백                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.4 핵심 컴포넌트

#### URL Frontier

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          URL Frontier 상세 설계                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   목표: 크롤링할 URL의 우선순위 및 정중함(Politeness) 관리                    │
│                                                                             │
│                              입력 URL                                        │
│                                 │                                           │
│                                 ▼                                           │
│   ┌─────────────────────────────────────────────────────────────────┐      │
│   │                     Prioritizer                                  │      │
│   │   • PageRank 기반                                                │      │
│   │   • 웹사이트 중요도                                              │      │
│   │   • 업데이트 빈도                                                │      │
│   └───────────────────────────┬─────────────────────────────────────┘      │
│                               │                                             │
│                               ▼                                             │
│   ┌─────────────────────────────────────────────────────────────────┐      │
│   │   Priority Queues                                                │      │
│   │   ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐           │      │
│   │   │ High    │  │ Medium  │  │ Low     │  │ Lowest  │           │      │
│   │   │Priority │  │Priority │  │Priority │  │Priority │           │      │
│   │   └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘           │      │
│   └────────┼────────────┼────────────┼────────────┼─────────────────┘      │
│            └────────────┴─────┬──────┴────────────┘                         │
│                               │                                             │
│                               ▼                                             │
│   ┌─────────────────────────────────────────────────────────────────┐      │
│   │   Host Queues (Politeness 보장)                                  │      │
│   │   ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │      │
│   │   │ amazon.com   │  │ google.com   │  │ github.com   │   ...    │      │
│   │   │ Queue        │  │ Queue        │  │ Queue        │          │      │
│   │   │ last_fetch:  │  │ last_fetch:  │  │ last_fetch:  │          │      │
│   │   │ 2s ago       │  │ 5s ago       │  │ 1s ago       │          │      │
│   │   └──────────────┘  └──────────────┘  └──────────────┘          │      │
│   │                                                                  │      │
│   │   규칙: 같은 호스트에 1초 이상 간격 유지                          │      │
│   └─────────────────────────────────────────────────────────────────┘      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### URL 중복 제거

```python
from pybloom_live import BloomFilter

class URLDeduplicator:
    def __init__(self, capacity=10_000_000_000, error_rate=0.01):
        """
        Bloom Filter + DB 하이브리드 방식
        - Bloom Filter: 빠른 1차 필터링 (메모리)
        - DB: 정확한 2차 확인 (디스크)
        """
        self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate)
        self.db = URLDatabase()  # Redis 또는 RocksDB

    def is_duplicate(self, url: str) -> bool:
        url_hash = self._normalize_and_hash(url)

        # 1차: Bloom Filter (빠름)
        if url_hash not in self.bloom:
            return False  # 확실히 새로운 URL

        # 2차: DB 확인 (Bloom Filter는 false positive 가능)
        return self.db.exists(url_hash)

    def add_url(self, url: str):
        url_hash = self._normalize_and_hash(url)
        self.bloom.add(url_hash)
        self.db.add(url_hash)

    def _normalize_and_hash(self, url: str) -> str:
        """URL 정규화 후 해시"""
        # 프로토콜 통일, trailing slash 제거, 쿼리 파라미터 정렬 등
        normalized = normalize_url(url)
        return hashlib.md5(normalized.encode()).hexdigest()
```

### 5.5 Politeness (정중함) 정책

```python
class PolitenessEnforcer:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.default_delay = 1.0  # 기본 1초 간격

    def can_fetch(self, host: str) -> bool:
        """해당 호스트를 지금 크롤링해도 되는지 확인"""
        last_fetch_key = f"crawler:last_fetch:{host}"
        last_fetch = self.redis.get(last_fetch_key)

        if last_fetch is None:
            return True

        delay = self._get_delay_for_host(host)
        elapsed = time.time() - float(last_fetch)
        return elapsed >= delay

    def record_fetch(self, host: str):
        """크롤링 완료 기록"""
        self.redis.set(f"crawler:last_fetch:{host}", time.time())

    def _get_delay_for_host(self, host: str) -> float:
        """호스트별 적정 딜레이 계산"""
        # robots.txt의 Crawl-delay 확인
        crawl_delay = self._get_robots_crawl_delay(host)
        if crawl_delay:
            return crawl_delay

        # TTFB 기반 동적 딜레이
        ttfb = self._get_host_ttfb(host)
        if ttfb and ttfb > 1.0:
            return ttfb * 2  # 느린 서버는 더 천천히

        return self.default_delay
```

### 5.6 robots.txt 처리

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          robots.txt 예시                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   User-agent: *                                                             │
│   Disallow: /admin/                                                         │
│   Disallow: /private/                                                       │
│   Crawl-delay: 2                                                            │
│                                                                             │
│   User-agent: Googlebot                                                     │
│   Disallow: /internal/                                                      │
│   Allow: /public/                                                           │
│                                                                             │
│   Sitemap: https://example.com/sitemap.xml                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

크롤러 동작:
1. 새 도메인 방문 전 robots.txt 먼저 다운로드
2. 규칙 파싱 및 캐싱 (TTL: 24시간)
3. 크롤링 전 해당 URL이 허용되는지 확인
4. Crawl-delay 준수
```

### 5.7 분산 크롤러 설계

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       분산 크롤러 파티셔닝                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   도메인 기반 파티셔닝:                                                       │
│   ┌─────────────────────────────────────────────────────────────────┐      │
│   │ Crawler Node 1: amazon.com, apple.com, alibaba.com ...         │      │
│   │ Crawler Node 2: google.com, github.com, gmail.com ...          │      │
│   │ Crawler Node 3: facebook.com, twitter.com, reddit.com ...      │      │
│   │ ...                                                             │      │
│   └─────────────────────────────────────────────────────────────────┘      │
│                                                                             │
│   장점:                                                                      │
│   - 각 노드가 특정 도메인 담당 → Politeness 관리 용이                         │
│   - 같은 도메인의 트래픽이 한 노드에서 발생 → 서버 부하 분산                    │
│                                                                             │
│   파티션 할당:                                                               │
│   ┌────────────────────────────────────────────────────────────────┐       │
│   │ partition_id = hash(domain) % num_crawlers                     │       │
│   │                                                                │       │
│   │ 예: hash("amazon.com") % 100 = 23 → Crawler #23 담당          │       │
│   └────────────────────────────────────────────────────────────────┘       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.8 트레이드오프 분석

| 결정 사항 | 선택 | 이유 |
|----------|------|------|
| URL 저장 | RocksDB + Bloom Filter | 빠른 조회 + 메모리 효율 |
| 콘텐츠 저장 | S3/HDFS | 대용량 저장, 저렴한 비용 |
| URL 분배 | 도메인 기반 해시 | Politeness 관리 용이 |
| 메시지 큐 | Kafka | 내구성, 순서 보장 |

---

## 6. Notification System

### 6.1 문제 정의 및 요구사항

#### 기능적 요구사항
- 다중 채널 지원 (Push, SMS, Email)
- 사용자별 알림 설정
- 알림 스케줄링
- 알림 템플릿

#### 비기능적 요구사항
- 고처리량 (수백만 알림/분)
- 낮은 지연시간 (< 5초)
- 신뢰성 (알림 손실 방지)
- 확장성

### 6.2 고수준 아키텍처

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       Notification System 아키텍처                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────┐                                                           │
│   │  Services   │ ← 주문 서비스, 결제 서비스, 마케팅 서비스 등                  │
│   │  (Triggers) │                                                           │
│   └──────┬──────┘                                                           │
│          │                                                                  │
│          ▼                                                                  │
│   ┌─────────────────────────────────────────────────────────────────┐      │
│   │                 Notification Service (API)                       │      │
│   │   • 요청 검증                                                    │      │
│   │   • 사용자 설정 확인                                             │      │
│   │   • 템플릿 렌더링                                                │      │
│   │   • Rate Limiting                                                │      │
│   └──────────────────────────────┬──────────────────────────────────┘      │
│                                  │                                          │
│                                  ▼                                          │
│   ┌─────────────────────────────────────────────────────────────────┐      │
│   │                    Message Queue (Kafka)                         │      │
│   │   ┌───────────────┬───────────────┬───────────────┐             │      │
│   │   │ Push Topic    │ SMS Topic     │ Email Topic   │             │      │
│   │   └───────────────┴───────────────┴───────────────┘             │      │
│   └──────────┬──────────────────┬──────────────────┬────────────────┘      │
│              │                  │                  │                        │
│              ▼                  ▼                  ▼                        │
│   ┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐           │
│   │  Push Workers    │ │  SMS Workers     │ │  Email Workers   │           │
│   │  ┌────┐ ┌────┐  │ │  ┌────┐ ┌────┐  │ │  ┌────┐ ┌────┐  │           │
│   │  │ W1 │ │ W2 │  │ │  │ W1 │ │ W2 │  │ │  │ W1 │ │ W2 │  │           │
│   │  └────┘ └────┘  │ │  └────┘ └────┘  │ │  └────┘ └────┘  │           │
│   └────────┬─────────┘ └────────┬─────────┘ └────────┬─────────┘           │
│            │                    │                    │                      │
│            ▼                    ▼                    ▼                      │
│   ┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐           │
│   │ APNs / FCM       │ │ Twilio / AWS SNS │ │ SendGrid /       │           │
│   │ (Apple/Google)   │ │                  │ │ Mailchimp        │           │
│   └──────────────────┘ └──────────────────┘ └──────────────────┘           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.3 알림 전송 흐름

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          알림 전송 상세 흐름                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   1. 트리거 이벤트                                                          │
│      │                                                                      │
│      ▼                                                                      │
│   ┌─────────────────────────────────────────────────────────────────┐      │
│   │ POST /notifications                                              │      │
│   │ {                                                                │      │
│   │   "user_id": "user123",                                         │      │
│   │   "template_id": "order_confirmed",                             │      │
│   │   "channels": ["push", "email"],                                │      │
│   │   "data": { "order_id": "ORD456", "amount": 50000 }            │      │
│   │ }                                                                │      │
│   └──────────────────────────────┬──────────────────────────────────┘      │
│                                  │                                          │
│   2. 사용자 설정 확인            │                                          │
│      │                           │                                          │
│      ▼                           │                                          │
│   ┌──────────────────────────────┴──────────────────────────────────┐      │
│   │ User Preference Service                                          │      │
│   │ - Push 알림 허용? ✓                                              │      │
│   │ - Email 허용? ✓                                                  │      │
│   │ - SMS 허용? ✗ (스킵)                                             │      │
│   │ - 방해금지 시간? 22:00-08:00 (해당 시간이면 스케줄링)            │      │
│   └──────────────────────────────┬──────────────────────────────────┘      │
│                                  │                                          │
│   3. 템플릿 렌더링               │                                          │
│      │                           │                                          │
│      ▼                           │                                          │
│   ┌──────────────────────────────┴──────────────────────────────────┐      │
│   │ Template Engine                                                  │      │
│   │ 입력: "주문 {{order_id}}가 확인되었습니다. 금액: {{amount}}원"   │      │
│   │ 출력: "주문 ORD456가 확인되었습니다. 금액: 50,000원"             │      │
│   └──────────────────────────────┬──────────────────────────────────┘      │
│                                  │                                          │
│   4. 메시지 큐 발행              │                                          │
│      │                           │                                          │
│      ▼                           │                                          │
│   ┌──────────────────────────────┴──────────────────────────────────┐      │
│   │ Kafka: notification.push.topic, notification.email.topic        │      │
│   └──────────────────────────────┬──────────────────────────────────┘      │
│                                  │                                          │
│   5. Worker 처리                 │                                          │
│      │                           │                                          │
│      ▼                           │                                          │
│   ┌──────────────────────────────┴──────────────────────────────────┐      │
│   │ - 디바이스 토큰 조회                                              │      │
│   │ - 외부 서비스 호출 (APNs, FCM, SendGrid)                         │      │
│   │ - 결과 로깅 (성공/실패)                                          │      │
│   │ - 실패 시 재시도 (Exponential Backoff)                           │      │
│   └─────────────────────────────────────────────────────────────────┘      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.4 디바이스 토큰 관리

```sql
-- 디바이스 정보 테이블
CREATE TABLE user_devices (
    user_id         VARCHAR(64),
    device_id       VARCHAR(64),
    platform        ENUM('ios', 'android', 'web'),
    push_token      VARCHAR(256),  -- APNs token 또는 FCM token
    app_version     VARCHAR(20),
    last_active_at  TIMESTAMP,
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, device_id),
    INDEX idx_push_token (push_token)
);

-- 알림 설정 테이블
CREATE TABLE notification_preferences (
    user_id             VARCHAR(64) PRIMARY KEY,
    push_enabled        BOOLEAN DEFAULT TRUE,
    email_enabled       BOOLEAN DEFAULT TRUE,
    sms_enabled         BOOLEAN DEFAULT FALSE,
    quiet_hours_start   TIME,           -- 방해금지 시작
    quiet_hours_end     TIME,           -- 방해금지 종료
    frequency_limit     INT DEFAULT 10, -- 시간당 최대 알림 수
    last_updated        TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 6.5 Rate Limiting 및 중복 방지

```python
class NotificationRateLimiter:
    def __init__(self, redis_client):
        self.redis = redis_client

    def can_send(self, user_id: str, channel: str) -> bool:
        """사용자별, 채널별 rate limit 확인"""
        key = f"notification:rate:{user_id}:{channel}"
        current = int(self.redis.get(key) or 0)
        limit = self._get_limit(user_id, channel)

        return current < limit

    def record_send(self, user_id: str, channel: str):
        """발송 기록"""
        key = f"notification:rate:{user_id}:{channel}"
        pipe = self.redis.pipeline()
        pipe.incr(key)
        pipe.expire(key, 3600)  # 1시간 윈도우
        pipe.execute()

    def is_duplicate(self, notification_id: str) -> bool:
        """멱등성 보장 - 중복 알림 방지"""
        key = f"notification:sent:{notification_id}"
        result = self.redis.set(key, "1", ex=86400, nx=True)
        return result is None  # 이미 존재하면 중복
```

### 6.6 트레이드오프 분석

| 결정 사항 | 선택 | 이유 |
|----------|------|------|
| 메시지 큐 | Kafka | 높은 처리량, 내구성, 순서 보장 |
| 채널별 분리 | 별도 Topic/Worker | 독립적 확장, 장애 격리 |
| 재시도 전략 | Exponential Backoff | 외부 서비스 부하 감소 |
| 실패 처리 | Dead Letter Queue | 분석 및 수동 재처리 가능 |

---

## 참고 자료

- [System Design Interview by Alex Xu Vol.1 & Vol.2](https://www.amazon.com/System-Design-Interview-insiders-Second/dp/B08CMF2CQF)
- [ByteByteGo - System Design](https://bytebytego.com/)
- [URL Shortening System Design - System Design One](https://systemdesign.one/url-shortening-system-design/)
- [Rate Limiting Algorithms - GeeksforGeeks](https://www.geeksforgeeks.org/system-design/rate-limiting-algorithms-system-design/)
- [Designing Twitter - High Scalability](https://highscalability.com/the-architecture-twitter-uses-to-deal-with-150m-active-users/)
- [Designing WhatsApp - DesignGurus](https://www.designgurus.io/blog/design-chat-application)
- [Web Crawler Design - AlgoMaster](https://blog.algomaster.io/p/design-a-web-crawler-system-design-interview)
- [Notification Service Design - NotificationAPI](https://www.notificationapi.com/blog/notification-service-design-with-architectural-diagrams)

# 시스템 디자인

## 목차
1. [시스템 디자인 면접 접근법](#1-시스템-디자인-면접-접근법)
2. [요구사항 분석](#2-요구사항-분석)
3. [용량 산정 (Back-of-envelope Estimation)](#3-용량-산정-back-of-envelope-estimation)
4. [트레이드오프 분석](#4-트레이드오프-분석)
5. [확장성, 가용성, 일관성 고려사항](#5-확장성-가용성-일관성-고려사항)
---

## 1. 시스템 디자인 면접 접근법

### 1.1 4단계 프레임워크 (Alex Xu)

시스템 디자인 면접은 정해진 정답이 없는 열린 문제입니다. Alex Xu의 "System Design Interview" 책에서 제시하는 4단계 프레임워크를 따르면 체계적으로 접근할 수 있습니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    시스템 디자인 4단계 프레임워크                    │
├─────────────────────────────────────────────────────────────────┤
│  Step 1: 문제 이해 및 설계 범위 확정 (3-10분)                       │
│  ├── 기능적 요구사항 정의                                          │
│  ├── 비기능적 요구사항 정의                                         │
│  └── 제약조건 및 가정 설정                                          │
├─────────────────────────────────────────────────────────────────┤
│  Step 2: 개략적인 설계안 제시 (10-15분)                            │
│  ├── 고수준 아키텍처 다이어그램                                     │
│  ├── 핵심 컴포넌트 식별                                            │
│  └── 데이터 흐름 설명                                              │
├─────────────────────────────────────────────────────────────────┤
│  Step 3: 상세 설계 (10-25분)                                      │
│  ├── 핵심 컴포넌트 딥다이브                                         │
│  ├── 데이터베이스 스키마                                            │
│  ├── API 설계                                                     │
│  └── 알고리즘/자료구조 선택                                         │
├─────────────────────────────────────────────────────────────────┤
│  Step 4: 마무리 (3-5분)                                           │
│  ├── 병목점 식별 및 해결방안                                        │
│  ├── 운영 고려사항 (모니터링, 로깅)                                  │
│  └── 확장 가능성 논의                                              │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 면접관과의 커뮤니케이션

#### 질문을 통한 요구사항 명확화

```
좋은 질문 예시:

Q: "사용자 수는 어느 정도를 예상하나요?"
Q: "읽기와 쓰기 비율은 어떻게 되나요?"
Q: "데이터 일관성이 중요한가요, 아니면 가용성이 더 중요한가요?"
Q: "지역적 분산이 필요한가요?"
Q: "기존 시스템과의 통합이 필요한가요?"
```

#### 가정 설정 및 공유

```
명시적 가정 예시:

"DAU(일일 활성 사용자)를 1000만으로 가정하겠습니다."
"읽기:쓰기 비율을 100:1로 가정하겠습니다."
"데이터 보관 기간을 5년으로 설정하겠습니다."
"평균 응답 시간 목표를 200ms 이하로 잡겠습니다."
```

### 1.3 시간 관리 전략

| 단계 | 시간 배분 | 핵심 활동 |
|------|----------|----------|
| 요구사항 분석 | 5-10분 | 질문, 범위 설정, 가정 |
| 고수준 설계 | 10-15분 | 아키텍처 다이어그램, 컴포넌트 |
| 상세 설계 | 10-25분 | 딥다이브, API, DB 스키마 |
| 마무리 | 3-5분 | 병목점, 확장성, Q&A |

---

## 2. 요구사항 분석

### 2.1 기능적 요구사항 (Functional Requirements)

기능적 요구사항은 시스템이 **무엇을** 해야 하는지를 정의합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                      기능적 요구사항 체크리스트                      │
├─────────────────────────────────────────────────────────────────┤
│  핵심 기능 (Core Features)                                        │
│  ├── 사용자가 수행할 주요 액션은 무엇인가?                            │
│  ├── 시스템의 입력과 출력은 무엇인가?                                 │
│  └── 어떤 데이터를 저장/조회해야 하는가?                              │
├─────────────────────────────────────────────────────────────────┤
│  사용자 시나리오 (User Scenarios)                                   │
│  ├── 주요 사용자 유형은 누구인가?                                    │
│  ├── 각 사용자의 주요 워크플로우는?                                   │
│  └── 엣지 케이스는 어떤 것들이 있는가?                                │
├─────────────────────────────────────────────────────────────────┤
│  API 정의                                                         │
│  ├── 어떤 API 엔드포인트가 필요한가?                                  │
│  ├── 요청/응답 형식은 어떻게 되는가?                                  │
│  └── 인증/인가 방식은?                                              │
└─────────────────────────────────────────────────────────────────┘
```

#### 예시: URL 단축 서비스

```
기능적 요구사항:
1. 긴 URL을 짧은 URL로 변환
2. 짧은 URL로 접속 시 원본 URL로 리다이렉트
3. 사용자 정의 짧은 URL 지원 (선택)
4. URL 만료 기능 (선택)
5. 클릭 통계 제공 (선택)

API 설계:
POST /api/shorten
  Request: { "long_url": "https://example.com/very/long/url" }
  Response: { "short_url": "https://tiny.url/abc123" }

GET /{short_code}
  Response: 301 Redirect to original URL
```

### 2.2 비기능적 요구사항 (Non-Functional Requirements)

비기능적 요구사항은 시스템이 **어떻게** 동작해야 하는지를 정의합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    비기능적 요구사항 카테고리                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐           │
│  │   성능        │  │   확장성      │  │   가용성      │           │
│  │  (Performance)│ │ (Scalability)│  │(Availability)│           │
│  ├──────────────┤  ├──────────────┤  ├──────────────┤           │
│  │ - 응답시간    │  │ - 수평 확장   │  │ - SLA 목표   │           │
│  │ - 처리량      │  │ - 수직 확장   │  │ - 장애 허용   │           │
│  │ - 지연시간    │  │ - 탄력성      │  │ - 복구 시간   │           │
│  └──────────────┘  └──────────────┘  └──────────────┘           │
│                                                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐           │
│  │   일관성      │  │   보안        │  │   운영성      │           │
│  │ (Consistency)│  │  (Security)  │  │(Operability) │           │
│  ├──────────────┤  ├──────────────┤  ├──────────────┤           │
│  │ - 강한 일관성 │  │ - 인증/인가   │  │ - 모니터링    │           │
│  │ - 최종 일관성 │  │ - 암호화      │  │ - 로깅       │           │
│  │ - 읽기 일관성 │  │ - 감사 로그   │  │ - 배포       │           │
│  └──────────────┘  └──────────────┘  └──────────────┘           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 주요 메트릭

| 메트릭 | 설명 | 일반적인 목표값 |
|-------|------|---------------|
| Latency (P99) | 99%의 요청이 이 시간 내 완료 | < 100ms |
| Throughput | 초당 처리 가능한 요청 수 | 10K+ QPS |
| Availability | 연간 가동률 | 99.9% ~ 99.99% |
| Durability | 데이터 손실 없이 보관되는 비율 | 99.999999999% (11 9's) |
| RTO | 복구 목표 시간 | < 1시간 |
| RPO | 복구 목표 시점 | < 1분 |

#### 가용성 수준과 다운타임

```
가용성 수준에 따른 연간 허용 다운타임:

99%       → 3.65일/년   (~87.6시간)
99.9%     → 8.76시간/년 (~526분)
99.99%    → 52.6분/년
99.999%   → 5.26분/년
99.9999%  → 31.5초/년

"Five Nines" (99.999%)는 대부분의 중요 시스템의 목표
```

---

## 3. 용량 산정 (Back-of-envelope Estimation)

### 3.1 기본 수치 암기

시스템 디자인에서 빠른 계산을 위해 알아야 할 기본 수치들입니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                        데이터 크기                               │
├─────────────────────────────────────────────────────────────────┤
│  1 Byte      = 8 bits                                           │
│  1 KB        = 1,000 Bytes       (10^3)                         │
│  1 MB        = 1,000 KB          (10^6)                         │
│  1 GB        = 1,000 MB          (10^9)                         │
│  1 TB        = 1,000 GB          (10^12)                        │
│  1 PB        = 1,000 TB          (10^15)                        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                        시간 단위                                 │
├─────────────────────────────────────────────────────────────────┤
│  1일   = 86,400초    ≈ 10^5초                                    │
│  1주   = 604,800초   ≈ 6 × 10^5초                                │
│  1달   = 2,592,000초 ≈ 2.5 × 10^6초                              │
│  1년   = 31,536,000초 ≈ 3 × 10^7초                               │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    레이턴시 수치 (2024 기준)                       │
├─────────────────────────────────────────────────────────────────┤
│  L1 캐시 참조                        0.5 ns                       │
│  L2 캐시 참조                        7 ns                         │
│  메인 메모리 참조                    100 ns                       │
│  SSD 랜덤 읽기                       150 μs                       │
│  HDD 디스크 탐색                     10 ms                        │
│  같은 데이터센터 내 RTT              0.5 ms                        │
│  대륙 간 RTT                         150 ms                       │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 2의 거듭제곱

```
2^10 = 1,024           ≈ 1 Thousand (1 KB)
2^20 = 1,048,576       ≈ 1 Million  (1 MB)
2^30 = 1,073,741,824   ≈ 1 Billion  (1 GB)
2^40 = 1,099,511,627,776 ≈ 1 Trillion (1 TB)

빠른 계산 팁:
- 2^10 ≈ 1000 (약 10^3)
- 따라서 2^20 ≈ 10^6, 2^30 ≈ 10^9
```

### 3.3 QPS (Queries Per Second) 계산

```python
# QPS 계산 공식
QPS = (DAU × 일일_평균_요청수) / 86400

# 피크 QPS (보통 평균의 2~3배)
Peak_QPS = QPS × 3

# 예시: Twitter
DAU = 300,000,000 (3억)
일일_평균_트윗_조회 = 10회

QPS = (300,000,000 × 10) / 86,400
    = 3,000,000,000 / 86,400
    ≈ 35,000 QPS

Peak_QPS ≈ 100,000 QPS
```

### 3.4 스토리지 용량 계산

#### 예시: 이미지 공유 서비스

```
가정:
- DAU: 10,000,000 (1천만)
- 하루 업로드: 사용자당 2개
- 이미지 평균 크기: 500 KB
- 보관 기간: 5년

일일 업로드 이미지 수:
10,000,000 × 2 = 20,000,000 (2천만 장/일)

일일 스토리지:
20,000,000 × 500 KB = 10,000,000 MB = 10 TB/일

연간 스토리지:
10 TB × 365 = 3.65 PB/년

5년 총 스토리지:
3.65 PB × 5 = 18.25 PB

+ 메타데이터 (약 5%)
+ 리플리케이션 (3x)
= 18.25 × 1.05 × 3 ≈ 57.5 PB
```

### 3.5 대역폭 계산

```
가정 (위 이미지 서비스 계속):
- 읽기:쓰기 비율 = 100:1
- 하루 업로드: 20,000,000장

쓰기 대역폭:
20,000,000 × 500 KB / 86,400초
= 10,000,000 MB / 86,400초
= 115.7 MB/s ≈ 1 Gbps

읽기 대역폭:
115.7 MB/s × 100 = 11,570 MB/s ≈ 100 Gbps
```

### 3.6 실전 계산 템플릿

```
┌─────────────────────────────────────────────────────────────────┐
│                    용량 산정 체크리스트                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 트래픽 추정                                                  │
│     □ DAU/MAU                                                   │
│     □ 사용자당 일일 요청 수                                       │
│     □ 읽기/쓰기 비율                                             │
│     □ 평균 QPS 및 피크 QPS                                       │
│                                                                 │
│  2. 스토리지 추정                                                 │
│     □ 데이터 항목당 크기                                          │
│     □ 일일/월간/연간 데이터 증가량                                 │
│     □ 보관 기간                                                  │
│     □ 복제 팩터                                                  │
│                                                                 │
│  3. 대역폭 추정                                                  │
│     □ 인바운드 트래픽                                             │
│     □ 아웃바운드 트래픽                                           │
│     □ CDN 필요성                                                 │
│                                                                 │
│  4. 캐시 추정                                                    │
│     □ 핫 데이터 비율 (보통 20% 규칙)                               │
│     □ 캐시 히트율 목표                                            │
│     □ 캐시 메모리 크기                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. 트레이드오프 분석

### 4.1 일반적인 트레이드오프

시스템 디자인에서 모든 것을 완벽하게 만족시키는 것은 불가능합니다. 핵심은 요구사항에 맞는 **적절한 균형점**을 찾는 것입니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    주요 트레이드오프 관계                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   일관성 ←───────────────────────────────────────→ 가용성        │
│                    (CAP Theorem)                                │
│                                                                 │
│   레이턴시 ←──────────────────────────────────────→ 처리량       │
│                    (Latency vs Throughput)                      │
│                                                                 │
│   단순성 ←───────────────────────────────────────→ 기능성        │
│                    (Simplicity vs Features)                     │
│                                                                 │
│   비용 ←─────────────────────────────────────────→ 성능         │
│                    (Cost vs Performance)                        │
│                                                                 │
│   읽기 최적화 ←───────────────────────────────────→ 쓰기 최적화   │
│                    (Read vs Write)                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 데이터베이스 선택 트레이드오프

#### SQL vs NoSQL

| 특성 | SQL (RDB) | NoSQL |
|-----|-----------|-------|
| 스키마 | 고정 스키마 | 유연한 스키마 |
| 확장성 | 수직 확장 중심 | 수평 확장 용이 |
| 일관성 | ACID 보장 | 최종 일관성 (대부분) |
| 조인 | 복잡한 조인 지원 | 조인 제한적 |
| 트랜잭션 | 강력한 트랜잭션 | 제한적 트랜잭션 |
| 쿼리 유연성 | SQL로 다양한 쿼리 | 쿼리 패턴 제한적 |

```
선택 가이드:

SQL을 선택할 때:
├── 데이터 관계가 복잡할 때
├── ACID 트랜잭션이 필수일 때
├── 스키마가 안정적일 때
└── 복잡한 쿼리가 필요할 때

NoSQL을 선택할 때:
├── 대규모 데이터, 높은 처리량이 필요할 때
├── 스키마가 자주 변경될 때
├── 수평 확장이 중요할 때
└── 단순한 쿼리 패턴일 때
```

### 4.3 동기 vs 비동기 처리

```
┌─────────────────────────────────────────────────────────────────┐
│                    동기 처리 (Synchronous)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Client ──Request──→ Server ──Response──→ Client               │
│            └──────── 대기 중 ────────┘                           │
│                                                                 │
│   장점:                                                         │
│   - 구현이 단순                                                  │
│   - 즉각적인 결과 확인                                           │
│   - 디버깅 용이                                                  │
│                                                                 │
│   단점:                                                         │
│   - 클라이언트 블로킹                                             │
│   - 리소스 점유                                                  │
│   - 확장성 제한                                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                   비동기 처리 (Asynchronous)                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Client ──Request──→ Queue ──Process──→ Worker                 │
│      │                                      │                   │
│      └──────── 즉시 응답 (ACK) ────────────┘                     │
│                                                                 │
│   장점:                                                         │
│   - 빠른 응답 시간                                               │
│   - 확장성 향상                                                  │
│   - 부하 분산                                                   │
│   - 재시도 용이                                                  │
│                                                                 │
│   단점:                                                         │
│   - 구현 복잡도 증가                                             │
│   - 결과 확인이 지연됨                                           │
│   - 상태 관리 필요                                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.4 캐싱 전략 트레이드오프

```
┌─────────────────────────────────────────────────────────────────┐
│                       캐싱 패턴 비교                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Cache-Aside (Lazy Loading)                                     │
│  ├── 읽기: 캐시 확인 → 미스 시 DB 조회 → 캐시 저장                  │
│  ├── 장점: 필요한 데이터만 캐싱, 캐시 장애 시 DB 폴백               │
│  └── 단점: 첫 요청 느림, 캐시 일관성 관리 필요                      │
│                                                                 │
│  Write-Through                                                  │
│  ├── 쓰기: 캐시와 DB 동시 업데이트                                 │
│  ├── 장점: 캐시와 DB 일관성 유지                                   │
│  └── 단점: 쓰기 레이턴시 증가, 불필요한 데이터도 캐싱               │
│                                                                 │
│  Write-Behind (Write-Back)                                      │
│  ├── 쓰기: 캐시에만 쓰고, 나중에 비동기로 DB 업데이트               │
│  ├── 장점: 빠른 쓰기 성능, 쓰기 배치 처리 가능                      │
│  └── 단점: 데이터 손실 위험, 구현 복잡                             │
│                                                                 │
│  Refresh-Ahead                                                  │
│  ├── 만료 전 백그라운드에서 미리 갱신                              │
│  ├── 장점: 캐시 미스 최소화                                        │
│  └── 단점: 예측 실패 시 리소스 낭비                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.5 Push vs Pull 아키텍처

```
예시: 소셜 미디어 피드

┌────────────────────────────────────────────────────────────────┐
│  Push 모델 (Fan-out on Write)                                   │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  게시물 작성 시:                                                 │
│  ┌──────┐    ┌──────────┐    ┌────────────┐                    │
│  │ User │───→│ 게시물   │───→│ 모든 팔로워 │                    │
│  └──────┘    │ 서버     │    │ 타임라인에  │                    │
│              └──────────┘    │ 복사       │                    │
│                              └────────────┘                    │
│                                                                │
│  장점: 읽기 시 빠른 응답                                         │
│  단점: 유명인의 경우 팔로워가 수백만 → 쓰기 부하 급증              │
│                                                                │
└────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────┐
│  Pull 모델 (Fan-out on Read)                                    │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  타임라인 조회 시:                                               │
│  ┌──────┐    ┌──────────┐    ┌────────────┐                    │
│  │ User │───→│ 조회     │───→│ 팔로잉한   │                    │
│  └──────┘    │ 요청     │    │ 사용자들의 │                    │
│              └──────────┘    │ 게시물 집계│                    │
│                              └────────────┘                    │
│                                                                │
│  장점: 쓰기 시 빠른 응답                                         │
│  단점: 읽기 시 여러 소스 집계 필요 → 읽기 레이턴시 증가            │
│                                                                │
└────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────┐
│  하이브리드 모델 (Twitter 방식)                                   │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  - 일반 사용자: Push 모델 사용                                   │
│  - 유명인 (팔로워 많은 사용자): Pull 모델 사용                     │
│  - 읽기 시 Pre-computed 타임라인 + 유명인 게시물 병합             │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 5. 확장성, 가용성, 일관성 고려사항

### 5.1 CAP 정리 (CAP Theorem)

분산 시스템에서는 다음 세 가지를 **동시에 모두 만족시킬 수 없습니다**.

```
┌─────────────────────────────────────────────────────────────────┐
│                        CAP 정리                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                    Consistency (일관성)                          │
│                         /\                                      │
│                        /  \                                     │
│                       /    \                                    │
│                      /  CP  \                                   │
│                     /   시스템 \                                 │
│                    /          \                                 │
│                   /            \                                │
│                  /              \                               │
│   Partition ────/────────────────\──── Availability             │
│   Tolerance    \       AP        /     (가용성)                  │
│   (분할 내성)   \     시스템     /                                │
│                  \             /                                │
│                   \           /                                 │
│                    ───────────                                  │
│                                                                 │
│  Consistency: 모든 노드가 동시에 같은 데이터를 봄                  │
│  Availability: 모든 요청이 (성공/실패) 응답을 받음                 │
│  Partition Tolerance: 네트워크 분할에도 시스템이 동작               │
│                                                                 │
│  ⚠️ 네트워크 분할은 불가피하므로, 실제로는 CP vs AP 선택            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 데이터베이스별 CAP 분류

| 분류 | 데이터베이스 | 특징 |
|-----|------------|------|
| CP | MongoDB, HBase, Redis (Cluster) | 일관성 우선, 네트워크 분할 시 가용성 희생 |
| AP | Cassandra, DynamoDB, CouchDB | 가용성 우선, 최종 일관성 허용 |
| CA | 전통적 RDBMS (단일 노드) | 분할 내성 없음 (분산 아님) |

### 5.2 PACELC 정리

CAP을 확장한 개념으로, 네트워크 분할이 **없는** 경우의 트레이드오프도 고려합니다.

```
PACELC = PAC + ELC

if Partition (분할 발생):
    Availability vs Consistency
Else (분할 없음):
    Latency vs Consistency

예시:
┌─────────────┬────────────────────────────────────────────┐
│ 시스템       │ PACELC 분류                                 │
├─────────────┼────────────────────────────────────────────┤
│ Dynamo      │ PA/EL - 가용성 우선, 낮은 레이턴시 우선        │
│ Cassandra   │ PA/EL - 가용성 우선, 낮은 레이턴시 우선        │
│ BigTable    │ PC/EC - 일관성 우선 (분할/평상시 모두)         │
│ MongoDB     │ PA/EC - 분할 시 가용성, 평상시 일관성          │
│ PNUTS       │ PC/EL - 분할 시 일관성, 평상시 낮은 레이턴시    │
└─────────────┴────────────────────────────────────────────┘
```

### 5.3 일관성 수준

```
┌─────────────────────────────────────────────────────────────────┐
│                      일관성 스펙트럼                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  강한 일관성 ──────────────────────────────────→ 약한 일관성      │
│  (Strong)                                    (Weak/Eventual)   │
│                                                                 │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌───────────┐ │
│  │ Lineariza-  │ │ Sequential  │ │  Causal     │ │ Eventual  │ │
│  │ bility      │ │ Consistency │ │ Consistency │ │ Consisten │ │
│  │             │ │             │ │             │ │ cy        │ │
│  │ 실시간      │ │ 순서 보장   │ │ 인과관계    │ │ 최종적    │ │
│  │ 일관성      │ │             │ │ 보장        │ │ 수렴      │ │
│  └─────────────┘ └─────────────┘ └─────────────┘ └───────────┘ │
│                                                                 │
│  ← 레이턴시 높음                         레이턴시 낮음 →          │
│  ← 가용성 낮음                           가용성 높음 →            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 일관성 수준별 사용 사례

| 일관성 수준 | 적합한 사용 사례 |
|-----------|----------------|
| 강한 일관성 | 금융 거래, 재고 관리, 예약 시스템 |
| 순차 일관성 | 소셜 미디어 피드, 채팅 메시지 순서 |
| 인과 일관성 | 협업 편집, 댓글 시스템 |
| 최종 일관성 | 좋아요 수, 조회수, DNS |

### 5.4 확장성 전략

#### 수직 확장 (Scale Up) vs 수평 확장 (Scale Out)

```
┌─────────────────────────────────────────────────────────────────┐
│                    수직 확장 (Scale Up)                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Before:              After:                                   │
│   ┌────────┐           ┌────────────┐                           │
│   │ Server │    →      │   Server   │                           │
│   │ 4 CPU  │           │   32 CPU   │                           │
│   │ 16GB   │           │   256GB    │                           │
│   └────────┘           └────────────┘                           │
│                                                                 │
│   장점: 구현 단순, 애플리케이션 변경 불필요                        │
│   단점: 비용 급증, 물리적 한계, 단일 장애점                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    수평 확장 (Scale Out)                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Before:              After:                                   │
│   ┌────────┐           ┌────────┐ ┌────────┐ ┌────────┐        │
│   │ Server │    →      │ Server │ │ Server │ │ Server │        │
│   │        │           │   1    │ │   2    │ │   3    │        │
│   └────────┘           └────────┘ └────────┘ └────────┘        │
│                              ↑         ↑         ↑              │
│                              └────Load Balancer──┘              │
│                                                                 │
│   장점: 무제한 확장 가능, 장애 격리, 비용 효율적                    │
│   단점: 구현 복잡, 데이터 일관성 관리, 네트워크 오버헤드            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 데이터베이스 확장 전략

```
┌─────────────────────────────────────────────────────────────────┐
│                    데이터베이스 확장 전략                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 읽기 복제 (Read Replicas)                                    │
│     ┌─────────┐                                                 │
│     │ Primary │──Write──→ ┌─────────┐                           │
│     │ (Write) │           │ Replica │──Read──→                  │
│     └─────────┘──Sync───→ │ (Read)  │                           │
│                           └─────────┘                           │
│                           ┌─────────┐                           │
│                   ──Sync─→│ Replica │──Read──→                  │
│                           └─────────┘                           │
│                                                                 │
│  2. 샤딩 (Sharding)                                              │
│     ┌─────────┐ ┌─────────┐ ┌─────────┐                         │
│     │ Shard 1 │ │ Shard 2 │ │ Shard 3 │                         │
│     │ A-H     │ │ I-P     │ │ Q-Z     │                         │
│     └─────────┘ └─────────┘ └─────────┘                         │
│          ↑           ↑           ↑                              │
│          └─── Shard Key (예: user_id의 첫글자) ───┘              │
│                                                                 │
│  3. 파티셔닝 (Partitioning)                                      │
│     - 수평 파티셔닝: 행 기준 분할                                  │
│     - 수직 파티셔닝: 열 기준 분할                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.5 가용성 보장 전략

```
┌─────────────────────────────────────────────────────────────────┐
│                    고가용성 (High Availability) 패턴             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 이중화 (Redundancy)                                          │
│     - 모든 중요 컴포넌트를 다중화                                  │
│     - Active-Passive 또는 Active-Active 구성                     │
│                                                                 │
│  2. 헬스 체크 & 자동 페일오버                                      │
│     ┌────────┐                                                  │
│     │ Health │──Check──→ Primary ✗                              │
│     │ Check  │                ↓                                 │
│     └────────┘          Auto Failover                           │
│                               ↓                                 │
│                          Secondary → Primary                    │
│                                                                 │
│  3. 다중 가용 영역 (Multi-AZ)                                     │
│     ┌────────────┐  ┌────────────┐  ┌────────────┐              │
│     │    AZ-1    │  │    AZ-2    │  │    AZ-3    │              │
│     │ ┌────────┐ │  │ ┌────────┐ │  │ ┌────────┐ │              │
│     │ │ Server │ │  │ │ Server │ │  │ │ Server │ │              │
│     │ └────────┘ │  │ └────────┘ │  │ └────────┘ │              │
│     └────────────┘  └────────────┘  └────────────┘              │
│                                                                 │
│  4. 회로 차단기 (Circuit Breaker)                                 │
│     - 장애 서비스 호출 차단                                        │
│     - 빠른 실패 (Fail Fast) 구현                                  │
│     - 폴백 (Fallback) 로직 제공                                   │
│                                                                 │
│  5. 레이트 리미팅 & 로드 셰딩                                      │
│     - 과부하 시 요청 제한                                          │
│     - 중요도 기반 트래픽 우선순위                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.6 장애 대응 패턴

```
┌─────────────────────────────────────────────────────────────────┐
│                    장애 격리 및 복구 패턴                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 벌크헤드 (Bulkhead) 패턴                                      │
│     ┌──────────┬──────────┬──────────┐                          │
│     │ Service A│ Service B│ Service C│ ← 격벽으로 분리           │
│     │ (Pool 1) │ (Pool 2) │ (Pool 3) │                          │
│     └──────────┴──────────┴──────────┘                          │
│     → 한 서비스 장애가 다른 서비스에 영향 X                         │
│                                                                 │
│  2. 재시도 (Retry) 전략                                           │
│     - 지수 백오프 (Exponential Backoff)                           │
│     - 최대 재시도 횟수 제한                                        │
│     - 지터 (Jitter) 추가                                          │
│                                                                 │
│     delay = min(cap, base * 2^attempt) + random_jitter           │
│                                                                 │
│  3. 타임아웃 설정                                                 │
│     - 연결 타임아웃                                               │
│     - 읽기 타임아웃                                               │
│     - 전체 요청 타임아웃                                          │
│                                                                 │
│  4. 폴백 (Fallback)                                               │
│     - 캐시된 데이터 반환                                          │
│     - 기본값 반환                                                 │
│     - 대체 서비스 호출                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 참고 자료

- [System Design Interview by Alex Xu](https://www.amazon.com/System-Design-Interview-insiders-Second/dp/B08CMF2CQF)
- [Designing Data-Intensive Applications (DDIA)](https://dataintensive.net/)
- [ByteByteGo - Back-of-the-envelope Estimation](https://bytebytego.com/courses/system-design-interview/back-of-the-envelope-estimation)
- [CAP Theorem Explained - IBM](https://www.ibm.com/think/topics/cap-theorem)
- [The Pragmatic Engineer - System Design Interview Review](https://blog.pragmaticengineer.com/system-design-interview-an-insiders-guide-review/)
- [GeeksforGeeks - Back of Envelope Estimation](https://www.geeksforgeeks.org/system-design/back-of-the-envelope-estimation-in-system-design/)
- [DesignGurus - Mastering Back-of-the-Envelope Estimation](https://www.designgurus.io/blog/back-of-the-envelope-system-design-interview)

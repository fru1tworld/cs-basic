# 분산 시스템 (Distributed Systems)

## 목차
1. [분산 시스템 기초 개념](#1-분산-시스템-기초-개념)
2. [분산 합의 알고리즘](#2-분산-합의-알고리즘)
3. [분산 트랜잭션](#3-분산-트랜잭션)
4. [분산 락과 리더 선출](#4-분산-락과-리더-선출)
5. [장애 허용과 복구](#5-장애-허용과-복구)

---

## 1. 분산 시스템 기초 개념

### 1.1 분산 시스템이란?

분산 시스템은 네트워크로 연결된 여러 독립적인 컴퓨터들이 하나의 통합된 시스템처럼 동작하는 컴퓨팅 환경입니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                      분산 시스템 구조                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│     ┌─────────┐       ┌─────────┐       ┌─────────┐            │
│     │ Node A  │       │ Node B  │       │ Node C  │            │
│     │         │       │         │       │         │            │
│     │ ┌─────┐ │       │ ┌─────┐ │       │ ┌─────┐ │            │
│     │ │ App │ │       │ │ App │ │       │ │ App │ │            │
│     │ └─────┘ │       │ └─────┘ │       │ └─────┘ │            │
│     │ ┌─────┐ │       │ ┌─────┐ │       │ ┌─────┐ │            │
│     │ │ DB  │ │       │ │ DB  │ │       │ │ DB  │ │            │
│     │ └─────┘ │       │ └─────┘ │       │ └─────┘ │            │
│     └────┬────┘       └────┬────┘       └────┬────┘            │
│          │                 │                 │                 │
│          └────────────┬────┴────────────────┘                 │
│                       │                                        │
│              ┌────────┴────────┐                              │
│              │    Network      │                              │
│              │  (메시지 전달)   │                              │
│              └─────────────────┘                              │
│                                                                │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 분산 시스템의 특성

#### CAP 정리 (CAP Theorem)

분산 시스템에서는 다음 세 가지 속성 중 최대 두 가지만 동시에 보장할 수 있습니다.

```
                    ┌─────────────────┐
                    │  Consistency    │
                    │   (일관성)       │
                    └────────┬────────┘
                             │
                    ┌────────┴────────┐
                    │                 │
              ┌─────▼─────┐     ┌─────▼─────┐
              │    CA     │     │    CP     │
              │(RDBMS등)  │     │(HBase등)  │
              └───────────┘     └───────────┘
                    │                 │
     ┌──────────────┴─────────────────┴──────────────┐
     │                                               │
┌────▼────────────┐                    ┌─────────────▼────┐
│  Availability   │◄───────────────────►│   Partition      │
│   (가용성)       │         AP          │   Tolerance      │
│                 │    (Cassandra등)    │   (분할 내성)     │
└─────────────────┘                     └──────────────────┘
```

| 속성 | 설명 |
|------|------|
| **Consistency (일관성)** | 모든 노드가 동일한 시점에 동일한 데이터를 본다 |
| **Availability (가용성)** | 모든 요청은 반드시 응답을 받는다 |
| **Partition Tolerance (분할 내성)** | 네트워크 분할이 발생해도 시스템이 계속 동작한다 |

### 1.3 분산 시스템의 도전 과제

```
┌─────────────────────────────────────────────────────────────────┐
│                    분산 시스템 도전 과제                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │   네트워크    │  │    시간      │  │    장애      │          │
│  │   지연/실패   │  │   동기화     │  │    처리      │          │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘          │
│         │                 │                 │                   │
│         ▼                 ▼                 ▼                   │
│  - 메시지 손실      - 클럭 드리프트   - 부분 장애              │
│  - 순서 뒤바뀜      - 논리적 시계     - Byzantine 장애          │
│  - 중복 전송        - 벡터 시계       - 장애 감지               │
│                                                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │    합의      │  │   데이터     │  │    확장성    │          │
│  │   달성       │  │   일관성     │  │   관리       │          │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘          │
│         │                 │                 │                   │
│         ▼                 ▼                 ▼                   │
│  - 리더 선출        - 복제 전략       - 수평 확장              │
│  - 원자적 브로드캐스트- 충돌 해결      - 로드 밸런싱            │
│  - 상태 머신 복제   - 최종 일관성     - 데이터 파티셔닝         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.4 시간과 순서 (Time and Ordering)

분산 시스템에서 시간 동기화는 매우 어려운 문제입니다.

#### 논리적 시계 (Logical Clocks)

```
┌─────────────────────────────────────────────────────────────────┐
│                   Lamport 논리적 시계                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Process A         Process B         Process C                │
│       │                 │                 │                    │
│   (1) ●                 │                 │                    │
│       │                 │                 │                    │
│       │─────────────────►(2)              │                    │
│       │                 │                 │                    │
│   (3) ●                 │                 │                    │
│       │                 │                 │                    │
│       │                 │─────────────────►(3)                 │
│       │                 │                 │                    │
│       │                 │(4)              │                    │
│       │                 │                 │                    │
│       │◄────────────────────────────────(5)                   │
│   (6) ●                 │                 │                    │
│                                                                 │
│   규칙:                                                         │
│   1. 로컬 이벤트 발생 시: LC = LC + 1                           │
│   2. 메시지 전송 시: LC = LC + 1, 메시지에 LC 포함              │
│   3. 메시지 수신 시: LC = max(LC, 수신된 LC) + 1                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 벡터 시계 (Vector Clocks)

```
┌─────────────────────────────────────────────────────────────────┐
│                      벡터 시계                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Server A              Server B              Server C         │
│      │                     │                     │             │
│  [1,0,0]                   │                     │             │
│      │                     │                     │             │
│      │────────────────────►│                     │             │
│      │               [1,1,0]                     │             │
│      │                     │                     │             │
│      │                     │────────────────────►│             │
│      │                     │               [1,1,1]             │
│      │                     │                     │             │
│  [2,0,0]                   │                     │             │
│      │                     │                     │             │
│      │◄────────────────────────────────────────│             │
│  [2,1,1]                   │                     │             │
│                                                                 │
│   벡터 시계 비교:                                               │
│   - [1,2,0] < [1,2,1] (인과 관계 있음)                         │
│   - [1,2,0] || [0,1,2] (동시 발생, 인과 관계 없음)             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 분산 합의 알고리즘

### 2.1 합의 문제란?

분산 시스템에서 합의(Consensus)는 여러 노드가 하나의 값에 동의하는 것을 의미합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                      합의 문제 예시                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│     제안자들                        합의 결과                   │
│                                                                 │
│    ┌───────┐                                                   │
│    │Node A │ ──── "값 = 5" ────┐                              │
│    └───────┘                    │                              │
│                                 │      ┌──────────────────┐    │
│    ┌───────┐                    ├────►│  모든 노드가      │    │
│    │Node B │ ──── "값 = 7" ────┤      │  동일한 값에      │    │
│    └───────┘                    │      │  동의: "값 = 5"   │    │
│                                 │      └──────────────────┘    │
│    ┌───────┐                    │                              │
│    │Node C │ ──── "값 = 5" ────┘                              │
│    └───────┘                                                   │
│                                                                 │
│  합의의 조건:                                                   │
│  1. 종료성(Termination): 모든 올바른 노드는 결국 결정한다       │
│  2. 합의(Agreement): 모든 올바른 노드는 같은 값을 결정한다      │
│  3. 유효성(Validity): 결정된 값은 어떤 노드가 제안한 값이다     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 Paxos 알고리즘

Paxos는 Leslie Lamport가 제안한 분산 합의 알고리즘입니다.

#### Paxos의 역할

```
┌─────────────────────────────────────────────────────────────────┐
│                      Paxos 역할 구성                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────┐                                           │
│  │    Proposer     │  값을 제안하는 역할                        │
│  │    (제안자)      │  고유한 제안 번호(proposal number) 사용    │
│  └─────────────────┘                                           │
│                                                                 │
│  ┌─────────────────┐                                           │
│  │    Acceptor     │  제안을 수락/거부하는 역할                 │
│  │    (수락자)      │  과반수(Quorum)가 수락해야 합의 성립       │
│  └─────────────────┘                                           │
│                                                                 │
│  ┌─────────────────┐                                           │
│  │    Learner      │  합의된 값을 학습하는 역할                 │
│  │    (학습자)      │  최종 결정값을 적용                       │
│  └─────────────────┘                                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Paxos 프로토콜 흐름

```
┌─────────────────────────────────────────────────────────────────┐
│                    Paxos 2단계 프로토콜                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Phase 1: Prepare (준비)                                       │
│  ════════════════════════                                      │
│                                                                 │
│    Proposer                    Acceptors                       │
│        │                      A1   A2   A3                     │
│        │                       │    │    │                     │
│        │──── Prepare(n) ──────►│    │    │                     │
│        │──── Prepare(n) ───────────►│    │                     │
│        │──── Prepare(n) ────────────────►│                     │
│        │                       │    │    │                     │
│        │◄─── Promise(n) ──────│    │    │                     │
│        │◄─── Promise(n) ───────────│    │                     │
│        │◄─── Promise(n) ────────────────│                     │
│        │                       │    │    │                     │
│                                                                 │
│  Phase 2: Accept (수락)                                        │
│  ══════════════════════                                        │
│                                                                 │
│    Proposer                    Acceptors                       │
│        │                      A1   A2   A3                     │
│        │                       │    │    │                     │
│        │── Accept(n,v) ───────►│    │    │                     │
│        │── Accept(n,v) ────────────►│    │                     │
│        │── Accept(n,v) ─────────────────►│                     │
│        │                       │    │    │                     │
│        │◄── Accepted(n,v) ────│    │    │                     │
│        │◄── Accepted(n,v) ─────────│    │                     │
│        │◄── Accepted(n,v) ──────────────│                     │
│        │                       │    │    │                     │
│        ▼                                                       │
│   ┌─────────────────────────────────────┐                      │
│   │ 과반수 수락 → 값 v가 선택됨(Chosen)  │                      │
│   └─────────────────────────────────────┘                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Paxos 상세 동작 예시

```
┌─────────────────────────────────────────────────────────────────┐
│                 Paxos 충돌 해결 시나리오                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   시간 →                                                       │
│                                                                 │
│   Proposer 1 (P1)               Proposer 2 (P2)                │
│   값 = "X"                      값 = "Y"                       │
│       │                              │                         │
│       │── Prepare(1) ──►            │                          │
│       │                              │── Prepare(2) ──►        │
│       │                              │                          │
│       │   Acceptors: "1보다 높은      │                          │
│       │   제안만 수락하겠다"          │                          │
│       │                              │                          │
│       │◄── Promise(1) ──            │                          │
│       │                              │◄── Promise(2) ──        │
│       │                              │                          │
│       │── Accept(1,"X") ──►          │                          │
│       │     ✗ 거부됨                 │                          │
│       │     (이미 2를 약속함)         │                          │
│       │                              │                          │
│       │                              │── Accept(2,"Y") ──►     │
│       │                              │    ✓ 수락됨              │
│       │                              │                          │
│       │                              ▼                          │
│       │                         값 "Y" 선택됨                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 Raft 알고리즘

Raft는 Paxos보다 이해하기 쉽게 설계된 합의 알고리즘입니다.

#### Raft 노드 상태

```
┌─────────────────────────────────────────────────────────────────┐
│                      Raft 노드 상태 전이                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                      ┌───────────────┐                         │
│         시작 ───────►│   Follower    │                         │
│                      │   (팔로워)     │                         │
│                      └───────┬───────┘                         │
│                              │                                  │
│                    타임아웃  │                                  │
│                   (heartbeat │                                  │
│                    미수신)   │                                  │
│                              ▼                                  │
│                      ┌───────────────┐                         │
│                      │  Candidate    │◄──────────────┐         │
│                      │   (후보자)     │               │         │
│                      └───────┬───────┘    선거 실패   │         │
│                              │           (분할 투표)  │         │
│                    과반수    │               │        │         │
│                    투표 획득 │               └────────┘         │
│                              ▼                                  │
│                      ┌───────────────┐                         │
│                      │    Leader     │                         │
│                      │    (리더)      │                         │
│                      └───────┬───────┘                         │
│                              │                                  │
│                    더 높은 임기의                               │
│                    리더 발견                                    │
│                              │                                  │
│                              ▼                                  │
│                      ┌───────────────┐                         │
│                      │   Follower    │                         │
│                      └───────────────┘                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Raft 리더 선출 과정

```
┌─────────────────────────────────────────────────────────────────┐
│                    Raft 리더 선출 과정                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Term 1: 정상 운영                                             │
│  ─────────────────                                             │
│                                                                 │
│   ┌─────────┐      Heartbeat      ┌─────────┐                  │
│   │ Leader  │ ──────────────────► │Follower │                  │
│   │ (Node1) │                     │ (Node2) │                  │
│   └─────────┘                     └─────────┘                  │
│        │                               │                        │
│        │          Heartbeat            │                        │
│        └──────────────────────────────►│                        │
│                                   ┌─────────┐                  │
│                                   │Follower │                  │
│                                   │ (Node3) │                  │
│                                   └─────────┘                  │
│                                                                 │
│  Term 2: 리더 장애 후 새 선거                                   │
│  ──────────────────────────────                                │
│                                                                 │
│   ┌─────────┐                     ┌─────────┐                  │
│   │  Down   │       타임아웃      │Candidate│                  │
│   │ (Node1) │  ◄─────────────────│ (Node2) │                  │
│   └─────────┘     RequestVote     └────┬────┘                  │
│                                        │                        │
│                   RequestVote          │                        │
│                                        ▼                        │
│                                   ┌─────────┐                  │
│                    VoteGranted   │Follower │                  │
│               ◄───────────────── │ (Node3) │                  │
│                                   └─────────┘                  │
│                                                                 │
│  결과: Node2가 과반수 투표 획득 → 새로운 리더                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Raft 로그 복제

```
┌─────────────────────────────────────────────────────────────────┐
│                      Raft 로그 복제                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Leader의 로그:                                                 │
│  ┌─────┬─────┬─────┬─────┬─────┬─────┐                         │
│  │ T1  │ T1  │ T2  │ T2  │ T2  │ T3  │                         │
│  │ x←1 │ y←2 │ x←3 │ z←1 │ y←5 │ x←4 │                         │
│  └─────┴─────┴─────┴─────┴─────┴─────┘                         │
│  Index: 1     2     3     4     5     6                        │
│                           ▲                                     │
│                      commitIndex                                │
│                                                                 │
│  ────────────────────────────────────────────────────────────  │
│                                                                 │
│  복제 과정:                                                     │
│                                                                 │
│  Leader          Follower A        Follower B                  │
│     │                │                  │                       │
│     │ AppendEntries  │                  │                       │
│     │ (entries,      │                  │                       │
│     │  prevLogIndex, │                  │                       │
│     │  prevLogTerm)  │                  │                       │
│     │───────────────►│                  │                       │
│     │───────────────────────────────────►                       │
│     │                │                  │                       │
│     │◄──── Success ──│                  │                       │
│     │◄──────────────────── Success ─────│                       │
│     │                │                  │                       │
│     │   과반수 복제 확인                │                       │
│     │   → commit 후 적용                │                       │
│     │                │                  │                       │
│     │  CommitIndex   │                  │                       │
│     │  업데이트 전파  │                  │                       │
│     │───────────────►│                  │                       │
│     │───────────────────────────────────►                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Raft 로그 불일치 해결

```
┌─────────────────────────────────────────────────────────────────┐
│                   Raft 로그 불일치 해결                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Leader 로그:                                                   │
│  ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┐                   │
│  │T1,1 │T1,2 │T2,3 │T3,4 │T3,5 │T3,6 │T3,7 │                   │
│  └─────┴─────┴─────┴─────┴─────┴─────┴─────┘                   │
│                                                                 │
│  Follower 로그 (이전 리더 장애로 불일치 발생):                   │
│  ┌─────┬─────┬─────┬─────┬─────┐                               │
│  │T1,1 │T1,2 │T2,3 │T2,4 │T2,5 │  ← 잘못된 엔트리              │
│  └─────┴─────┴─────┴─────┴─────┘                               │
│                                                                 │
│  해결 과정:                                                     │
│  ───────────                                                   │
│                                                                 │
│  1. Leader가 AppendEntries 전송 (prevLogIndex=6, prevLogTerm=3)│
│  2. Follower: "인덱스 6에 Term 3 엔트리 없음" → 거부           │
│  3. Leader: nextIndex를 5로 감소                               │
│  4. Leader가 AppendEntries 전송 (prevLogIndex=5, prevLogTerm=2)│
│  5. Follower: "인덱스 5에 Term 2 있음" → 하지만 Term 불일치    │
│  6. 계속 반복...                                               │
│  7. prevLogIndex=3에서 일치 발견                               │
│  8. Follower: 인덱스 4부터 덮어쓰기                            │
│                                                                 │
│  결과:                                                          │
│  ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┐                   │
│  │T1,1 │T1,2 │T2,3 │T3,4 │T3,5 │T3,6 │T3,7 │  ← Leader와 동일 │
│  └─────┴─────┴─────┴─────┴─────┴─────┴─────┘                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.4 Paxos vs Raft 비교

| 특성 | Paxos | Raft |
|------|-------|------|
| **복잡성** | 높음 (이해하기 어려움) | 낮음 (이해하기 쉬움) |
| **리더** | 선택적 (Multi-Paxos) | 필수 (강한 리더) |
| **로그 구조** | 로그 갭 허용 | 연속적 로그만 허용 |
| **멤버십 변경** | 별도 프로토콜 필요 | Joint Consensus 내장 |
| **구현** | Google Chubby | etcd, Consul |

---

## 3. 분산 트랜잭션

### 3.1 분산 트랜잭션의 필요성

```
┌─────────────────────────────────────────────────────────────────┐
│                    분산 트랜잭션 시나리오                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  예: 계좌 이체 (A계좌 → B계좌로 100원 이체)                      │
│                                                                 │
│   ┌─────────────┐                     ┌─────────────┐          │
│   │   Bank A    │                     │   Bank B    │          │
│   │   Server    │                     │   Server    │          │
│   │             │                     │             │          │
│   │ ┌─────────┐ │                     │ ┌─────────┐ │          │
│   │ │A 계좌   │ │    ────────────►   │ │B 계좌   │ │          │
│   │ │잔액:1000│ │      100원 이체     │ │잔액:500 │ │          │
│   │ │→ 900   │ │                     │ │→ 600   │ │          │
│   │ └─────────┘ │                     │ └─────────┘ │          │
│   └─────────────┘                     └─────────────┘          │
│                                                                 │
│  문제 상황:                                                     │
│  - A에서 출금 성공 + B에서 입금 실패 → 돈이 사라짐!              │
│  - 두 작업이 원자적으로 처리되어야 함                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 2PC (Two-Phase Commit)

2PC는 분산 트랜잭션을 위한 가장 기본적인 프로토콜입니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    2PC (Two-Phase Commit)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Phase 1: Prepare (투표 단계)                                  │
│  ═══════════════════════════                                   │
│                                                                 │
│      Coordinator              Participant A    Participant B   │
│           │                        │                │          │
│           │──── PREPARE ──────────►│                │          │
│           │──── PREPARE ────────────────────────────►          │
│           │                        │                │          │
│           │◄─── VOTE_YES ─────────│                │          │
│           │◄─── VOTE_YES ───────────────────────────│          │
│           │                        │                │          │
│                                                                 │
│  Phase 2: Commit (결정 단계)                                   │
│  ═══════════════════════════                                   │
│                                                                 │
│      Coordinator              Participant A    Participant B   │
│           │                        │                │          │
│           │──── COMMIT ───────────►│                │          │
│           │──── COMMIT ─────────────────────────────►          │
│           │                        │                │          │
│           │◄─── ACK ──────────────│                │          │
│           │◄─── ACK ────────────────────────────────│          │
│           │                        │                │          │
│           ▼                        ▼                ▼          │
│      ┌─────────────────────────────────────────────────┐       │
│      │         트랜잭션 완료 (Committed)                │       │
│      └─────────────────────────────────────────────────┘       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 2PC 실패 시나리오

```
┌─────────────────────────────────────────────────────────────────┐
│                    2PC 실패 처리                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  시나리오 1: Participant가 VOTE_NO 응답                         │
│  ───────────────────────────────────────                        │
│                                                                 │
│      Coordinator              Participant A    Participant B   │
│           │                        │                │          │
│           │──── PREPARE ──────────►│                │          │
│           │──── PREPARE ────────────────────────────►          │
│           │                        │                │          │
│           │◄─── VOTE_YES ─────────│                │          │
│           │◄─── VOTE_NO ────────────────────────────│          │
│           │                        │                │          │
│           │──── ABORT ────────────►│                │          │
│           │──── ABORT ──────────────────────────────►          │
│           │                        │                │          │
│                                                                 │
│  시나리오 2: Coordinator 장애 (Blocking 문제)                   │
│  ─────────────────────────────────────────────                  │
│                                                                 │
│      Coordinator              Participant A    Participant B   │
│           │                        │                │          │
│           │──── PREPARE ──────────►│                │          │
│           │──── PREPARE ────────────────────────────►          │
│           │                        │                │          │
│           │◄─── VOTE_YES ─────────│                │          │
│           │◄─── VOTE_YES ───────────────────────────│          │
│           │                        │                │          │
│           X (장애 발생!)           │                │          │
│                                    │                │          │
│                              ┌─────┴─────┐    ┌─────┴─────┐   │
│                              │  Blocked! │    │  Blocked! │   │
│                              │락 유지 중..│    │락 유지 중..│   │
│                              └───────────┘    └───────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.3 3PC (Three-Phase Commit)

3PC는 2PC의 블로킹 문제를 해결하기 위해 제안된 프로토콜입니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    3PC (Three-Phase Commit)                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Phase 1: CanCommit (투표 요청)                               │
│   ══════════════════════════════                               │
│                                                                 │
│      Coordinator              Participants                     │
│           │────── CanCommit? ─────────►│                       │
│           │◄───── Yes ─────────────────│                       │
│                                                                 │
│   Phase 2: PreCommit (사전 커밋)                               │
│   ══════════════════════════════                               │
│                                                                 │
│      Coordinator              Participants                     │
│           │────── PreCommit ──────────►│                       │
│           │◄───── ACK ─────────────────│                       │
│           │                            │                       │
│           │  이 시점에서 참가자는      │                       │
│           │  커밋 준비 완료 상태       │                       │
│                                                                 │
│   Phase 3: DoCommit (최종 커밋)                                │
│   ═════════════════════════════                                │
│                                                                 │
│      Coordinator              Participants                     │
│           │────── DoCommit ───────────►│                       │
│           │◄───── ACK ─────────────────│                       │
│                                                                 │
│   장점: Coordinator 장애 시 참가자들이 독립적으로 결정 가능    │
│   단점: 네트워크 분할 시 일관성 문제 발생 가능                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.4 Saga 패턴

Saga는 장시간 실행되는 분산 트랜잭션을 위한 패턴입니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                      Saga 패턴 (보상 트랜잭션)                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  정상 실행 흐름:                                                │
│  ──────────────                                                │
│                                                                 │
│    T1 ──────► T2 ──────► T3 ──────► T4 ──────► 완료           │
│   주문생성   결제처리   재고차감   배송요청                     │
│                                                                 │
│  실패 시 보상 트랜잭션:                                        │
│  ─────────────────────                                         │
│                                                                 │
│    T1 ──────► T2 ──────► T3 ──────► T4                        │
│   주문생성   결제처리   재고차감    X 실패!                    │
│     │          │          │                                    │
│     │          │          ▼                                    │
│     │          │        C3 (재고복구)                          │
│     │          ▼                                               │
│     │        C2 (결제취소)                                     │
│     ▼                                                          │
│   C1 (주문취소)                                                │
│                                                                 │
│  ───────────────────────────────────────────────────────────── │
│                                                                 │
│  Saga 구현 방식:                                               │
│                                                                 │
│  1. Choreography (이벤트 기반)                                 │
│     ┌─────┐  이벤트  ┌─────┐  이벤트  ┌─────┐                 │
│     │서비스A│ ──────► │서비스B│ ──────► │서비스C│                │
│     └─────┘         └─────┘         └─────┘                   │
│                                                                 │
│  2. Orchestration (중앙 조정자)                                │
│                  ┌──────────┐                                  │
│                  │Orchestrator│                                 │
│                  └─────┬────┘                                  │
│            ┌──────────┼──────────┐                            │
│            ▼          ▼          ▼                            │
│        ┌─────┐   ┌─────┐   ┌─────┐                           │
│        │서비스A│   │서비스B│   │서비스C│                        │
│        └─────┘   └─────┘   └─────┘                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Saga Orchestration 상세 흐름

```
┌─────────────────────────────────────────────────────────────────┐
│                  Saga Orchestration 예시                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   주문 처리 Saga:                                               │
│                                                                 │
│   ┌─────────────┐                                              │
│   │   Client    │                                              │
│   └──────┬──────┘                                              │
│          │ 주문 요청                                           │
│          ▼                                                     │
│   ┌─────────────┐                                              │
│   │   Saga      │                                              │
│   │Orchestrator │                                              │
│   └──────┬──────┘                                              │
│          │                                                     │
│    ┌─────┼─────┬─────────────┬─────────────┐                  │
│    │     │     │             │             │                  │
│    ▼     │     ▼             ▼             ▼                  │
│  ┌────┐  │   ┌────┐       ┌────┐       ┌────┐                │
│  │주문│  │   │결제│       │재고│       │배송│                │
│  │서비스│ │   │서비스│      │서비스│      │서비스│               │
│  └─┬──┘  │   └─┬──┘       └─┬──┘       └─┬──┘                │
│    │     │     │             │             │                  │
│    │ 1.주문생성│             │             │                  │
│    │◄────┘     │             │             │                  │
│    │ OK        │             │             │                  │
│    │───────────│2.결제처리   │             │                  │
│    │           │◄────────────│             │                  │
│    │           │ OK          │             │                  │
│    │           │─────────────│3.재고차감   │                  │
│    │           │             │◄────────────│                  │
│    │           │             │ OK          │                  │
│    │           │             │─────────────│4.배송요청        │
│    │           │             │             │◄─────────────    │
│    │           │             │             │ OK               │
│    │           │             │             │                  │
│    ▼           ▼             ▼             ▼                  │
│                 트랜잭션 완료                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. 분산 락과 리더 선출

### 4.1 분산 락 (Distributed Lock)

분산 환경에서 공유 리소스에 대한 동시 접근을 제어합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                      분산 락의 필요성                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  문제 상황: 동시에 같은 리소스 수정 시도                         │
│  ───────────────────────────────────────                        │
│                                                                 │
│      Server A                   Server B                       │
│         │                          │                           │
│         │   READ inventory = 10    │                           │
│         │◄────────────────────────►│  READ inventory = 10      │
│         │                          │                           │
│         │  inventory = 10 - 1 = 9  │  inventory = 10 - 1 = 9  │
│         │                          │                           │
│         │   WRITE inventory = 9    │                           │
│         │─────────────────────────►│   WRITE inventory = 9    │
│         │                          │                           │
│         ▼                          ▼                           │
│     ┌─────────────────────────────────────────┐                │
│     │  결과: inventory = 9 (기대값: 8)         │                │
│     │  Lost Update 발생!                       │                │
│     └─────────────────────────────────────────┘                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Redis를 이용한 분산 락 (Redlock)

```
┌─────────────────────────────────────────────────────────────────┐
│                    Redis 분산 락 (Redlock)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  단일 인스턴스 락:                                              │
│  ─────────────────                                             │
│                                                                 │
│    Client                        Redis                         │
│       │                            │                           │
│       │  SET lock_key unique_id    │                           │
│       │      NX EX 30              │                           │
│       │───────────────────────────►│                           │
│       │                            │                           │
│       │◄─────── OK ───────────────│  락 획득 성공             │
│       │                            │                           │
│       │   (작업 수행)               │                           │
│       │                            │                           │
│       │  DEL lock_key              │                           │
│       │  (if value == unique_id)   │                           │
│       │───────────────────────────►│                           │
│       │                            │  락 해제                  │
│                                                                 │
│  ────────────────────────────────────────────────────────────  │
│                                                                 │
│  Redlock 알고리즘 (다중 인스턴스):                              │
│  ─────────────────────────────────                             │
│                                                                 │
│                    ┌──────────┐                                │
│                    │  Client  │                                │
│                    └────┬─────┘                                │
│           ┌─────────────┼─────────────┐                       │
│           │             │             │                        │
│           ▼             ▼             ▼                        │
│      ┌─────────┐  ┌─────────┐  ┌─────────┐                    │
│      │ Redis 1 │  │ Redis 2 │  │ Redis 3 │                    │
│      │   OK    │  │   OK    │  │  FAIL   │                    │
│      └─────────┘  └─────────┘  └─────────┘                    │
│           │             │             │                        │
│      ┌─────────┐  ┌─────────┐                                 │
│      │ Redis 4 │  │ Redis 5 │                                 │
│      │   OK    │  │   OK    │                                 │
│      └─────────┘  └─────────┘                                 │
│                                                                 │
│      과반수(3개 이상)에서 락 획득 → 락 성공                     │
│                                                                 │
│  Redlock 순서:                                                 │
│  1. 현재 시간 기록 (T1)                                        │
│  2. 모든 Redis 인스턴스에 순차적으로 락 시도                   │
│  3. 현재 시간 기록 (T2)                                        │
│  4. 과반수 성공 && (T2 - T1) < 락 TTL → 락 획득 성공          │
│  5. 실패 시 모든 인스턴스에서 락 해제                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### ZooKeeper를 이용한 분산 락

```
┌─────────────────────────────────────────────────────────────────┐
│                  ZooKeeper 분산 락 구현                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ZNode 구조:                                                   │
│  ────────────                                                  │
│                                                                 │
│     /locks                                                     │
│       └── /resource_lock                                       │
│             ├── lock-0000000001  (Client A)                   │
│             ├── lock-0000000002  (Client B)                   │
│             └── lock-0000000003  (Client C)                   │
│                                                                 │
│  락 획득 과정:                                                  │
│  ─────────────                                                 │
│                                                                 │
│    Client A                       ZooKeeper                    │
│       │                              │                         │
│       │ create /locks/resource_lock/ │                         │
│       │        lock- (EPHEMERAL +    │                         │
│       │              SEQUENTIAL)     │                         │
│       │─────────────────────────────►│                         │
│       │                              │                         │
│       │◄── /locks/.../lock-0001 ────│                         │
│       │                              │                         │
│       │    getChildren()             │                         │
│       │─────────────────────────────►│                         │
│       │                              │                         │
│       │◄── [lock-0001] ─────────────│  내가 최소값 → 락 획득  │
│       │                              │                         │
│                                                                 │
│    Client B                       ZooKeeper                    │
│       │                              │                         │
│       │ create lock-0002             │                         │
│       │─────────────────────────────►│                         │
│       │                              │                         │
│       │◄── /locks/.../lock-0002 ────│                         │
│       │                              │                         │
│       │    getChildren()             │                         │
│       │─────────────────────────────►│                         │
│       │                              │                         │
│       │◄── [lock-0001, lock-0002] ──│  내가 최소가 아님       │
│       │                              │                         │
│       │    watch(lock-0001)          │  이전 노드 감시        │
│       │─────────────────────────────►│                         │
│       │                              │                         │
│       │   (lock-0001 삭제 시 알림)   │                         │
│       │◄─────────────────────────────│  락 획득!              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 리더 선출 (Leader Election)

분산 시스템에서 하나의 노드를 리더로 선출하는 과정입니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                      리더 선출 알고리즘                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Bully 알고리즘:                                               │
│  ───────────────                                               │
│                                                                 │
│    가장 높은 ID를 가진 노드가 리더가 됨                         │
│                                                                 │
│    Node 1     Node 2     Node 3(L)   Node 4                   │
│      │          │          X (장애)     │                      │
│      │          │                       │                      │
│      │          │   타임아웃 감지       │                      │
│      │          │──────────────────────►│                      │
│      │◄─────────│   Election 메시지     │                      │
│      │          │                       │                      │
│      │          │◄────── OK ────────────│                      │
│      │          │                       │                      │
│      │          │     Node 4가 더 높은 ID                      │
│      │          │     → 선거 포기       │                      │
│      │          │                       │                      │
│      │◄─────────────── Coordinator ─────│                      │
│      │          │◄──── Coordinator ─────│                      │
│      │          │                       │                      │
│      │          │     Node 4가 새 리더  │                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Ring 알고리즘

```
┌─────────────────────────────────────────────────────────────────┐
│                      Ring 선출 알고리즘                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│              ┌───────────────────────┐                         │
│              │                       │                         │
│              ▼                       │                         │
│         ┌─────────┐            ┌─────────┐                    │
│         │  Node 1 │───────────►│  Node 2 │                    │
│         │  (ID=1) │            │  (ID=2) │                    │
│         └─────────┘            └────┬────┘                    │
│              ▲                      │                          │
│              │                      ▼                          │
│         ┌────┴────┐            ┌─────────┐                    │
│         │  Node 4 │◄───────────│  Node 3 │                    │
│         │  (ID=4) │            │  (ID=3) │                    │
│         └─────────┘            └─────────┘                    │
│                                                                 │
│   선거 과정:                                                    │
│   ───────────                                                  │
│                                                                 │
│   1. Node 2가 선거 시작                                        │
│      Election[2] → Node 3                                     │
│                                                                 │
│   2. Node 3가 자신의 ID 추가 후 전달                           │
│      Election[2,3] → Node 4                                   │
│                                                                 │
│   3. Node 4가 자신의 ID 추가 후 전달                           │
│      Election[2,3,4] → Node 1                                 │
│                                                                 │
│   4. Node 1이 자신의 ID 추가 후 전달                           │
│      Election[2,3,4,1] → Node 2                               │
│                                                                 │
│   5. Node 2가 리스트 수신 (자신이 시작점)                      │
│      → 최대 ID = 4 → Node 4가 리더                            │
│      Coordinator[4] 메시지 전파                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### ZooKeeper를 이용한 리더 선출

```
┌─────────────────────────────────────────────────────────────────┐
│                ZooKeeper 리더 선출                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  /election                                                     │
│    ├── member-0000000001  ──► Leader (최소 시퀀스)            │
│    ├── member-0000000002  ──► Follower (watch: 0001)          │
│    └── member-0000000003  ──► Follower (watch: 0002)          │
│                                                                 │
│  선출 과정:                                                     │
│  ───────────                                                   │
│                                                                 │
│    1. 각 노드가 EPHEMERAL_SEQUENTIAL 노드 생성                 │
│    2. 자신의 시퀀스 번호가 가장 작으면 리더                     │
│    3. 아니면 바로 앞 번호 노드를 watch                         │
│    4. watch 대상 노드 삭제 시 다시 확인                        │
│                                                                 │
│  장애 복구 시나리오:                                           │
│  ──────────────────                                            │
│                                                                 │
│    Before:                       After (Leader 장애):          │
│    ────────                      ──────────────────            │
│                                                                 │
│    member-0001 (Leader)          member-0001 X (세션 만료)    │
│         │                                                      │
│         ▼                        member-0002 ──► New Leader   │
│    member-0002 (watching 0001)        │                        │
│         │                             ▼                        │
│         ▼                        member-0003 (watching 0002)  │
│    member-0003 (watching 0002)                                 │
│                                                                 │
│    EPHEMERAL 노드는 세션 종료 시 자동 삭제                     │
│    → 자동으로 리더 재선출                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3 Fencing Token

분산 락에서 발생할 수 있는 문제를 해결하기 위한 기법입니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    Fencing Token 문제와 해결                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  문제 시나리오 (Fencing Token 없음):                           │
│  ─────────────────────────────────                             │
│                                                                 │
│    Client A          Lock Service         Storage              │
│       │                   │                  │                 │
│       │── acquire lock ──►│                  │                 │
│       │◄── lock granted ──│                  │                 │
│       │                   │                  │                 │
│       │   (GC pause로     │                  │                 │
│       │    락 만료됨)     │                  │                 │
│       │                   │                  │                 │
│       │              Client B                │                 │
│       │                   │── acquire lock ──►                 │
│       │                   │◄── lock granted ──                 │
│       │                   │                  │                 │
│       │                   │── write(B) ─────►│                 │
│       │                   │                  │                 │
│       │── write(A) ──────────────────────────►  ← 잘못된 쓰기!│
│       │                   │                  │                 │
│                                                                 │
│  해결책 (Fencing Token 사용):                                  │
│  ─────────────────────────                                     │
│                                                                 │
│    Client A          Lock Service         Storage              │
│       │                   │                  │                 │
│       │── acquire lock ──►│                  │                 │
│       │◄── token=33 ──────│                  │                 │
│       │                   │                  │                 │
│       │   (GC pause)      │                  │                 │
│       │                   │                  │                 │
│       │              Client B                │                 │
│       │                   │── acquire lock ──►                 │
│       │                   │◄── token=34 ──────                 │
│       │                   │                  │                 │
│       │                   │── write(token=34)►                 │
│       │                   │         last_token=34              │
│       │                   │                  │                 │
│       │── write(token=33)────────────────────►                 │
│       │         33 < 34 → REJECTED!          │                 │
│       │                   │                  │                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. 장애 허용과 복구

### 5.1 장애 유형

```
┌─────────────────────────────────────────────────────────────────┐
│                      분산 시스템 장애 유형                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Crash Failure (충돌 장애)                                  │
│  ─────────────────────────────                                 │
│     노드가 완전히 멈추고 응답하지 않음                          │
│                                                                 │
│     ┌─────────┐                  ┌─────────┐                   │
│     │ Node A  │ ─── request ───► │ Node B  │                   │
│     └─────────┘                  └────X────┘                   │
│                                    (crashed)                   │
│                                                                 │
│  2. Omission Failure (누락 장애)                               │
│  ───────────────────────────────                               │
│     메시지 송수신 실패                                          │
│                                                                 │
│     ┌─────────┐                  ┌─────────┐                   │
│     │ Node A  │ ─── request ──X  │ Node B  │                   │
│     └─────────┘     (dropped)    └─────────┘                   │
│                                                                 │
│  3. Timing Failure (타이밍 장애)                               │
│  ───────────────────────────────                               │
│     응답이 예상 시간 내에 도착하지 않음                         │
│                                                                 │
│     ┌─────────┐                  ┌─────────┐                   │
│     │ Node A  │ ─── request ───► │ Node B  │                   │
│     └─────────┘                  └─────────┘                   │
│         │                             │                        │
│         │◄────── response ────────────│                        │
│         │        (too late!)          │                        │
│                                                                 │
│  4. Byzantine Failure (비잔틴 장애)                            │
│  ─────────────────────────────────                             │
│     노드가 임의의 잘못된 동작을 함 (악의적 포함)                │
│                                                                 │
│     ┌─────────┐      ┌─────────┐      ┌─────────┐             │
│     │ Node A  │      │ Node B  │      │ Node C  │             │
│     └────┬────┘      └────┬────┘      └────┬────┘             │
│          │                │                │                   │
│          │   "값은 5"     │   "값은 7"     │   값은 뭐지?     │
│          └───────────────►│◄──────────────┘                   │
│               (거짓말!)     (Byzantine)                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 장애 감지 (Failure Detection)

```
┌─────────────────────────────────────────────────────────────────┐
│                      장애 감지 메커니즘                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Heartbeat 기반 감지:                                          │
│  ────────────────────                                          │
│                                                                 │
│      Node A              Monitor              Node B           │
│         │                   │                   │              │
│         │── heartbeat ─────►│                   │              │
│         │                   │◄── heartbeat ────│              │
│         │                   │                   │              │
│         │── heartbeat ─────►│                   │              │
│         │                   │    (timeout!)     │              │
│         │                   │                   X (장애)       │
│         │                   │                   │              │
│         │                   │   Node B 장애로   │              │
│         │                   │   판단           │              │
│                                                                 │
│  ────────────────────────────────────────────────────────────  │
│                                                                 │
│  Gossip 프로토콜 기반 감지:                                    │
│  ─────────────────────────                                     │
│                                                                 │
│    ┌───────┐         ┌───────┐         ┌───────┐              │
│    │Node A │◄───────►│Node B │◄───────►│Node C │              │
│    └───┬───┘         └───┬───┘         └───┬───┘              │
│        │                 │                 │                   │
│        └─────────────────┼─────────────────┘                   │
│                          │                                     │
│                     ┌────┴────┐                                │
│                     │ Node D  │                                │
│                     └─────────┘                                │
│                                                                 │
│    각 노드가 자신의 heartbeat 카운터를 증가                    │
│    주기적으로 랜덤 노드에게 상태 정보 전파                      │
│    카운터가 오랫동안 증가하지 않으면 장애로 판단               │
│                                                                 │
│  ────────────────────────────────────────────────────────────  │
│                                                                 │
│  Phi Accrual Failure Detector:                                 │
│  ─────────────────────────────                                 │
│                                                                 │
│    전통적 방식: 고정 타임아웃 (장애/정상)                       │
│                                                                 │
│    Phi Accrual: 확률적 판단                                    │
│    ┌────────────────────────────────────────────┐              │
│    │  phi = -log10(P_later)                       │              │
│    │                                            │              │
│    │  phi = 1 → 10% 확률로 아직 도착 안 함       │              │
│    │  phi = 2 → 1% 확률로 아직 도착 안 함        │              │
│    │  phi = 8 → 거의 확실히 장애                 │              │
│    └────────────────────────────────────────────┘              │
│                                                                 │
│    Cassandra, Akka 등에서 사용                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.3 복제 전략 (Replication Strategies)

```
┌─────────────────────────────────────────────────────────────────┐
│                      복제 전략 비교                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 동기식 복제 (Synchronous)                                  │
│  ────────────────────────────                                  │
│                                                                 │
│      Client         Primary        Replica 1      Replica 2   │
│         │              │              │              │         │
│         │── write ────►│              │              │         │
│         │              │── replicate ►│              │         │
│         │              │── replicate ────────────────►         │
│         │              │              │              │         │
│         │              │◄──── ACK ────│              │         │
│         │              │◄──── ACK ────────────────────│        │
│         │◄──── OK ─────│              │              │         │
│         │              │              │              │         │
│                                                                 │
│      장점: 강한 일관성                                         │
│      단점: 높은 지연시간, 가용성 저하                          │
│                                                                 │
│  2. 비동기식 복제 (Asynchronous)                               │
│  ───────────────────────────────                               │
│                                                                 │
│      Client         Primary        Replica 1      Replica 2   │
│         │              │              │              │         │
│         │── write ────►│              │              │         │
│         │◄──── OK ─────│              │              │         │
│         │              │              │              │         │
│         │              │── replicate ►│              │         │
│         │              │── replicate ────────────────►         │
│         │              │              │              │         │
│                                                                 │
│      장점: 낮은 지연시간, 높은 가용성                          │
│      단점: 데이터 손실 가능, 최종 일관성                       │
│                                                                 │
│  3. 반동기식 복제 (Semi-synchronous)                           │
│  ───────────────────────────────────                           │
│                                                                 │
│      Client         Primary        Replica 1      Replica 2   │
│         │              │              │              │         │
│         │── write ────►│              │              │         │
│         │              │── replicate ►│              │         │
│         │              │── replicate ────────────────►         │
│         │              │              │              │         │
│         │              │◄──── ACK ────│              │         │
│         │◄──── OK ─────│              │ (1개만 확인) │         │
│         │              │              │              │         │
│                                                                 │
│      중간 수준의 일관성과 성능 절충                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.4 장애 복구 패턴

```
┌─────────────────────────────────────────────────────────────────┐
│                      장애 복구 패턴                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Checkpoint & Recovery                                      │
│  ────────────────────────                                      │
│                                                                 │
│    시간 ──────────────────────────────────────────────────►    │
│                                                                 │
│    State: S1 ───► S2 ───► S3 ───► S4 ───► S5                  │
│             │            │             X (장애)               │
│             ▼            ▼                                     │
│         [Checkpoint1] [Checkpoint2]                           │
│                          │                                     │
│                          ▼                                     │
│                     복구: S3부터 재시작                        │
│                                                                 │
│  2. Write-Ahead Logging (WAL)                                  │
│  ────────────────────────────                                  │
│                                                                 │
│    ┌─────────────────────────────────────────┐                │
│    │              WAL (로그 파일)             │                │
│    │  ┌─────┬─────┬─────┬─────┬─────┬─────┐ │                │
│    │  │ Op1 │ Op2 │ Op3 │ Op4 │ Op5 │ ... │ │                │
│    │  └─────┴─────┴─────┴─────┴─────┴─────┘ │                │
│    └───────────────────┬─────────────────────┘                │
│                        │                                       │
│                        ▼                                       │
│                 장애 후 로그 재생                               │
│                 (Redo/Undo)                                    │
│                                                                 │
│  3. Circuit Breaker 패턴                                       │
│  ────────────────────────                                      │
│                                                                 │
│    ┌─────────┐       ┌─────────┐       ┌─────────┐            │
│    │ CLOSED  │──────►│  OPEN   │──────►│HALF-OPEN│            │
│    │(정상)   │ 실패  │(차단)   │ 타임  │(테스트) │            │
│    └────┬────┘ 임계  └─────────┘ 아웃  └────┬────┘            │
│         │      초과        ▲                 │                 │
│         │                  │                 │                 │
│         │                  └─── 실패 ────────┘                 │
│         │                                    │                 │
│         └──────────────── 성공 ──────────────┘                 │
│                                                                 │
│    CLOSED: 요청 정상 전달                                      │
│    OPEN: 요청 즉시 실패 처리 (빠른 실패)                       │
│    HALF-OPEN: 일부 요청만 테스트 전달                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.5 데이터 복구 기법

```
┌─────────────────────────────────────────────────────────────────┐
│                      데이터 복구 기법                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Read Repair                                                │
│  ───────────────                                               │
│                                                                 │
│    읽기 시 불일치 데이터 발견 → 자동 복구                       │
│                                                                 │
│      Client         Node A         Node B         Node C      │
│         │              │              │              │         │
│         │── read ─────►│              │              │         │
│         │── read ──────────────────►│              │         │
│         │── read ─────────────────────────────────►│         │
│         │              │              │              │         │
│         │◄─ v2 ────────│              │              │         │
│         │◄─ v1 (오래됨)────────────────│              │         │
│         │◄─ v2 ────────────────────────────────────│         │
│         │              │              │              │         │
│         │              │    repair    │              │         │
│         │              │─────────────►│   v1 → v2   │         │
│         │              │              │              │         │
│                                                                 │
│  2. Anti-Entropy (Merkle Tree)                                 │
│  ─────────────────────────────                                 │
│                                                                 │
│    백그라운드에서 데이터 동기화                                 │
│                                                                 │
│         Node A                      Node B                     │
│    ┌──────────────┐            ┌──────────────┐               │
│    │  Root: ABC   │            │  Root: ABD   │               │
│    │     / \      │            │     / \      │               │
│    │   AB   C     │            │   AB   D     │   ← 불일치!  │
│    │   /\         │            │   /\         │               │
│    │  A  B        │            │  A  B        │               │
│    └──────────────┘            └──────────────┘               │
│                                                                 │
│    Root 해시 비교 → 다르면 하위 비교 → 변경된 데이터만 동기화  │
│                                                                 │
│  3. Hinted Handoff                                             │
│  ─────────────────                                             │
│                                                                 │
│    장애 노드 대신 다른 노드가 임시 저장                         │
│                                                                 │
│      Client         Node A         Node B(장애)   Node C      │
│         │              │              X              │         │
│         │── write ────►│              X              │         │
│         │              │              X              │         │
│         │              │── hint 저장 ───────────────►│         │
│         │              │              │              │         │
│         │              │         (Node B 복구)       │         │
│         │              │              │              │         │
│         │              │              │◄─ hint 전달─│         │
│         │              │              │              │         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.6 Quorum 기반 일관성

```
┌─────────────────────────────────────────────────────────────────┐
│                    Quorum 기반 읽기/쓰기                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  N = 전체 복제본 수                                            │
│  W = 쓰기 쿼럼 (쓰기 성공에 필요한 최소 응답 수)               │
│  R = 읽기 쿼럼 (읽기 성공에 필요한 최소 응답 수)               │
│                                                                 │
│  강한 일관성 조건: W + R > N                                   │
│                                                                 │
│  예시 (N=3):                                                   │
│  ────────────                                                  │
│                                                                 │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                        │
│  │ Replica │  │ Replica │  │ Replica │                        │
│  │    1    │  │    2    │  │    3    │                        │
│  └────┬────┘  └────┬────┘  └────┬────┘                        │
│       │            │            │                              │
│       ▼            ▼            ▼                              │
│                                                                 │
│  W=2, R=2 설정 시:                                             │
│                                                                 │
│  쓰기:                         읽기:                           │
│  ┌───┐                        ┌───┐                           │
│  │ W │─────► R1 (성공)        │ R │─────► R1 (v2)             │
│  │ r │─────► R2 (성공)        │ e │─────► R2 (v2)             │
│  │ i │─────► R3 (실패/느림)   │ a │─────► R3 (응답 대기 안함) │
│  │ t │       │                │ d │       │                   │
│  │ e │       │                │   │       │                   │
│  └───┘       │                └───┘       │                   │
│       2개 성공 → OK               2개 응답 → 최신 값 반환      │
│                                                                 │
│  W + R = 4 > 3 (N) → 강한 일관성 보장                          │
│                                                                 │
│  ────────────────────────────────────────────────────────────  │
│                                                                 │
│  설정별 특성:                                                   │
│  │ 설정        │ 특성                                          │
│  │ W=1, R=N   │ 빠른 쓰기, 느린 읽기                           │
│  │ W=N, R=1   │ 느린 쓰기, 빠른 읽기                           │
│  │ W=R=N/2+1  │ 균형 잡힌 설정                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 요약

### 핵심 개념 정리

| 주제 | 핵심 내용 |
|------|----------|
| **CAP 정리** | 일관성, 가용성, 분할 내성 중 2가지만 보장 가능 |
| **Paxos** | 다중 제안자 지원, 복잡하지만 강력한 합의 알고리즘 |
| **Raft** | 이해하기 쉬운 합의 알고리즘, 강한 리더 기반 |
| **2PC/3PC** | 분산 트랜잭션을 위한 원자적 커밋 프로토콜 |
| **Saga** | 보상 트랜잭션 기반의 장기 실행 트랜잭션 패턴 |
| **분산 락** | Redis(Redlock), ZooKeeper를 통한 상호 배제 구현 |
| **리더 선출** | Bully, Ring, ZooKeeper 기반 선출 알고리즘 |
| **장애 허용** | 복제, Heartbeat, Circuit Breaker 등의 기법 |

### 실무 적용 가이드

```
┌─────────────────────────────────────────────────────────────────┐
│                    기술 선택 가이드                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  분산 조정이 필요할 때:                                        │
│  - ZooKeeper: 강한 일관성, 리더 선출, 설정 관리                │
│  - etcd: Kubernetes 환경, Raft 기반                           │
│  - Consul: 서비스 디스커버리 + 분산 조정                       │
│                                                                 │
│  분산 락이 필요할 때:                                          │
│  - Redis (Redlock): 높은 성능, 적당한 일관성                   │
│  - ZooKeeper: 강한 일관성, 순서 보장                          │
│                                                                 │
│  분산 트랜잭션이 필요할 때:                                    │
│  - 2PC: 짧은 트랜잭션, 강한 일관성 필요                        │
│  - Saga: 장시간 트랜잭션, 마이크로서비스 환경                  │
│                                                                 │
│  장애 허용이 필요할 때:                                        │
│  - Circuit Breaker: Resilience4j, Hystrix                     │
│  - 복제: Primary-Replica, Multi-Primary                        │
│  - 백업: 정기적 스냅샷 + WAL                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 참고 자료

- [Designing Data-Intensive Applications](https://dataintensive.net/) - Martin Kleppmann
- [Raft Consensus Algorithm](https://raft.github.io/)
- [Paxos Made Simple](https://lamport.azurewebsites.net/pubs/paxos-simple.pdf) - Leslie Lamport
- [ZooKeeper Documentation](https://zookeeper.apache.org/doc/current/)
- [Redis Distributed Locks](https://redis.io/topics/distlock)
- [The Part-Time Parliament](https://lamport.azurewebsites.net/pubs/lamport-paxos.pdf) - Leslie Lamport (원본 Paxos 논문)
- [In Search of an Understandable Consensus Algorithm](https://raft.github.io/raft.pdf) - Raft 논문

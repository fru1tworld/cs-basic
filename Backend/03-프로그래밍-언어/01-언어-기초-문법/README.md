# í”„ë¡œê·¸ë˜ë° ì–¸ì–´ ë¬¸ë²•

## ëª©ì°¨
1. [íƒ€ì… ì‹œìŠ¤í…œ](#1-íƒ€ì…-ì‹œìŠ¤í…œ)
2. [ë©”ëª¨ë¦¬ ëª¨ë¸](#2-ë©”ëª¨ë¦¬-ëª¨ë¸)
3. [ê°€ë¹„ì§€ ì»¬ë ‰ì…˜](#3-ê°€ë¹„ì§€-ì»¬ë ‰ì…˜)
4. [ì»´íŒŒì¼ vs ì¸í„°í”„ë¦¬í„°](#4-ì»´íŒŒì¼-vs-ì¸í„°í”„ë¦¬í„°)
---

## 1. íƒ€ì… ì‹œìŠ¤í…œ

### 1.1 Static vs Dynamic Typing

#### Static Typing (ì •ì  íƒ€ì…)
ì»´íŒŒì¼ íƒ€ì„ì— ë³€ìˆ˜ì˜ íƒ€ì…ì´ ê²°ì •ë˜ë©°, íƒ€ì… ë¶ˆì¼ì¹˜ ì‹œ ì»´íŒŒì¼ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.

```java
// Java - ì •ì  íƒ€ì… ì–¸ì–´
public class StaticTypingExample {
    public static void main(String[] args) {
        String name = "John";
        int age = 25;

        // ì»´íŒŒì¼ ì—ëŸ¬: incompatible types
        // age = "twenty-five";

        // ì œë„¤ë¦­ì„ í†µí•œ íƒ€ì… ì•ˆì •ì„±
        List<String> names = new ArrayList<>();
        names.add("Alice");
        // names.add(123); // ì»´íŒŒì¼ ì—ëŸ¬
    }
}
```

```go
// Go - ì •ì  íƒ€ì… + íƒ€ì… ì¶”ë¡ 
package main

func main() {
    // íƒ€ì… ì¶”ë¡  (ì»´íŒŒì¼ íƒ€ì„ì— íƒ€ì… ê²°ì •)
    name := "John"  // stringìœ¼ë¡œ ì¶”ë¡ 
    age := 25       // intë¡œ ì¶”ë¡ 

    // ëª…ì‹œì  íƒ€ì… ì„ ì–¸
    var salary float64 = 50000.0

    // ì»´íŒŒì¼ ì—ëŸ¬: cannot use "25" (type string) as type int
    // age = "25"
}
```

**ì¥ì :**
- ì»´íŒŒì¼ íƒ€ì„ì— íƒ€ì… ì—ëŸ¬ ë°œê²¬
- IDE ìë™ì™„ì„± ë° ë¦¬íŒ©í† ë§ ì§€ì›
- ëŸ°íƒ€ì„ ì„±ëŠ¥ ìµœì í™” ê°€ëŠ¥
- ì½”ë“œ ë¬¸ì„œí™” íš¨ê³¼

**ë‹¨ì :**
- ì½”ë“œ ì‘ì„± ì‹œ boilerplate ì¦ê°€
- ìœ ì—°ì„± ê°ì†Œ (ë™ì  êµ¬ì¡° ì²˜ë¦¬ ì–´ë ¤ì›€)

#### Dynamic Typing (ë™ì  íƒ€ì…)
ëŸ°íƒ€ì„ì— ë³€ìˆ˜ì˜ íƒ€ì…ì´ ê²°ì •ë˜ë©°, ê°™ì€ ë³€ìˆ˜ì— ë‹¤ë¥¸ íƒ€ì…ì˜ ê°’ì„ í• ë‹¹í•  ìˆ˜ ìˆë‹¤.

```python
# Python - ë™ì  íƒ€ì… ì–¸ì–´
def dynamic_example():
    value = "Hello"  # str
    print(type(value))  # <class 'str'>

    value = 42  # intë¡œ ë³€ê²½
    print(type(value))  # <class 'int'>

    value = [1, 2, 3]  # listë¡œ ë³€ê²½
    print(type(value))  # <class 'list'>

# Duck Typing ì˜ˆì œ
class Duck:
    def quack(self):
        print("Quack!")

    def walk(self):
        print("Walking like a duck")

class Person:
    def quack(self):
        print("I'm quacking like a duck!")

    def walk(self):
        print("Walking like a person")

def make_it_quack(thing):
    # íƒ€ì…ì„ ê²€ì‚¬í•˜ì§€ ì•Šê³  ë©”ì„œë“œë§Œ í˜¸ì¶œ
    thing.quack()
    thing.walk()

make_it_quack(Duck())    # OK
make_it_quack(Person())  # OK - Duckì´ ì•„ë‹ˆì–´ë„ ë™ì‘
```

**ì¥ì :**
- ë¹ ë¥¸ í”„ë¡œí† íƒ€ì´í•‘
- ì½”ë“œ ê°„ê²°ì„±
- ìœ ì—°í•œ ë‹¤í˜•ì„± (Duck Typing)

**ë‹¨ì :**
- ëŸ°íƒ€ì„ ì—ëŸ¬ ë°œìƒ ê°€ëŠ¥
- ë¦¬íŒ©í† ë§ ì–´ë ¤ì›€
- ëŒ€ê·œëª¨ í”„ë¡œì íŠ¸ì—ì„œ ìœ ì§€ë³´ìˆ˜ ë¹„ìš© ì¦ê°€

### 1.2 Strong vs Weak Typing

#### Strong Typing (ê°•íƒ€ì…)
ì•”ë¬µì  íƒ€ì… ë³€í™˜ì„ í—ˆìš©í•˜ì§€ ì•Šê±°ë‚˜ ë§¤ìš° ì œí•œì ìœ¼ë¡œ í—ˆìš©í•œë‹¤.

```python
# Python - ê°•íƒ€ì… ì–¸ì–´
number = 42
text = "The answer is: "

# TypeError: can only concatenate str (not "int") to str
# result = text + number

# ëª…ì‹œì  ë³€í™˜ í•„ìš”
result = text + str(number)  # OK
```

```java
// Java - ê°•íƒ€ì… (ì¼ë¶€ ì•”ë¬µì  ë³€í™˜ í—ˆìš©)
public class StrongTyping {
    public static void main(String[] args) {
        int intValue = 42;
        long longValue = intValue;  // OK - í™•ì¥ ë³€í™˜ (Widening)

        long bigValue = 100L;
        // int smallValue = bigValue;  // ì»´íŒŒì¼ ì—ëŸ¬ - ì¶•ì†Œ ë³€í™˜ ë¶ˆê°€
        int smallValue = (int) bigValue;  // ëª…ì‹œì  ìºìŠ¤íŒ… í•„ìš”

        String text = "Number: " + intValue;  // OK - ë¬¸ìì—´ ì—°ê²° ì‹œ ìë™ ë³€í™˜
    }
}
```

#### Weak Typing (ì•½íƒ€ì…)
ì•”ë¬µì  íƒ€ì… ë³€í™˜ì„ ììœ ë¡­ê²Œ í—ˆìš©í•œë‹¤.

```javascript
// JavaScript - ì•½íƒ€ì… ì–¸ì–´
console.log("5" + 3);      // "53" (ë¬¸ìì—´ ì—°ê²°)
console.log("5" - 3);      // 2 (ìˆ«ì ì—°ì‚°)
console.log("5" * "2");    // 10 (ìˆ«ì ì—°ì‚°)
console.log(true + true);  // 2
console.log([] + {});      // "[object Object]"
console.log({} + []);      // 0 ë˜ëŠ” "[object Object]" (í™˜ê²½ì— ë”°ë¼ ë‹¤ë¦„)

// ë™ë“± ì—°ì‚°ìì˜ íƒ€ì… ê°•ì œ ë³€í™˜
console.log("5" == 5);     // true (íƒ€ì… ê°•ì œ ë³€í™˜)
console.log("5" === 5);    // false (ì—„ê²©í•œ ë¹„êµ)
console.log(null == undefined);  // true
console.log(null === undefined); // false
```

### 1.3 íƒ€ì… ì‹œìŠ¤í…œ ë¹„êµí‘œ

| ì–¸ì–´ | íƒ€ì… ê²€ì‚¬ ì‹œì  | íƒ€ì… ê°•ë„ | íŠ¹ì§• |
|------|---------------|----------|------|
| Java | ì •ì  | ê°•íƒ€ì… | ì œë„¤ë¦­, ëª…ì‹œì  íƒ€ì… ì„ ì–¸ |
| Python | ë™ì  | ê°•íƒ€ì… | Duck Typing, Type Hints(3.5+) |
| Go | ì •ì  | ê°•íƒ€ì… | íƒ€ì… ì¶”ë¡ , ì¸í„°í˜ì´ìŠ¤ |
| JavaScript | ë™ì  | ì•½íƒ€ì… | íƒ€ì… ê°•ì œ ë³€í™˜, TypeScriptë¡œ ë³´ì™„ |
| C | ì •ì  | ì•½íƒ€ì… | í¬ì¸í„° ìºìŠ¤íŒ…, ì•”ë¬µì  ë³€í™˜ |
| Rust | ì •ì  | ê°•íƒ€ì… | ì†Œìœ ê¶Œ ì‹œìŠ¤í…œ, ì œë¡œ ì½”ìŠ¤íŠ¸ ì¶”ìƒí™” |

---

## 2. ë©”ëª¨ë¦¬ ëª¨ë¸

### 2.1 Stack vs Heap

#### Stack ë©”ëª¨ë¦¬

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Stack Memory              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚    Function Call Frame      â”‚   â”‚  â† Top (SP: Stack Pointer)
â”‚  â”‚  - Local Variables          â”‚   â”‚
â”‚  â”‚  - Return Address           â”‚   â”‚
â”‚  â”‚  - Parameters               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   Previous Function Frame   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚             ...                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚      Main Function Frame    â”‚   â”‚  â† Bottom
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†‘ ì„±ì¥ ë°©í–¥ (ë†’ì€ ì£¼ì†Œ â†’ ë‚®ì€ ì£¼ì†Œ)
```

**íŠ¹ì§•:**
- LIFO (Last In First Out) êµ¬ì¡°
- ì»´íŒŒì¼ íƒ€ì„ì— í¬ê¸°ê°€ ê²°ì •ë¨
- ë§¤ìš° ë¹ ë¥¸ í• ë‹¹/í•´ì œ (í¬ì¸í„° ì´ë™ë§Œìœ¼ë¡œ ê°€ëŠ¥)
- í•¨ìˆ˜ í˜¸ì¶œ ì‹œ ìë™ ìƒì„±, ë°˜í™˜ ì‹œ ìë™ í•´ì œ
- í¬ê¸° ì œí•œ ìˆìŒ (ì¼ë°˜ì ìœ¼ë¡œ 1~8MB)

```java
// Java - Stackì— ì €ì¥ë˜ëŠ” ë°ì´í„°
public class StackExample {
    public static void main(String[] args) {
        int x = 10;           // Stack: primitive
        double y = 20.5;      // Stack: primitive

        calculate(x, y);      // ìƒˆ Stack Frame ìƒì„±
    }

    public static double calculate(int a, double b) {
        int result = a * 2;   // Stack: ì§€ì—­ ë³€ìˆ˜
        return result + b;
    }  // í•¨ìˆ˜ ì¢…ë£Œ ì‹œ Stack Frame ì œê±°
}
```

```c
// C - Stackê³¼ í•¨ìˆ˜ í˜¸ì¶œ
#include <stdio.h>

void recursive(int n) {
    int local_array[1000];  // Stackì— 4KB í• ë‹¹
    printf("Depth: %d, Address: %p\n", n, (void*)&local_array);

    if (n > 0) {
        recursive(n - 1);  // Stack ê³„ì† ì„±ì¥
    }
}

int main() {
    recursive(10);  // Stack Overflow ê°€ëŠ¥
    return 0;
}
```

#### Heap ë©”ëª¨ë¦¬

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Heap Memory               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚Object1â”‚  â”‚  Object2  â”‚          â”‚
â”‚  â”‚ 100B  â”‚  â”‚   500B    â”‚  Free    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚       â”‚   Object3   â”‚    Free      â”‚
â”‚       â”‚    1KB      â”‚              â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                 Free Space          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ ì„±ì¥ ë°©í–¥ (ë‚®ì€ ì£¼ì†Œ â†’ ë†’ì€ ì£¼ì†Œ)
```

**íŠ¹ì§•:**
- ë™ì  ë©”ëª¨ë¦¬ í• ë‹¹
- ëŸ°íƒ€ì„ì— í¬ê¸° ê²°ì • ê°€ëŠ¥
- í”„ë¡œê·¸ë˜ë¨¸ ë˜ëŠ” GCê°€ ëª…ì‹œì ìœ¼ë¡œ ê´€ë¦¬
- Stackë³´ë‹¤ ëŠë¦° í• ë‹¹/í•´ì œ
- ë‹¨í¸í™”(Fragmentation) ë°œìƒ ê°€ëŠ¥

```java
// Java - Heapì— ì €ì¥ë˜ëŠ” ë°ì´í„°
public class HeapExample {
    public static void main(String[] args) {
        // ê°ì²´ëŠ” Heapì— ì €ì¥, ì°¸ì¡°ëŠ” Stackì— ì €ì¥
        String name = new String("Hello");  // Heap: "Hello" ê°ì²´
        int[] array = new int[1000];        // Heap: ë°°ì—´ ê°ì²´

        Person person = new Person("John", 25);  // Heap: Person ê°ì²´

        // Stack: name, array, person (ì°¸ì¡° ë³€ìˆ˜ë“¤)
        // Heap: String ê°ì²´, int[] ê°ì²´, Person ê°ì²´
    }
}

class Person {
    private String name;  // Heap ë‚´ ê°ì²´ì˜ í•„ë“œ
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

```go
// Go - Escape Analysis
package main

// ì»´íŒŒì¼ëŸ¬ê°€ ìŠ¤íƒ vs í™ í• ë‹¹ì„ ê²°ì •
func stackAllocation() int {
    x := 42  // ìŠ¤íƒì— í• ë‹¹ (í•¨ìˆ˜ ë‚´ì—ì„œë§Œ ì‚¬ìš©)
    return x
}

func heapAllocation() *int {
    x := 42   // í™ì— í• ë‹¹ (í•¨ìˆ˜ ì™¸ë¶€ë¡œ escape)
    return &x // ì£¼ì†Œë¥¼ ë°˜í™˜í•˜ë¯€ë¡œ í™ í• ë‹¹
}

// go build -gcflags="-m" ìœ¼ë¡œ escape analysis í™•ì¸ ê°€ëŠ¥
```

### 2.2 ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  High Address
â”‚           Kernel Space              â”‚  (ìš´ì˜ì²´ì œ ì˜ì—­)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              Stack                  â”‚  â†“ ì„±ì¥
â”‚         (ì§€ì—­ ë³€ìˆ˜, ë§¤ê°œë³€ìˆ˜)          â”‚
â”œ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€â”¤
â”‚                                     â”‚
â”‚         (ì‚¬ìš© ê°€ëŠ¥ ê³µê°„)              â”‚
â”‚                                     â”‚
â”œ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€â”¤
â”‚              Heap                   â”‚  â†‘ ì„±ì¥
â”‚          (ë™ì  í• ë‹¹)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         BSS Segment                 â”‚  (ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ì „ì—­/ì •ì  ë³€ìˆ˜)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Data Segment                â”‚  (ì´ˆê¸°í™”ëœ ì „ì—­/ì •ì  ë³€ìˆ˜)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Text Segment                â”‚  (ê¸°ê³„ì–´ ì½”ë“œ, Read-Only)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  Low Address
```

---

## 3. ê°€ë¹„ì§€ ì»¬ë ‰ì…˜

### 3.1 ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°œìš”

ê°€ë¹„ì§€ ì»¬ë ‰ì…˜(GC)ì€ ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ë©”ëª¨ë¦¬ë¥¼ ìë™ìœ¼ë¡œ íšŒìˆ˜í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ì´ë‹¤.

```
ì°¸ì¡° ê°€ëŠ¥í•œ ê°ì²´ (Reachable Objects)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Root Set          Heap Memory
  â”Œâ”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”    â”Œâ”€â”€â”€â”    â”Œâ”€â”€â”€â”
  â”‚Stackâ”‚â”€â”€â”€â”€â–¶â”‚ A â”‚â”€â”€â”€â–¶â”‚ B â”‚â”€â”€â”€â–¶â”‚ C â”‚  â† Live Objects
  â”‚ Var â”‚     â””â”€â”€â”€â”˜    â””â”€â”€â”€â”˜    â””â”€â”€â”€â”˜
  â””â”€â”€â”€â”€â”€â”˜
  â”Œâ”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”
  â”‚Staticâ”‚â”€â”€â”€â–¶â”‚ D â”‚  â† Live Object
  â”‚ Var â”‚     â””â”€â”€â”€â”˜
  â””â”€â”€â”€â”€â”€â”˜
                â”Œâ”€â”€â”€â”    â”Œâ”€â”€â”€â”
                â”‚ E â”‚â”€â”€â”€â–¶â”‚ F â”‚  â† Garbage (Unreachable)
                â””â”€â”€â”€â”˜    â””â”€â”€â”€â”˜
```

### 3.2 Mark-and-Sweep ì•Œê³ ë¦¬ì¦˜

#### Phase 1: Mark (ë§ˆí‚¹)
Root Setì—ì„œ ì‹œì‘í•˜ì—¬ ë„ë‹¬ ê°€ëŠ¥í•œ ëª¨ë“  ê°ì²´ë¥¼ ë§ˆí‚¹í•œë‹¤.

```
Mark Phase:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Root Set          Heap Memory
  â”Œâ”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”    â”Œâ”€â”€â”€â”    â”Œâ”€â”€â”€â”
  â”‚Stackâ”‚â”€â”€â”€â”€â–¶â”‚ A â”‚â”€â”€â”€â–¶â”‚ B â”‚â”€â”€â”€â–¶â”‚ C â”‚
  â”‚ Var â”‚     â”‚ âœ“ â”‚    â”‚ âœ“ â”‚    â”‚ âœ“ â”‚  â† Marked
  â””â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”˜    â””â”€â”€â”€â”˜    â””â”€â”€â”€â”˜

                â”Œâ”€â”€â”€â”    â”Œâ”€â”€â”€â”
                â”‚ E â”‚â”€â”€â”€â–¶â”‚ F â”‚
                â”‚   â”‚    â”‚   â”‚  â† Unmarked
                â””â”€â”€â”€â”˜    â””â”€â”€â”€â”˜
```

#### Phase 2: Sweep (ìŠ¤ìœ•)
ë§ˆí‚¹ë˜ì§€ ì•Šì€ ê°ì²´ë¥¼ ë©”ëª¨ë¦¬ì—ì„œ í•´ì œí•œë‹¤.

```
Sweep Phase:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Heap Memory (After Sweep)
  â”Œâ”€â”€â”€â”    â”Œâ”€â”€â”€â”    â”Œâ”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”
  â”‚ A â”‚    â”‚ B â”‚    â”‚ C â”‚    â”‚ Free  â”‚    â”‚ Free  â”‚
  â””â”€â”€â”€â”˜    â””â”€â”€â”€â”˜    â””â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”˜
                              (was E)      (was F)
```

```java
// Mark-and-Sweep ì˜ì‚¬ ì½”ë“œ
public class MarkAndSweep {
    private Set<Object> marked = new HashSet<>();

    // Mark Phase
    public void mark(Object root) {
        if (root == null || marked.contains(root)) {
            return;
        }
        marked.add(root);

        // ê°ì²´ê°€ ì°¸ì¡°í•˜ëŠ” ëª¨ë“  ê°ì²´ë¥¼ ì¬ê·€ì ìœ¼ë¡œ ë§ˆí‚¹
        for (Object reference : getReferences(root)) {
            mark(reference);
        }
    }

    // Sweep Phase
    public void sweep(List<Object> allObjects) {
        Iterator<Object> iterator = allObjects.iterator();
        while (iterator.hasNext()) {
            Object obj = iterator.next();
            if (!marked.contains(obj)) {
                // ë§ˆí‚¹ë˜ì§€ ì•Šì€ ê°ì²´ í•´ì œ
                free(obj);
                iterator.remove();
            }
        }
        marked.clear();  // ë‹¤ìŒ GC ì‚¬ì´í´ì„ ìœ„í•´ ì´ˆê¸°í™”
    }
}
```

**ë‹¨ì :**
- Stop-the-World: GC ì‹¤í–‰ ì¤‘ ì• í”Œë¦¬ì¼€ì´ì…˜ ì¼ì‹œ ì •ì§€
- ë©”ëª¨ë¦¬ ë‹¨í¸í™”: ì—°ì†ì ì´ì§€ ì•Šì€ ë¹ˆ ê³µê°„ ë°œìƒ
- ì „ì²´ Heap ìŠ¤ìº” í•„ìš”

### 3.3 Mark-and-Compact ì•Œê³ ë¦¬ì¦˜

Mark-and-Sweepì˜ ë‹¨í¸í™” ë¬¸ì œë¥¼ í•´ê²°í•œë‹¤.

```
Before Compaction:
â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”€â”
â”‚ A â”‚ â”‚Freeâ”‚ â”‚ B â”‚ â”‚Freeâ”‚ â”‚ C â”‚ â”‚Freeâ”‚
â””â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜

After Compaction:
â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ A â”‚ â”‚ B â”‚ â”‚ C â”‚ â”‚       Free         â”‚
â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.4 Generational GC (ì„¸ëŒ€ë³„ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜)

**ì•½í•œ ì„¸ëŒ€ ê°€ì„¤ (Weak Generational Hypothesis):**
- ëŒ€ë¶€ë¶„ì˜ ê°ì²´ëŠ” ìƒì„± ì§í›„ ê³§ë°”ë¡œ ì‚¬ìš©ë˜ì§€ ì•Šê²Œ ëœë‹¤ (Young Die Young)
- ì˜¤ë˜ëœ ê°ì²´ê°€ ìƒˆë¡œìš´ ê°ì²´ë¥¼ ì°¸ì¡°í•˜ëŠ” ê²½ìš°ëŠ” ë“œë¬¼ë‹¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Heap Memory                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      Young Generation â”‚         Old Generation           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                  â”‚
â”‚  Eden   â”‚  Survivor   â”‚        Tenured Space             â”‚
â”‚  Space  â”‚  S0  â”‚  S1  â”‚                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  80%    â”‚ 10%  â”‚ 10%  â”‚                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ê°ì²´ ìƒì„± â†’ Eden â†’ (ì‚´ì•„ë‚¨ìŒ) â†’ Survivor â†’ (ë‚˜ì´ ì¦ê°€) â†’ Old Gen
```

#### JVMì˜ ì„¸ëŒ€ë³„ GC

```java
// JVM GC ë™ì‘ ì´í•´ë¥¼ ìœ„í•œ ì˜ˆì œ
public class GenerationalGCExample {
    public static void main(String[] args) {
        // 1. ìƒˆ ê°ì²´ëŠ” Edenì— í• ë‹¹
        Object shortLived = new Object();  // Eden

        // 2. ì§§ì€ ìˆ˜ëª… ê°ì²´ëŠ” Minor GCì—ì„œ ìˆ˜ì§‘
        shortLived = null;

        // 3. ì˜¤ë˜ ì‚´ì•„ë‚¨ëŠ” ê°ì²´
        List<byte[]> longLived = new ArrayList<>();
        for (int i = 0; i < 100; i++) {
            // Survivorë¥¼ ê±°ì³ Old Generationìœ¼ë¡œ ì´ë™
            longLived.add(new byte[1024 * 1024]);  // 1MB
        }

        // GC ë¡œê·¸ í™•ì¸: -XX:+PrintGCDetails -XX:+PrintGCDateStamps
    }
}
```

#### GC ì¢…ë¥˜ë³„ ë¹„êµ

| GC ì¢…ë¥˜ | Young Gen GC | Old Gen GC | íŠ¹ì§• |
|---------|--------------|------------|------|
| Serial GC | Serial | Serial Mark-Sweep-Compact | ë‹¨ì¼ ìŠ¤ë ˆë“œ, ì‘ì€ í™ |
| Parallel GC | Parallel Scavenge | Parallel Old | ë©€í‹° ìŠ¤ë ˆë“œ, ì²˜ë¦¬ëŸ‰ ì¤‘ì‹œ |
| CMS | ParNew | Concurrent Mark-Sweep | ë‚®ì€ ì§€ì—°ì‹œê°„ (Deprecated) |
| G1 GC | Mixed GC | Mixed GC | Region ê¸°ë°˜, ê· í˜•ì¡íŒ ì„±ëŠ¥ |
| ZGC | - | Concurrent | ë§¤ìš° ë‚®ì€ ì§€ì—°ì‹œê°„ (<10ms) |
| Shenandoah | - | Concurrent | ë‚®ì€ ì§€ì—°ì‹œê°„ |

### 3.5 G1 GC (Garbage-First GC)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  G1 Heap Layout                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¤
â”‚  E   â”‚  E   â”‚  S   â”‚  O   â”‚  O   â”‚  H   â”‚  E   â”‚ F â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚  O   â”‚  F   â”‚  F   â”‚  O   â”‚  E   â”‚  H   â”‚  S   â”‚ O â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚  F   â”‚  O   â”‚  E   â”‚  F   â”‚  O   â”‚  H   â”‚  O   â”‚ F â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”˜

E: Eden       S: Survivor    O: Old
H: Humongous  F: Free
```

**íŠ¹ì§•:**
- Heapì„ ë™ì¼í•œ í¬ê¸°ì˜ Regionìœ¼ë¡œ ë¶„í• 
- ê°€ë¹„ì§€ê°€ ë§ì€ Regionì„ ìš°ì„  ìˆ˜ì§‘ (Garbage-First)
- ì˜ˆì¸¡ ê°€ëŠ¥í•œ ì¼ì‹œ ì •ì§€ ì‹œê°„ (-XX:MaxGCPauseMillis)

```bash
# G1 GC JVM ì˜µì…˜ ì˜ˆì‹œ
java -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=200 \
     -XX:G1HeapRegionSize=16m \
     -XX:InitiatingHeapOccupancyPercent=45 \
     -Xms4g -Xmx4g \
     MyApplication
```

### 3.6 Goì˜ GC

GoëŠ” Tri-color Mark-and-Sweep ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•œë‹¤.

```go
// Go GCëŠ” ë™ì‹œì„± GC (Concurrent GC)
// - STW ì‹œê°„ ìµœì†Œí™” (ë³´í†µ 1ms ë¯¸ë§Œ)
// - Write Barrier ì‚¬ìš©

package main

import (
    "runtime"
    "runtime/debug"
)

func main() {
    // GC í†µê³„ í™•ì¸
    var stats debug.GCStats
    debug.ReadGCStats(&stats)

    // ìˆ˜ë™ GC íŠ¸ë¦¬ê±°
    runtime.GC()

    // GC ë¹„ìœ¨ ì¡°ì • (ê¸°ë³¸ê°’: 100)
    // GOGC=200 ì´ë©´ í™ì´ 2ë°°ê°€ ë  ë•Œ GC
    debug.SetGCPercent(200)
}
```

```
Tri-color Marking:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  âšª White: ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•ŠìŒ (GC ëŒ€ìƒ í›„ë³´)
  âš« Black: ë°©ë¬¸ ì™„ë£Œ, ëª¨ë“  ì°¸ì¡°ë„ ë°©ë¬¸
  ğŸ”˜ Gray:  ë°©ë¬¸í–ˆì§€ë§Œ ì°¸ì¡°ë¥¼ ì•„ì§ ë‹¤ ë°©ë¬¸í•˜ì§€ ì•ŠìŒ

  ì‹œì‘:  ëª¨ë“  ê°ì²´ âšª
  ì§„í–‰:  Root â†’ ğŸ”˜ â†’ âš« (ì°¸ì¡°ëœ ê°ì²´ëŠ” ğŸ”˜ë¡œ)
  ì¢…ë£Œ:  âšª ê°ì²´ë“¤ ìˆ˜ì§‘
```

---

## 4. ì»´íŒŒì¼ vs ì¸í„°í”„ë¦¬í„°

### 4.1 ì»´íŒŒì¼ëŸ¬ (Compiler)

ì†ŒìŠ¤ ì½”ë“œ ì „ì²´ë¥¼ ê¸°ê³„ì–´ë¡œ ë³€í™˜í•œ í›„ ì‹¤í–‰í•œë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Source Code â”‚â”€â”€â”€â–¶â”‚   Compiler   â”‚â”€â”€â”€â–¶â”‚  Machine Codeâ”‚
â”‚   (*.c, *.go)â”‚    â”‚              â”‚    â”‚  (*.exe, bin)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â”‚
                                               â–¼
                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                        â”‚   Execution  â”‚
                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ì»´íŒŒì¼ ê³¼ì •

```
Source Code
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Lexical   â”‚  í† í°í™” (Token)
â”‚  Analysis   â”‚  int x = 42; â†’ [INT, ID(x), ASSIGN, NUM(42), SEMICOLON]
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Syntax    â”‚  êµ¬ë¬¸ ë¶„ì„, AST ìƒì„±
â”‚  Analysis   â”‚  Abstract Syntax Tree
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Semantic   â”‚  íƒ€ì… ê²€ì‚¬, ìŠ¤ì½”í”„ ë¶„ì„
â”‚  Analysis   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Intermediate â”‚  ì¤‘ê°„ í‘œí˜„ (IR) ìƒì„±
â”‚    Code     â”‚  ì˜ˆ: LLVM IR, Java Bytecode
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Optimization â”‚  ìµœì í™” (ì¸ë¼ì´ë‹, ë£¨í”„ ìµœì í™” ë“±)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Code     â”‚  íƒ€ê²Ÿ ì•„í‚¤í…ì²˜ìš© ê¸°ê³„ì–´ ìƒì„±
â”‚ Generation  â”‚  (x86, ARM, etc.)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```c
// C ì»´íŒŒì¼ ì˜ˆì‹œ
// gcc -S -O2 example.c  (ì–´ì…ˆë¸”ë¦¬ ì¶œë ¥)
// gcc -c example.c      (ì˜¤ë¸Œì íŠ¸ íŒŒì¼)
// gcc example.c -o example (ì‹¤í–‰ íŒŒì¼)

int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(3, 5);
    return result;
}

// ìƒì„±ëœ x86-64 ì–´ì…ˆë¸”ë¦¬ (ìµœì í™” ì „)
// add:
//     pushq   %rbp
//     movq    %rsp, %rbp
//     movl    %edi, -4(%rbp)
//     movl    %esi, -8(%rbp)
//     movl    -4(%rbp), %edx
//     movl    -8(%rbp), %eax
//     addl    %edx, %eax
//     popq    %rbp
//     ret
```

**ì¥ì :**
- ë¹ ë¥¸ ì‹¤í–‰ ì†ë„
- ë°°í¬ ì‹œ ì†ŒìŠ¤ ì½”ë“œ ë…¸ì¶œ ì—†ìŒ
- ì»´íŒŒì¼ íƒ€ì„ ìµœì í™”

**ë‹¨ì :**
- í”Œë«í¼ë³„ ì»´íŒŒì¼ í•„ìš”
- ì»´íŒŒì¼ ì‹œê°„ ì†Œìš”
- ë””ë²„ê¹…ì´ ìƒëŒ€ì ìœ¼ë¡œ ì–´ë ¤ì›€

### 4.2 ì¸í„°í”„ë¦¬í„° (Interpreter)

ì†ŒìŠ¤ ì½”ë“œë¥¼ í•œ ì¤„ì”© ì½ì–´ì„œ ì¦‰ì‹œ ì‹¤í–‰í•œë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Source Code â”‚â”€â”€â”€â–¶â”‚ Interpreter  â”‚â”€â”€â”€â–¶ ì‹¤í–‰ ê²°ê³¼
â”‚   (*.py)     â”‚    â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
# Python ì¸í„°í”„ë¦¬í„° ë™ì‘ ì˜ˆì‹œ
# ì½”ë“œë¥¼ í•œ ì¤„ì”© ì½ê³  ì‹¤í–‰

def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# ì´ ì‹œì ì—ì„œ í•¨ìˆ˜ ì •ì˜ê°€ í•´ì„ë˜ê³  ë©”ëª¨ë¦¬ì— ì €ì¥ë¨
print(fibonacci(10))  # ì´ ì¤„ì´ ì‹¤í–‰ë  ë•Œ í•¨ìˆ˜ í˜¸ì¶œ
```

**ì¥ì :**
- ë¹ ë¥¸ ê°œë°œ ì‚¬ì´í´ (ìˆ˜ì • í›„ ì¦‰ì‹œ ì‹¤í–‰)
- í”Œë«í¼ ë…ë¦½ì 
- ë™ì  ì½”ë“œ ì‹¤í–‰ ê°€ëŠ¥ (eval, exec)
- ë””ë²„ê¹… ìš©ì´

**ë‹¨ì :**
- ëŠë¦° ì‹¤í–‰ ì†ë„
- ëŸ°íƒ€ì„ ì—ëŸ¬
- ì†ŒìŠ¤ ì½”ë“œ ë…¸ì¶œ

### 4.3 í•˜ì´ë¸Œë¦¬ë“œ ë°©ì‹

#### JIT (Just-In-Time) ì»´íŒŒì¼

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Source Code â”‚â”€â”€â”€â–¶â”‚   Compiler   â”‚â”€â”€â”€â–¶â”‚   Bytecode   â”‚
â”‚   (*.java)   â”‚    â”‚   (javac)    â”‚    â”‚  (*.class)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â”‚
                                               â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚              JVM                  â”‚
                    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                    â”‚ Interpreter  â”‚   JIT Compiler    â”‚
                    â”‚  (ì´ˆê¸° ì‹¤í–‰)   â”‚  (Hot Code ìµœì í™”) â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```java
// JIT ì»´íŒŒì¼ ì˜ˆì‹œ
public class JITExample {
    public static void main(String[] args) {
        long sum = 0;

        // ì²˜ìŒì—ëŠ” ì¸í„°í”„ë¦¬í„°ë¡œ ì‹¤í–‰
        // ë°˜ë³µì´ ë§ì•„ì§€ë©´ (threshold ë„ë‹¬) JIT ì»´íŒŒì¼
        for (int i = 0; i < 100_000_000; i++) {
            sum += calculate(i);  // Hot Method
        }

        System.out.println(sum);
    }

    // ìì£¼ í˜¸ì¶œë˜ë©´ JIT ì»´íŒŒì¼ëŸ¬ê°€ ë„¤ì´í‹°ë¸Œ ì½”ë“œë¡œ ë³€í™˜
    private static int calculate(int n) {
        return n * 2 + 1;
    }
}

// JIT ì»´íŒŒì¼ í™•ì¸: java -XX:+PrintCompilation JITExample
```

#### AOT (Ahead-Of-Time) ì»´íŒŒì¼

```bash
# GraalVM Native Image - AOT ì»´íŒŒì¼
native-image -jar myapp.jar

# ê²°ê³¼: ë„¤ì´í‹°ë¸Œ ì‹¤í–‰ íŒŒì¼ (JVM ì—†ì´ ì‹¤í–‰ ê°€ëŠ¥)
# ì¥ì : ë¹ ë¥¸ ì‹œì‘ ì‹œê°„, ë‚®ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©
# ë‹¨ì : ë™ì  ê¸°ëŠ¥ ì œí•œ (Reflection ë“±)
```

### 4.4 ì–¸ì–´ë³„ ì‹¤í–‰ ë°©ì‹ ë¹„êµ

| ì–¸ì–´ | ì‹¤í–‰ ë°©ì‹ | íŠ¹ì§• |
|------|----------|------|
| C/C++ | ìˆœìˆ˜ ì»´íŒŒì¼ | ë„¤ì´í‹°ë¸Œ ê¸°ê³„ì–´, ìµœê³  ì„±ëŠ¥ |
| Go | ìˆœìˆ˜ ì»´íŒŒì¼ | ë‹¨ì¼ ë°”ì´ë„ˆë¦¬, ë¹ ë¥¸ ì»´íŒŒì¼ |
| Rust | ìˆœìˆ˜ ì»´íŒŒì¼ | LLVM ê¸°ë°˜, ì•ˆì „ì„± + ì„±ëŠ¥ |
| Java | ì»´íŒŒì¼ + JIT | ë°”ì´íŠ¸ì½”ë“œ â†’ JVM â†’ JIT |
| Kotlin | ì»´íŒŒì¼ + JIT | Javaì™€ ë™ì¼ (JVM) ë˜ëŠ” Native |
| Python | ì¸í„°í”„ë¦¬í„° | CPython (ë°”ì´íŠ¸ì½”ë“œ ìºì‹±) |
| JavaScript | JIT | V8, SpiderMonkey ë“± |
| TypeScript | íŠ¸ëœìŠ¤íŒŒì¼ | TS â†’ JS â†’ ì—”ì§„ ì‹¤í–‰ |

---

## ì°¸ê³  ìë£Œ

- "Java Performance: The Definitive Guide" - Scott Oaks
- "Understanding the JVM" - Oracle Documentation
- "The Go Programming Language" - Alan Donovan, Brian Kernighan
- Oracle JVM Garbage Collection Tuning Guide
- Python Official Documentation - Memory Management

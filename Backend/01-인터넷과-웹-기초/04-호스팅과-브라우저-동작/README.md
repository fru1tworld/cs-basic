# 호스팅과 브라우저 동작

> 웹 서비스의 인프라 기반인 호스팅 유형과 브라우저의 렌더링 과정을 다룹니다.

## 목차
1. [웹 호스팅 유형](#1-웹-호스팅-유형)
2. [브라우저 렌더링 파이프라인](#2-브라우저-렌더링-파이프라인)
3. [Critical Rendering Path](#3-critical-rendering-path)
4. [브라우저 캐싱 메커니즘](#4-브라우저-캐싱-메커니즘)
---

## 1. 웹 호스팅 유형

### 1.1 호스팅 유형 개요

```
┌─────────────────────────────────────────────────────────────────────┐
│                       호스팅 유형 스펙트럼                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   관리 책임 높음                               관리 책임 낮음        │
│        ◄────────────────────────────────────────────►              │
│                                                                     │
│   ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ │
│   │ 베어메탈  │ │Dedicated │ │   VPS    │ │  Cloud   │ │ Managed/ │ │
│   │  서버    │ │  서버    │ │          │ │          │ │ PaaS     │ │
│   └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │
│                                                                     │
│   비용: 고정 ────────────────────────────────────► 종량제           │
│   확장성: 낮음 ──────────────────────────────────► 높음             │
│   유연성: 높음 ──────────────────────────────────► 낮음             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 Shared Hosting (공유 호스팅)

```
┌─────────────────────────────────────────────────────────────────────┐
│                      Shared Hosting 구조                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│                    ┌─────────────────────────────┐                  │
│                    │       Physical Server        │                  │
│                    │                             │                  │
│   ┌────────────────┼────────────────────────────┐│                  │
│   │                │      Operating System       ││                  │
│   │                │       (공유 - Linux)        ││                  │
│   │   ┌────────────┼────────────────────────────┤│                  │
│   │   │            │    Web Server (Apache)      ││                  │
│   │   │   ┌────────┼────────┬────────┬─────────┐││                  │
│   │   │   │Site A  │ Site B │ Site C │ Site D  │││                  │
│   │   │   │ 5GB    │  3GB   │  10GB  │  2GB    │││                  │
│   │   │   └────────┴────────┴────────┴─────────┘││                  │
│   │   └─────────────────────────────────────────┤│                  │
│   └──────────────────────────────────────────────┘│                  │
│                    └─────────────────────────────┘                  │
│                                                                     │
│   특징:                                                             │
│   - 여러 사이트가 하나의 서버 자원 공유                               │
│   - 가장 저렴한 옵션 (월 $3-15)                                      │
│   - 제한된 자원, 성능 간섭 가능                                       │
│   - 서버 설정 커스터마이징 불가                                       │
│                                                                     │
│   적합한 경우:                                                       │
│   - 개인 블로그, 소규모 웹사이트                                      │
│   - 트래픽이 적은 정적 사이트                                         │
│   - 예산이 제한된 스타트업 초기                                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.3 VPS (Virtual Private Server)

```
┌─────────────────────────────────────────────────────────────────────┐
│                         VPS 구조                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│                    ┌─────────────────────────────┐                  │
│                    │       Physical Server        │                  │
│                    │     (강력한 하드웨어)         │                  │
│   ┌────────────────┼─────────────────────────────┐│                  │
│   │                │      Hypervisor             ││                  │
│   │                │    (KVM, VMware, Xen)       ││                  │
│   │   ┌────────────┼─────┬──────┬──────┬───────┐ ││                  │
│   │   │   VM 1     │VM 2 │ VM 3 │ VM 4 │ VM 5  │ ││                  │
│   │   │┌─────────┐ │     │      │      │       │ ││                  │
│   │   ││   OS    │ │ OS  │  OS  │  OS  │  OS   │ ││                  │
│   │   ││ (독립)  │ │     │      │      │       │ ││                  │
│   │   │├─────────┤ │     │      │      │       │ ││                  │
│   │   ││  Apps   │ │Apps │ Apps │ Apps │ Apps  │ ││                  │
│   │   │└─────────┘ │     │      │      │       │ ││                  │
│   │   │  2 CPU    │1 CPU│4 CPU │2 CPU │ 1 CPU │ ││                  │
│   │   │  4GB RAM  │2GB  │8GB   │4GB   │ 2GB   │ ││                  │
│   │   └────────────┴─────┴──────┴──────┴───────┘ ││                  │
│   └──────────────────────────────────────────────┘│                  │
│                    └─────────────────────────────┘                  │
│                                                                     │
│   특징:                                                             │
│   - 가상화된 독립 서버 환경                                          │
│   - 보장된 CPU, RAM, 스토리지                                        │
│   - Root 접근 권한, 전체 커스터마이징                                 │
│   - Shared보다 비싸지만 Dedicated보다 저렴 (월 $20-100)              │
│                                                                     │
│   적합한 경우:                                                       │
│   - 중소규모 웹 애플리케이션                                          │
│   - 개발/스테이징 환경                                               │
│   - 특정 소프트웨어 요구사항이 있는 프로젝트                           │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.4 Dedicated Server (전용 서버)

```
┌─────────────────────────────────────────────────────────────────────┐
│                      Dedicated Server 구조                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                    Physical Server                           │   │
│   │                  (단일 고객 전용)                             │   │
│   │                                                             │   │
│   │   ┌─────────────────────────────────────────────────────┐   │   │
│   │   │                Operating System                      │   │   │
│   │   │              (완전한 제어권)                          │   │   │
│   │   │                                                     │   │   │
│   │   │   ┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐          │   │   │
│   │   │   │ Web   │ │  DB   │ │ Cache │ │ Worker│          │   │   │
│   │   │   │Server │ │Server │ │Server │ │       │          │   │   │
│   │   │   └───────┘ └───────┘ └───────┘ └───────┘          │   │   │
│   │   │                                                     │   │   │
│   │   │   Hardware: 32 Core, 128GB RAM, 2TB NVMe SSD       │   │   │
│   │   └─────────────────────────────────────────────────────┘   │   │
│   │                                                             │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│   특징:                                                             │
│   - 물리 서버 전체 독점 사용                                         │
│   - 최대 성능, 완전한 격리                                           │
│   - 하드웨어 커스터마이징 가능                                        │
│   - 높은 비용 (월 $100-500+)                                        │
│                                                                     │
│   적합한 경우:                                                       │
│   - 높은 트래픽의 대규모 서비스                                       │
│   - 컴플라이언스 요구사항 (PCI-DSS, HIPAA)                           │
│   - 고성능 데이터베이스, 게임 서버                                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.5 Cloud Hosting

```
┌─────────────────────────────────────────────────────────────────────┐
│                       Cloud Hosting 구조                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│                    ┌──────────────────────────────────┐             │
│                    │         Cloud Provider           │             │
│                    │    (AWS, GCP, Azure, etc.)       │             │
│   ┌────────────────┼──────────────────────────────────┼───────────┐ │
│   │   Region 1     │   Region 2      │    Region 3   │           │ │
│   │   (서울)       │   (도쿄)        │    (버지니아)  │           │ │
│   │                │                 │               │           │ │
│   │   ┌─────┐      │    ┌─────┐      │    ┌─────┐    │           │ │
│   │   │ AZ-a│      │    │ AZ-a│      │    │ AZ-a│    │           │ │
│   │   │ AZ-b│      │    │ AZ-b│      │    │ AZ-b│    │           │ │
│   │   │ AZ-c│      │    │ AZ-c│      │    │ AZ-c│    │           │ │
│   │   └─────┘      │    └─────┘      │    └─────┘    │           │ │
│   └────────────────┴─────────────────┴───────────────┴───────────┘ │
│                                                                     │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                    사용 가능한 서비스                        │   │
│   │   Compute: EC2, Cloud Run, VMs                              │   │
│   │   Storage: S3, Cloud Storage, Blob                          │   │
│   │   Database: RDS, Cloud SQL, Cosmos DB                       │   │
│   │   Networking: VPC, Load Balancer, CDN                       │   │
│   │   Containers: EKS, GKE, AKS                                 │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│   특징:                                                             │
│   - 종량제 과금 (사용한 만큼)                                        │
│   - 무한 확장성 (Auto Scaling)                                      │
│   - 글로벌 인프라                                                   │
│   - 다양한 관리형 서비스                                             │
│   - 고가용성 (Multi-AZ)                                             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.6 호스팅 유형 비교표

```python
# 호스팅 유형 비교
hosting_comparison = {
    "shared": {
        "cost": "$3-15/월",
        "performance": "낮음",
        "scalability": "불가",
        "control": "없음",
        "isolation": "없음",
        "management": "완전 관리형",
        "use_case": "개인 블로그, 소규모 사이트"
    },
    "vps": {
        "cost": "$20-100/월",
        "performance": "중간",
        "scalability": "수동 업그레이드",
        "control": "Root 권한",
        "isolation": "가상화 격리",
        "management": "반관리/자체관리",
        "use_case": "중소규모 앱, 개발 환경"
    },
    "dedicated": {
        "cost": "$100-500+/월",
        "performance": "높음",
        "scalability": "하드웨어 교체",
        "control": "완전 제어",
        "isolation": "물리적 격리",
        "management": "자체 관리",
        "use_case": "대규모 서비스, 컴플라이언스"
    },
    "cloud": {
        "cost": "종량제",
        "performance": "유연",
        "scalability": "Auto Scaling",
        "control": "인스턴스 레벨",
        "isolation": "가상화 격리",
        "management": "다양한 옵션",
        "use_case": "스타트업, 변동 트래픽, 글로벌"
    },
    "paas": {
        "cost": "종량제 (높음)",
        "performance": "관리됨",
        "scalability": "자동",
        "control": "제한적",
        "isolation": "컨테이너/함수",
        "management": "완전 관리형",
        "use_case": "빠른 개발, 서버리스 앱"
    }
}
```

### 1.7 Cloud 서비스 모델 (IaaS, PaaS, SaaS)

```
┌─────────────────────────────────────────────────────────────────────┐
│               Cloud 서비스 모델 책임 분담                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│              On-Premise   IaaS      PaaS      SaaS                 │
│              ─────────    ────      ────      ────                 │
│   ┌────────┐                                                       │
│   │  App   │   고객       고객      고객      제공자               │
│   ├────────┤                                                       │
│   │  Data  │   고객       고객      고객      제공자               │
│   ├────────┤                                                       │
│   │Runtime │   고객       고객      제공자    제공자               │
│   ├────────┤                                                       │
│   │Middleware│  고객       고객      제공자    제공자               │
│   ├────────┤                                                       │
│   │   OS   │   고객       고객      제공자    제공자               │
│   ├────────┤                                                       │
│   │Virtual │   고객       제공자    제공자    제공자               │
│   ├────────┤                                                       │
│   │Server  │   고객       제공자    제공자    제공자               │
│   ├────────┤                                                       │
│   │Storage │   고객       제공자    제공자    제공자               │
│   ├────────┤                                                       │
│   │Network │   고객       제공자    제공자    제공자               │
│   └────────┘                                                       │
│                                                                     │
│   예시:                                                             │
│   IaaS: AWS EC2, GCP Compute Engine, Azure VMs                     │
│   PaaS: Heroku, Google App Engine, AWS Elastic Beanstalk           │
│   SaaS: Google Workspace, Salesforce, Slack                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. 브라우저 렌더링 파이프라인

### 2.1 브라우저 구조

```
┌─────────────────────────────────────────────────────────────────────┐
│                       브라우저 구조                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                    User Interface                            │   │
│   │     (주소창, 북마크, 뒤로/앞으로 버튼, 탭 등)                   │   │
│   └─────────────────────────┬───────────────────────────────────┘   │
│                             │                                       │
│   ┌─────────────────────────┴───────────────────────────────────┐   │
│   │                    Browser Engine                            │   │
│   │          (UI와 렌더링 엔진 사이의 마샬링)                      │   │
│   └─────────────────────────┬───────────────────────────────────┘   │
│                             │                                       │
│   ┌─────────────────────────┴───────────────────────────────────┐   │
│   │                   Rendering Engine                           │   │
│   │        (Blink - Chrome, Gecko - Firefox, WebKit - Safari)    │   │
│   │                                                             │   │
│   │   ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │   │
│   │   │ Networking│  │HTML Parser│  │CSS Parser│  │JavaScript│   │   │
│   │   │          │  │          │  │          │  │  Engine  │   │   │
│   │   │          │  │          │  │          │  │  (V8)    │   │   │
│   │   └──────────┘  └──────────┘  └──────────┘  └──────────┘   │   │
│   │                                                             │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                             │                                       │
│   ┌──────────┬──────────────┴─────────────┬──────────┐             │
│   │  UI      │        Data Persistence    │  Display │             │
│   │ Backend  │    (Cache, Cookies, etc.)  │  Backend │             │
│   └──────────┴────────────────────────────┴──────────┘             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 렌더링 파이프라인 개요

```
┌─────────────────────────────────────────────────────────────────────┐
│                    렌더링 파이프라인 (Pixel Pipeline)                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   HTML ─► DOM                                                       │
│            │                                                        │
│            ├──────────────────────────────────┐                     │
│            │                                  │                     │
│            ▼                                  ▼                     │
│   CSS ─► CSSOM ─────────────────────────► Render                    │
│                                            Tree                     │
│                                              │                      │
│                                              ▼                      │
│                                           Layout                    │
│                                          (Reflow)                   │
│                                              │                      │
│                                              ▼                      │
│                                           Paint                     │
│                                          (Repaint)                  │
│                                              │                      │
│                                              ▼                      │
│                                         Composite                   │
│                                              │                      │
│                                              ▼                      │
│                                           Display                   │
│                                                                     │
│   5단계: Parse → Style → Layout → Paint → Composite                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.3 각 단계 상세

#### 1단계: Parse (파싱)

```
┌─────────────────────────────────────────────────────────────────────┐
│                         1. Parse (파싱)                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  HTML 파싱 → DOM Tree 생성                                          │
│                                                                     │
│  HTML:                           DOM Tree:                          │
│  ┌──────────────────────┐        ┌─────────────────────────────┐   │
│  │ <html>               │        │         Document            │   │
│  │   <head>             │        │            │                │   │
│  │     <title>Hi</title>│  ───►  │          <html>             │   │
│  │   </head>            │        │         /      \            │   │
│  │   <body>             │        │     <head>    <body>        │   │
│  │     <div>Hello</div> │        │       │         │           │   │
│  │   </body>            │        │    <title>    <div>         │   │
│  │ </html>              │        │       │         │           │   │
│  └──────────────────────┘        │     "Hi"     "Hello"        │   │
│                                  └─────────────────────────────┘   │
│                                                                     │
│  CSS 파싱 → CSSOM Tree 생성                                         │
│                                                                     │
│  CSS:                            CSSOM Tree:                        │
│  ┌──────────────────────┐        ┌─────────────────────────────┐   │
│  │ body {               │        │       StyleSheetList        │   │
│  │   font-size: 16px;   │  ───►  │            │                │   │
│  │ }                    │        │       StyleSheet            │   │
│  │ div {                │        │       /        \            │   │
│  │   color: red;        │        │    body       div           │   │
│  │ }                    │        │  font-size   color          │   │
│  └──────────────────────┘        │    16px       red           │   │
│                                  └─────────────────────────────┘   │
│                                                                     │
│  특징:                                                              │
│  - DOM 생성은 점진적 (Incremental)                                   │
│  - CSSOM은 완전히 파싱될 때까지 블로킹                                │
│  - <script>는 DOM 파싱을 중단시킴 (동기적)                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2단계: Style (스타일 계산)

```
┌─────────────────────────────────────────────────────────────────────┐
│                      2. Style (스타일 계산)                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  DOM + CSSOM → Render Tree (렌더 트리)                               │
│                                                                     │
│  ┌────────┐     ┌────────┐          ┌────────────────────┐          │
│  │  DOM   │  +  │ CSSOM  │   ───►   │    Render Tree     │          │
│  │  Tree  │     │  Tree  │          │                    │          │
│  └────────┘     └────────┘          │  (화면에 표시될     │          │
│                                     │   노드만 포함)      │          │
│                                     └────────────────────┘          │
│                                                                     │
│  Render Tree 특징:                                                   │
│  - display: none 요소는 제외                                         │
│  - visibility: hidden 요소는 포함 (공간 차지)                         │
│  - ::before, ::after 의사 요소 포함                                  │
│  - <head>, <script> 등 비시각 요소 제외                              │
│                                                                     │
│  스타일 계산 과정:                                                    │
│  1. 선택자 매칭 (어떤 규칙이 적용되는지)                               │
│  2. 명시도 계산 (Specificity)                                        │
│  3. 캐스케이딩 (우선순위 적용)                                        │
│  4. 상속 처리                                                        │
│  5. 최종 계산된 스타일 (Computed Style)                               │
│                                                                     │
│  명시도 계산:                                                        │
│  inline > ID > Class/Attribute/Pseudo-class > Element > *           │
│  (1,0,0,0) (0,1,0,0)     (0,0,1,0)              (0,0,0,1)           │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 3단계: Layout (레이아웃/Reflow)

```
┌─────────────────────────────────────────────────────────────────────┐
│                     3. Layout (레이아웃/Reflow)                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  각 요소의 정확한 위치와 크기 계산                                    │
│                                                                     │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │ Viewport: 1024 x 768                                         │   │
│  │ ┌──────────────────────────────────────────────────────────┐ │   │
│  │ │ <body> - Box: (0,0) 1024x768                             │ │   │
│  │ │ ┌────────────────────────────────────────────────────┐   │ │   │
│  │ │ │ <header> - Box: (0,0) 1024x80                      │   │ │   │
│  │ │ └────────────────────────────────────────────────────┘   │ │   │
│  │ │ ┌────────────────────────────────────────────────────┐   │ │   │
│  │ │ │ <main> - Box: (0,80) 1024x600                      │   │ │   │
│  │ │ │ ┌──────────────┐ ┌──────────────────────────────┐  │   │ │   │
│  │ │ │ │ <aside>      │ │ <article>                    │  │   │ │   │
│  │ │ │ │ 200x600      │ │ 824x600                      │  │   │ │   │
│  │ │ │ └──────────────┘ └──────────────────────────────┘  │   │ │   │
│  │ │ └────────────────────────────────────────────────────┘   │ │   │
│  │ │ ┌────────────────────────────────────────────────────┐   │ │   │
│  │ │ │ <footer> - Box: (0,680) 1024x88                    │   │ │   │
│  │ │ └────────────────────────────────────────────────────┘   │ │   │
│  │ └──────────────────────────────────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  박스 모델:                                                          │
│  ┌─────────────────────────────────────┐                            │
│  │ Margin                              │                            │
│  │ ┌─────────────────────────────────┐ │                            │
│  │ │ Border                          │ │                            │
│  │ │ ┌─────────────────────────────┐ │ │                            │
│  │ │ │ Padding                     │ │ │                            │
│  │ │ │ ┌─────────────────────────┐ │ │ │                            │
│  │ │ │ │ Content                 │ │ │ │                            │
│  │ │ │ └─────────────────────────┘ │ │ │                            │
│  │ │ └─────────────────────────────┘ │ │                            │
│  │ └─────────────────────────────────┘ │                            │
│  └─────────────────────────────────────┘                            │
│                                                                     │
│  Layout 트리거 (비용 높음):                                           │
│  - width, height, padding, margin, border 변경                      │
│  - position, display, float 변경                                    │
│  - font-size, font-family, line-height 변경                         │
│  - 창 크기 변경 (resize)                                             │
│  - offsetWidth, scrollHeight 등 레이아웃 속성 읽기                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 4단계: Paint (페인트)

```
┌─────────────────────────────────────────────────────────────────────┐
│                        4. Paint (페인트)                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  레이아웃 박스를 실제 픽셀로 변환 (래스터화 준비)                       │
│                                                                     │
│  Paint 순서 (Stacking Context):                                      │
│  1. background-color                                                │
│  2. background-image                                                │
│  3. border                                                          │
│  4. children (자식 요소들)                                           │
│  5. outline                                                         │
│                                                                     │
│  Paint 기록 (Display List 생성):                                     │
│  ┌────────────────────────────────────────────────────────────┐     │
│  │ DrawRect (0,0,1024,768) color: #ffffff                     │     │
│  │ DrawRect (0,0,1024,80) color: #333333                      │     │
│  │ DrawText (20,40) "Site Title" font: 24px Bold              │     │
│  │ DrawRect (0,80,200,600) color: #f0f0f0                     │     │
│  │ DrawRect (200,80,824,600) color: #ffffff                   │     │
│  │ DrawImage (220,100) src: "image.jpg" 400x300               │     │
│  │ DrawText (220,420) "Article content..." font: 16px         │     │
│  │ ...                                                        │     │
│  └────────────────────────────────────────────────────────────┘     │
│                                                                     │
│  Paint 트리거 (Layout보다 가벼움):                                    │
│  - color, background-color 변경                                     │
│  - visibility, text-decoration 변경                                 │
│  - box-shadow, border-radius 변경                                   │
│                                                                     │
│  레이어 (Layers):                                                    │
│  - 특정 조건에서 요소가 별도 레이어로 분리                             │
│  - 조건: will-change, transform, opacity, position: fixed          │
│  - 장점: 해당 레이어만 다시 그리면 됨                                  │
│  - 단점: 메모리 사용 증가                                             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 5단계: Composite (합성)

```
┌─────────────────────────────────────────────────────────────────────┐
│                      5. Composite (합성)                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  레이어들을 합쳐서 최종 화면 구성 (GPU 가속)                           │
│                                                                     │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │   Layer 1 (배경)      ─┐                                     │   │
│  │   ┌──────────────┐     │                                     │   │
│  │   │ Background   │     │                                     │   │
│  │   └──────────────┘     │                                     │   │
│  │                        │     ┌──────────────┐                │   │
│  │   Layer 2 (콘텐츠)    ─┼───► │   합성 결과   │                │   │
│  │   ┌──────────────┐     │     │   (화면)     │                │   │
│  │   │   Content    │     │     └──────────────┘                │   │
│  │   └──────────────┘     │                                     │   │
│  │                        │                                     │   │
│  │   Layer 3 (오버레이)  ─┘                                     │   │
│  │   ┌──────────────┐                                           │   │
│  │   │   Modal      │                                           │   │
│  │   └──────────────┘                                           │   │
│  │                                                              │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  Compositor-only 속성 (가장 효율적):                                 │
│  - transform (translate, scale, rotate)                            │
│  - opacity                                                         │
│  → Layout, Paint 스킵, 합성만 다시 수행                              │
│  → GPU에서 처리, 메인 스레드 블로킹 없음                              │
│                                                                     │
│  성능 최적화 팁:                                                     │
│  - 애니메이션은 transform, opacity만 사용                            │
│  - will-change로 미리 레이어 승격 힌트                               │
│  - 너무 많은 레이어는 메모리 과다 사용                                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.4 렌더링 성능 최적화

```javascript
// 레이아웃 스래싱 (Layout Thrashing) - 피해야 할 패턴
function badPattern() {
    const elements = document.querySelectorAll('.item');

    elements.forEach(el => {
        // 읽기와 쓰기가 번갈아 발생 → 매번 Layout 재계산
        const width = el.offsetWidth;      // 읽기 (Layout 강제)
        el.style.width = width + 10 + 'px'; // 쓰기 (Layout 무효화)
    });
}

// 최적화된 패턴 - 읽기와 쓰기 분리
function goodPattern() {
    const elements = document.querySelectorAll('.item');

    // 1. 먼저 모든 값 읽기
    const widths = Array.from(elements).map(el => el.offsetWidth);

    // 2. 그 다음 모든 값 쓰기
    elements.forEach((el, i) => {
        el.style.width = widths[i] + 10 + 'px';
    });
}

// requestAnimationFrame 사용
function animateWithRAF() {
    const element = document.getElementById('animated');
    let position = 0;

    function animate() {
        position += 1;

        // transform 사용 (Compositor-only)
        element.style.transform = `translateX(${position}px)`;

        if (position < 300) {
            requestAnimationFrame(animate);
        }
    }

    requestAnimationFrame(animate);
}

// CSS will-change 힌트
/*
.animated-element {
    will-change: transform, opacity;
}

/* 사용 후 해제 */
.animated-element.animation-done {
    will-change: auto;
}
*/
```

---

## 3. Critical Rendering Path

### 3.1 CRP 개요

```
┌─────────────────────────────────────────────────────────────────────┐
│                  Critical Rendering Path (CRP)                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  정의: 브라우저가 HTML, CSS, JavaScript를 화면의 픽셀로              │
│        변환하기 위해 거치는 필수 단계들                               │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                        Timeline                              │    │
│  ├─────────────────────────────────────────────────────────────┤    │
│  │ Network      ████████████████████████████████████████████    │    │
│  │              │HTML│  │CSS│  │JS│  │Images│                   │    │
│  ├─────────────────────────────────────────────────────────────┤    │
│  │ Parse HTML   ██████████──────────████████████████            │    │
│  │                      (JS가 블로킹)                           │    │
│  ├─────────────────────────────────────────────────────────────┤    │
│  │ Parse CSS           ████████████                             │    │
│  │                                                              │    │
│  ├─────────────────────────────────────────────────────────────┤    │
│  │ Execute JS                    ████                           │    │
│  │                                                              │    │
│  ├─────────────────────────────────────────────────────────────┤    │
│  │ Layout                             ████                      │    │
│  ├─────────────────────────────────────────────────────────────┤    │
│  │ Paint                                  ████                  │    │
│  ├─────────────────────────────────────────────────────────────┤    │
│  │                                        │                     │    │
│  │                                   First Paint                │    │
│  │                                   (사용자가 콘텐츠 봄)        │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 렌더 블로킹 리소스

```html
<!-- CSS는 렌더 블로킹 -->
<head>
    <!-- 1. 모든 CSS가 파싱될 때까지 렌더링 대기 -->
    <link rel="stylesheet" href="styles.css">

    <!-- 2. 조건부 CSS로 블로킹 최소화 -->
    <link rel="stylesheet" href="print.css" media="print">
    <link rel="stylesheet" href="mobile.css" media="(max-width: 768px)">

    <!-- 3. 크리티컬 CSS 인라인화 -->
    <style>
        /* 위에 표시되는 핵심 스타일만 */
        .hero { background: blue; color: white; }
        .nav { display: flex; }
    </style>

    <!-- 4. 비동기 CSS 로드 -->
    <link rel="preload" href="non-critical.css" as="style"
          onload="this.onload=null;this.rel='stylesheet'">
</head>

<!-- JavaScript는 파서 블로킹 -->
<body>
    <div id="content">...</div>

    <!-- 1. 일반 스크립트: HTML 파싱 중단 -->
    <script src="blocking.js"></script>

    <!-- 2. async: 다운로드는 비동기, 실행 시 파싱 중단 -->
    <!--    다운로드 완료 순서대로 실행 (순서 보장 X) -->
    <script async src="analytics.js"></script>
    <script async src="ads.js"></script>

    <!-- 3. defer: 다운로드 비동기, DOM 파싱 완료 후 순서대로 실행 -->
    <script defer src="app.js"></script>
    <script defer src="vendor.js"></script>

    <!-- 4. module: 기본적으로 defer처럼 동작 -->
    <script type="module" src="main.js"></script>
</body>
```

**async vs defer 비교:**
```
┌─────────────────────────────────────────────────────────────────────┐
│                    async vs defer                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  일반 스크립트 (blocking):                                           │
│  HTML ──────█████████████████──────────────────────                 │
│             │               │                                       │
│             │ Parse HTML    │ 계속 Parse                             │
│             │ 중단          │                                       │
│  JS         │    다운로드→실행│                                       │
│             └───────────────┘                                       │
│                                                                     │
│  async:                                                             │
│  HTML ────────────────█████────────────────────                     │
│                       │   │                                         │
│                       │   │ Parse 중단 후 재개                       │
│  JS   ██████████████████  │                                         │
│       │            │  │실행│                                         │
│       └──다운로드──┘  └────┘                                         │
│       (파싱과 병렬)   (완료 즉시)                                     │
│                                                                     │
│  defer:                                                             │
│  HTML ──────────────────────────────────────█                       │
│                                             │ DOMContentLoaded 직전  │
│  JS   ██████████████████████████████████████│                       │
│       │                               │     │ 실행                  │
│       └─────── 다운로드 (병렬) ────────┘     └────────               │
│                                                                     │
│  사용 가이드:                                                        │
│  - async: 독립적인 스크립트 (분석, 광고)                              │
│  - defer: DOM에 의존하는 스크립트, 순서 중요                          │
│  - 인라인 스크립트: async/defer 불가                                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.3 CRP 최적화 전략

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- 1. 리소스 힌트 (Resource Hints) -->
    <!-- DNS 미리 조회 -->
    <link rel="dns-prefetch" href="https://cdn.example.com">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">

    <!-- TCP 연결 미리 수행 -->
    <link rel="preconnect" href="https://cdn.example.com" crossorigin>

    <!-- 중요 리소스 미리 로드 -->
    <link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/css/critical.css" as="style">
    <link rel="preload" href="/js/main.js" as="script">

    <!-- 다음 페이지 미리 로드 -->
    <link rel="prefetch" href="/next-page.html">

    <!-- 2. 크리티컬 CSS 인라인 -->
    <style>
        /* Above-the-fold 콘텐츠만 */
        :root { --primary: #007bff; }
        body { margin: 0; font-family: system-ui, sans-serif; }
        .hero { min-height: 100vh; background: var(--primary); }
        /* ... 최소한의 핵심 스타일 */
    </style>

    <!-- 3. 나머지 CSS는 비동기 로드 -->
    <link rel="preload" href="/css/main.css" as="style"
          onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/css/main.css"></noscript>
</head>
<body>
    <!-- 4. Above-the-fold 콘텐츠 먼저 -->
    <header class="hero">
        <h1>Welcome</h1>
    </header>

    <!-- 5. 중요하지 않은 콘텐츠 -->
    <main>
        <!-- Lazy loading 이미지 -->
        <img src="placeholder.jpg"
             data-src="hero.jpg"
             loading="lazy"
             alt="Hero Image">
    </main>

    <!-- 6. JavaScript는 맨 아래, defer 사용 -->
    <script defer src="/js/vendor.js"></script>
    <script defer src="/js/main.js"></script>
</body>
</html>
```

### 3.4 Core Web Vitals

```
┌─────────────────────────────────────────────────────────────────────┐
│                      Core Web Vitals (2024)                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  LCP (Largest Contentful Paint) - 로딩 성능                          │
│  ├─ 정의: 가장 큰 콘텐츠 요소가 표시되는 시간                          │
│  ├─ 목표: 2.5초 이내                                                 │
│  └─ 측정: <img>, <video>, background-image, 큰 텍스트 블록            │
│                                                                     │
│  FID (First Input Delay) → INP로 대체됨                              │
│                                                                     │
│  INP (Interaction to Next Paint) - 응답성                            │
│  ├─ 정의: 사용자 상호작용 후 화면 업데이트까지 시간                     │
│  ├─ 목표: 200ms 이내                                                 │
│  └─ 측정: 클릭, 탭, 키보드 입력의 지연 시간                            │
│                                                                     │
│  CLS (Cumulative Layout Shift) - 시각적 안정성                        │
│  ├─ 정의: 페이지 수명 동안 발생하는 레이아웃 이동의 합                  │
│  ├─ 목표: 0.1 이하                                                   │
│  └─ 원인: 크기 없는 이미지, 동적 콘텐츠, 웹폰트 FOUT                   │
│                                                                     │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │ 측정 도구:                                                │       │
│  │ - Lighthouse (Chrome DevTools)                           │       │
│  │ - PageSpeed Insights (web.dev)                           │       │
│  │ - Chrome UX Report (CrUX)                                │       │
│  │ - Web Vitals JavaScript Library                          │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**Web Vitals 측정 코드:**
```javascript
import { onLCP, onINP, onCLS } from 'web-vitals';

function sendToAnalytics(metric) {
    const body = JSON.stringify({
        name: metric.name,
        value: metric.value,
        id: metric.id,
        rating: metric.rating,  // 'good', 'needs-improvement', 'poor'
        navigationType: metric.navigationType,
    });

    // Use sendBeacon for reliability
    navigator.sendBeacon('/analytics', body);
}

// 각 지표 측정
onLCP(sendToAnalytics);
onINP(sendToAnalytics);
onCLS(sendToAnalytics);

// 추가 지표
import { onFCP, onTTFB } from 'web-vitals';
onFCP(sendToAnalytics);   // First Contentful Paint
onTTFB(sendToAnalytics);  // Time to First Byte
```

---

## 4. 브라우저 캐싱 메커니즘

### 4.1 브라우저 캐시 계층

```
┌─────────────────────────────────────────────────────────────────────┐
│                     브라우저 캐시 계층                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                     Memory Cache                             │   │
│   │   - 가장 빠름 (RAM)                                          │   │
│   │   - 탭/세션 닫으면 삭제                                       │   │
│   │   - 작은 리소스, 자주 접근하는 리소스                          │   │
│   │   예: 인라인 이미지, preload된 리소스                          │   │
│   └──────────────────────────────┬──────────────────────────────┘   │
│                                  │ Miss                             │
│                                  ▼                                  │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                     Disk Cache                               │   │
│   │   - 디스크 저장 (HDD/SSD)                                    │   │
│   │   - 브라우저 종료 후에도 유지                                 │   │
│   │   - Cache-Control 헤더에 따라 만료                            │   │
│   │   예: CSS, JS, 이미지 파일                                    │   │
│   └──────────────────────────────┬──────────────────────────────┘   │
│                                  │ Miss                             │
│                                  ▼                                  │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                     Service Worker Cache                     │   │
│   │   - 프로그래밍 가능한 캐시                                    │   │
│   │   - 오프라인 지원                                            │   │
│   │   - Cache API로 제어                                         │   │
│   │   예: PWA 앱 셸, 중요 리소스                                  │   │
│   └──────────────────────────────┬──────────────────────────────┘   │
│                                  │ Miss                             │
│                                  ▼                                  │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                     Push Cache (HTTP/2)                      │   │
│   │   - HTTP/2 Server Push 리소스                               │   │
│   │   - 연결 기반 (연결 종료 시 삭제)                              │   │
│   │   - 매우 짧은 수명                                           │   │
│   └──────────────────────────────┬──────────────────────────────┘   │
│                                  │ Miss                             │
│                                  ▼                                  │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                     Network Request                          │   │
│   │   - 원격 서버에서 가져옴                                      │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 HTTP 캐싱 흐름

```
┌─────────────────────────────────────────────────────────────────────┐
│                    HTTP 캐싱 결정 흐름                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌─────────────────────┐                                           │
│   │  리소스 요청 발생    │                                           │
│   └──────────┬──────────┘                                           │
│              │                                                      │
│              ▼                                                      │
│   ┌─────────────────────┐    예                                     │
│   │ 캐시에 있는가?       │────────► 만료 확인으로                     │
│   └──────────┬──────────┘                                           │
│              │ 아니오                                               │
│              ▼                                                      │
│   ┌─────────────────────┐                                           │
│   │ 네트워크 요청        │                                           │
│   │ (서버에서 가져옴)    │                                           │
│   └──────────┬──────────┘                                           │
│              │                                                      │
│              ▼                                                      │
│   ┌─────────────────────┐                                           │
│   │ 캐시 저장 가능?      │ no-store: 아니오 → 캐시 안 함              │
│   └──────────┬──────────┘                                           │
│              │ 예                                                   │
│              ▼                                                      │
│   ┌─────────────────────┐                                           │
│   │ 캐시에 저장          │                                           │
│   └─────────────────────┘                                           │
│                                                                     │
│   ─────────────────────────────────────────────────────────────     │
│                                                                     │
│   만료 확인 흐름:                                                    │
│                                                                     │
│   ┌─────────────────────┐                                           │
│   │ 캐시된 리소스        │                                           │
│   └──────────┬──────────┘                                           │
│              │                                                      │
│              ▼                                                      │
│   ┌─────────────────────┐    예    ┌───────────────────────────┐   │
│   │ max-age 지나지      │────────► │ 캐시에서 바로 사용         │   │
│   │ 않았는가?           │          │ (네트워크 요청 없음)       │   │
│   └──────────┬──────────┘          └───────────────────────────┘   │
│              │ 아니오 (만료됨)                                      │
│              ▼                                                      │
│   ┌─────────────────────┐    예    ┌───────────────────────────┐   │
│   │ must-revalidate?    │────────► │ 서버에 검증 요청           │   │
│   │ 또는 no-cache?      │          │ If-None-Match (ETag)      │   │
│   └──────────┬──────────┘          │ If-Modified-Since (Date)  │   │
│              │                     └─────────────┬─────────────┘   │
│              │                                   │                 │
│              │                                   ▼                 │
│              │                     ┌───────────────────────────┐   │
│              │                     │ 304 Not Modified?         │   │
│              │                     │ 예 → 캐시 사용            │   │
│              │                     │ 아니오 → 새 응답 사용      │   │
│              │                     └───────────────────────────┘   │
│              │ 아니오                                               │
│              ▼                                                      │
│   ┌─────────────────────┐                                           │
│   │ stale-while-        │ 예 → 캐시 사용 + 백그라운드 갱신          │
│   │ revalidate 설정?    │                                           │
│   └─────────────────────┘                                           │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.3 캐싱 전략 예시

```python
# 리소스 유형별 캐싱 전략
CACHING_STRATEGIES = {
    # 1. 정적 자산 (버전 해시 포함)
    # /static/app.a1b2c3.js
    "immutable_assets": {
        "Cache-Control": "public, max-age=31536000, immutable",
        # 1년, 절대 변하지 않음 (파일명에 해시)
    },

    # 2. HTML 문서
    "html_pages": {
        "Cache-Control": "no-cache",
        # 항상 서버 검증, ETag 사용
        "ETag": '"a1b2c3d4"',
    },

    # 3. API 응답 (공개 데이터)
    "public_api": {
        "Cache-Control": "public, max-age=300, stale-while-revalidate=60",
        # 5분 캐시, 만료 후 60초간 오래된 캐시 사용하며 갱신
    },

    # 4. API 응답 (사용자별)
    "private_api": {
        "Cache-Control": "private, max-age=60, must-revalidate",
        # 브라우저만 캐시, 1분, 만료 후 필수 검증
    },

    # 5. 민감한 데이터
    "sensitive_data": {
        "Cache-Control": "no-store",
        # 절대 캐시하지 않음
    },

    # 6. 이미지 (변경 가능)
    "images": {
        "Cache-Control": "public, max-age=86400, stale-while-revalidate=604800",
        # 1일 캐시, 1주일간 오래된 캐시 허용
    },
}
```

**Express.js 캐싱 설정:**
```javascript
const express = require('express');
const app = express();

// 정적 자산 (해시된 파일명)
app.use('/static', express.static('dist', {
    maxAge: '1y',
    immutable: true,
}));

// HTML 페이지
app.get('/', (req, res) => {
    res.set({
        'Cache-Control': 'no-cache',
        'ETag': calculateETag(content),
    });
    res.send(content);
});

// API 엔드포인트
app.get('/api/public-data', (req, res) => {
    res.set({
        'Cache-Control': 'public, max-age=300, stale-while-revalidate=60',
    });
    res.json(data);
});

// 사용자별 데이터
app.get('/api/user/profile', authenticate, (req, res) => {
    res.set({
        'Cache-Control': 'private, max-age=60',
        'Vary': 'Authorization',  // 사용자별 다른 캐시
    });
    res.json(userProfile);
});
```

### 4.4 Service Worker 캐싱

```javascript
// service-worker.js

const CACHE_NAME = 'my-app-v1';
const STATIC_ASSETS = [
    '/',
    '/index.html',
    '/css/app.css',
    '/js/app.js',
    '/images/logo.png',
];

// 설치 시 정적 자산 캐시
self.addEventListener('install', (event) => {
    event.waitUntil(
        caches.open(CACHE_NAME).then((cache) => {
            return cache.addAll(STATIC_ASSETS);
        })
    );
});

// 요청 가로채기
self.addEventListener('fetch', (event) => {
    event.respondWith(
        caches.match(event.request).then((cachedResponse) => {
            // 캐시 우선 전략 (Cache First)
            if (cachedResponse) {
                return cachedResponse;
            }

            // 네트워크로 가져와서 캐시에 저장
            return fetch(event.request).then((networkResponse) => {
                // POST 등은 캐시하지 않음
                if (event.request.method !== 'GET') {
                    return networkResponse;
                }

                // 캐시에 복사본 저장
                const responseClone = networkResponse.clone();
                caches.open(CACHE_NAME).then((cache) => {
                    cache.put(event.request, responseClone);
                });

                return networkResponse;
            });
        })
    );
});

// 캐싱 전략 변형들
const STRATEGIES = {
    // 1. Cache First (오프라인 우선)
    cacheFirst: async (request) => {
        const cached = await caches.match(request);
        return cached || fetch(request);
    },

    // 2. Network First (최신 데이터 우선)
    networkFirst: async (request) => {
        try {
            return await fetch(request);
        } catch {
            return caches.match(request);
        }
    },

    // 3. Stale While Revalidate (빠른 응답 + 갱신)
    staleWhileRevalidate: async (request) => {
        const cached = await caches.match(request);
        const fetchPromise = fetch(request).then((response) => {
            caches.open(CACHE_NAME).then((cache) => {
                cache.put(request, response.clone());
            });
            return response;
        });
        return cached || fetchPromise;
    },

    // 4. Network Only (캐시 안 함)
    networkOnly: (request) => fetch(request),

    // 5. Cache Only (네트워크 안 감)
    cacheOnly: (request) => caches.match(request),
};
```

### 4.5 ETag와 조건부 요청

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ETag 기반 조건부 요청                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  첫 번째 요청:                                                       │
│                                                                     │
│  Client                                      Server                 │
│     │                                           │                   │
│     │ ─────── GET /data.json ──────────────────►│                   │
│     │                                           │                   │
│     │ ◄─────── 200 OK ──────────────────────────│                   │
│     │          ETag: "abc123"                   │                   │
│     │          Cache-Control: no-cache          │                   │
│     │          [data]                           │                   │
│     │                                           │                   │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                     │
│  두 번째 요청 (데이터 변경 없음):                                     │
│                                                                     │
│  Client                                      Server                 │
│     │                                           │                   │
│     │ ─────── GET /data.json ──────────────────►│                   │
│     │         If-None-Match: "abc123"           │                   │
│     │                                           │                   │
│     │ ◄─────── 304 Not Modified ────────────────│                   │
│     │          (본문 없음, 대역폭 절약)          │                   │
│     │                                           │                   │
│     │          → 캐시된 데이터 사용              │                   │
│                                                                     │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                     │
│  세 번째 요청 (데이터 변경됨):                                        │
│                                                                     │
│  Client                                      Server                 │
│     │                                           │                   │
│     │ ─────── GET /data.json ──────────────────►│                   │
│     │         If-None-Match: "abc123"           │                   │
│     │                                           │                   │
│     │ ◄─────── 200 OK ──────────────────────────│                   │
│     │          ETag: "def456" (새 ETag)         │                   │
│     │          [새 data]                        │                   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**ETag 생성 방법:**
```python
import hashlib

def generate_etag(content: bytes) -> str:
    """
    콘텐츠 기반 ETag 생성 (Strong ETag)
    """
    return f'"{hashlib.md5(content).hexdigest()}"'

def generate_weak_etag(last_modified: str, size: int) -> str:
    """
    메타데이터 기반 ETag (Weak ETag)
    """
    return f'W/"{last_modified}-{size}"'

# Express.js에서
# app.use(express.static('public', { etag: true }));
# → 자동으로 파일 기반 ETag 생성
```

---

## 참고 자료

- [MDN - Critical Rendering Path](https://developer.mozilla.org/en-US/docs/Web/Performance/Guides/Critical_rendering_path)
- [web.dev - Understanding the Critical Path](https://web.dev/learn/performance/understanding-the-critical-path)
- [Chrome Developers - How Browsers Work](https://developer.chrome.com/docs/chromium/renderingng-architecture)
- [web.dev - Core Web Vitals](https://web.dev/articles/vitals)
- [MDN - HTTP Caching](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching)
- [Google - Service Worker Overview](https://developers.google.com/web/fundamentals/primers/service-workers)
- [Cloudflare - What is Web Hosting](https://www.cloudflare.com/learning/performance/what-is-http3/)
